#include "tile.h"
#include "events.h"
#include "http.h"
#include "save_system.h"

int main() {
	HANDLE hInput = CreateFileW(L"CONIN$", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, nullptr, OPEN_EXISTING, 0, nullptr);
	DWORD prev_mode;
	GetConsoleMode(hInput, &prev_mode);
	SetConsoleMode(hInput, ENABLE_EXTENDED_FLAGS | (prev_mode & ~ENABLE_QUICK_EDIT_MODE));
	srand(time(nullptr)); /*reset the seed*/
	SendConsole("" + server_name + " is now UP!", "WARN");
	SendConsole("Server is Made By GTOS", "INFO");
	SendConsole("Loading server configuration from config.json", "INFO");
	try {
		ifstream load_config("config.json"); /*load config info*/
		if (load_config.fail()) {
			load_config.close();
			SendConsole("Failed to load config.json make sure it exists and the permissions are correct", "ERROR");
			system("PAUSE");
			return -1;
		}
		json config_json;
		load_config >> config_json;
		load_config.close();
		if (config_json["enable_whitelist"] == 1) {
			for (int i = 0; i < config_json["whitelist"].size(); i++) {
				whitelist.push_back(config_json["whitelist"].at(i));
			} if (whitelist.size() != 0) {
				SendConsole("Whitelist is enabled, added " + to_string(whitelist.size()) + " players to the list", "WARN");
			} else {
				SendConsole("Whitelist is enabled", "WARN");
			}
		} for (int i = 0; i < config_json["creators"].size(); i++) {
			creators.push_back(config_json["creators"].at(i));
		} for (int i = 0; i < config_json["blacklisted_ip"].size(); i++) {
			blacklistedip.push_back(config_json["blacklisted_ip"].at(i));
		}
		SendConsole("Added " + to_string(creators.size()) + " creators to the list", "WARN");
		SendConsole("Blacklisted " + to_string(blacklistedip.size()) + " IP on the list", "WARN");
		configPort = json_to_int(config_json["server_port"]);
		server_ip = json_to_string(config_json["server_ip"]);
		server_name = json_to_string(config_json["server_name"]);
		server_discord = json_to_string(config_json["server_discord"]);
		server_website = json_to_string(config_json["server_website"]);
		server_email = json_to_string(config_json["server_email"]);
		bool debug = json_to_bool(config_json["debug"]);
		antiproxy = json_to_bool(config_json["block_proxy"]);
		if (configPort == 0 || server_ip == "" || server_name == "" || server_discord == "" || server_website == "" || server_email == "") {
			SendConsole("Misconfiguration detected please check config.json", "ERROR");
			system("PAUSE");
			return -1;
		} if (antiproxy) {
			SendConsole("You're using experimental antiproxy setting, disable it if you have issues with logging in", "WARN");
		}
		if (debug) {
			cout_cch = true;
		}
	} catch (std::exception&) {
		SendConsole("Failed to parse config.json make sure server is up to date", "ERROR");
		system("PAUSE");
		return -1; 
	} 
	//SendConsole("config.json loading completed, 0 warnings", "INFO"); 
	try {
		string c_role_name = "";
		ifstream infile("roles.xaml");
		int r_line = 0,	working_with = 0;
		bool read = false, subscriber = false;
		if (infile.fail()) {
			infile.close();
			SendConsole("Failed to load roles.xaml make sure it exists and the permissions are correct", "ERROR");
			system("PAUSE");
			return -1;
		} for (string line; getline(infile, line);) {
			if (line.length() > 3 && line.at(0) != '/' && line.at(1) != '/') {
				auto ex = explode("|", line);
				if (ex.at(0) == "<START>") {
					read = true;
					continue;
				} else if (ex.at(0) == "<SPACE>") {
					r_line = 0;
					continue;
				} else if (ex.at(0) == "<END>") {
					break;
				} if (read) {
					switch (r_line) {
						case 0:
						{
							c_role_name = ex.at(1);
							break;
						}
						case 1:
						{
							if (ex.at(1) == "none") {
								subscriber = true;
							} else {
								working_with = atoi(ex.at(1).c_str());
								role_name.insert({ c_role_name, working_with });
								role_nameko.insert({ working_with, c_role_name });
							}
							break;
						}
						case 2:
						{
							if (ex.at(1) == "none") {
								role_prefix.insert({ working_with, "" });
							} else {
								role_prefix.insert({ working_with, ex.at(1) });
							}
							break;
						}
						case 3:
						{
							if (subscriber) {
								sub_commands = explode(",", ex.at(1));
								subscriber = false;
							} else {
								role_commands.insert({ working_with, explode(",", ex.at(1)) });
							}
							break;
						}
						case 4:
						{
							if (ex.at(1) != "none") {							
								role_chat.insert({ working_with, ex.at(1) });
							}
							break;
						}
					}
					r_line++;
				}
			}
		}
		infile.close();
	} catch(const std::out_of_range& e) {
		SendConsole("Failed to load roles.xaml make sure the format is correct", "ERROR");
		system("PAUSE");
		return -1;
	} SendConsole("roles.xaml loading completed, 0 warnings", "INFO"); try {
		string type = "";
		ifstream infile("override.xaml");
		int r_line = 0, working_with = 0;
		bool read = false;
		if (infile.fail()) {
			infile.close();
			SendConsole("Failed to load override.xaml make sure it exists and the permissions are correct", "ERROR");
			system("PAUSE");
			return -1;
		} for (string line; getline(infile, line);) {
			if (line.length() > 3 && line.at(0) != '/' && line.at(1) != '/') {
				auto ex = explode("|", line);
				if (ex.at(0) == "<START>") {
					read = true;
					continue;
				}
				else if (ex.at(0) == "<SPACE>") {
					r_line = 0;
					continue;
				}
				else if (ex.at(0) == "<END>") {
					break;
				} if (read) {
					switch (r_line) {
						case 0:
						{
							type = ex.at(1);
							break;
						}
						case 1:
						{
							working_with = atoi(ex.at(1).c_str());
							break;
						}
						case 2:
						{
							if (type == "OnBreakEvent") {
								custom_gem_block.insert({ working_with, atoi(ex.at(1).c_str()) });
							}
							break;
						}
						case 3:
						{
							if (type == "OnBreakEvent") {
								if (atoi(ex.at(1).c_str()) != 0) {
									custom_drop_chance.insert({ working_with, atoi(ex.at(1).c_str()) });
								}
							}
							break;
						}
						case 4:
						{
							if (type == "OnBreakEvent") {
								if (custom_drop_chance.find(working_with) != custom_drop_chance.end()) {
									custom_drop_block.insert({ working_with, atoi(ex.at(1).c_str()) });
								}
							}
							break;
						}
					}
					r_line++;
				}
			}
		}
		infile.close();
	} catch(const std::out_of_range& e) {
		SendConsole("Failed to load override.xaml make sure the format is correct", "ERROR");
		system("PAUSE");
		return -1;
	} SendConsole("override.xaml loading completed, 0 warnings", "INFO"); try {
		ifstream infile("performance.xaml");
		int r_line = 0;
		bool read = false;
		if (infile.fail()) {
			infile.close();
			SendConsole("Failed to load performance.xaml make sure it exists and the permissions are correct", "ERROR");
			system("PAUSE");
			return -1;
		} for (string line; getline(infile, line);) {
			if (line.length() > 3 && line.at(0) != '/' && line.at(1) != '/') {
				auto ex = explode("|", line);
				if (ex.at(0) == "<START>") {
					read = true;
					continue;
				}
				else if (ex.at(0) == "<SPACE>") {
					r_line = 0;
					continue;
				}
				else if (ex.at(0) == "<END>") {
					break;
				} if (read) {
					switch (r_line) {
						case 0:
						{
							if (ex.at(0) == "visibleparticles" && ex.at(1) == "false") {
								SendConsole("Visible particles are limited to change this edit performance.xaml", "WARN");
								visibleparticles = false;
							}
							break;
						}
						case 1:
						{
							if (ex.at(0) == "worldthreading") {
								worldthreading = atoi(ex.at(1).c_str());
								if (worldthreading != 12) SendConsole("World threading set to " + to_string(worldthreading) + " to change this edit performance.xaml", "WARN");
							}
							break;
						}
						case 2:
						{
							if (ex.at(0) == "autosave" && ex.at(1) == "false") {
								SendConsole("Autosave is now disabled to change this edit performance.xaml", "WARN");
								autosave = false;
							}
							break;
						}
						case 3:
						{
							if (ex.at(0) == "jammers" && ex.at(1) == "false") {
								SendConsole("Jammers are now disabled to change this edit performance.xaml", "WARN");
								jammers = false;
							}
							break;
						}
						case 4:
						{
							if (ex.at(0) == "clearpeer" && ex.at(1) == "false") {
								SendConsole("Clearpeer are now disabled to change this edit performance.xaml", "WARN");
								clearpeer = false;
							}
							break;
						}
						case 5:
						{
							if (ex.at(0) == "webhooks" && ex.at(1) == "false") {
								SendConsole("Webhooks are now disabled to change this edit performance.xaml", "WARN");
								webhooks = false;
							}
							break;
						}
					}
					r_line++;
				}
			}
		}
		infile.close();
	}
	catch (const std::out_of_range& e) {
		SendConsole("Failed to load performance.xaml make sure the format is correct", "ERROR");
		system("PAUSE");
		return -1;
	} SendConsole("performance.xaml loading completed, 0 warnings", "INFO"); try {
		ifstream infile("items.xaml");
		int r_line = 0, working_with = 0;
		bool read = false;
		if (infile.fail()) {
			infile.close();
			SendConsole("Failed to load items.xaml make sure it exists and the permissions are correct", "ERROR");
			system("PAUSE");
			return -1;
		} for (string line; getline(infile, line);) {
			if (line.length() > 3 && line.at(0) != '/' && line.at(1) != '/') {
				auto ex = explode("|", line);
				if (ex.at(0) == "<START>") {
					read = true;
					continue;
				}
				else if (ex.at(0) == "<SPACE>") { 
					r_line = 0;
					continue;
				}
				else if (ex.at(0) == "<END>") {
					break;
				} if (read) {
					switch (r_line) {
						case 0:
						{
							if (ex.at(0) == "id") {
								working_with = atoi(ex.at(1).c_str());
							}
							break;
						}
						case 1:
						{
							if (ex.at(0) == "multiplegems") {
								if (atoi(ex.at(1).c_str()) > 1) {
									item_multiplier.insert({ working_with, atoi(ex.at(1).c_str()) });
								}
							}
							break;
						}
						case 2:
						{
							if (ex.at(0) == "onehit") {
								if (ex.at(1) == "true") {
									one_hit.insert({ working_with, true });
								}
							}
							break;
						}
						case 3:
						{
							if (ex.at(0) == "triplepunch") {
								if (ex.at(1) == "true") {
									triple_punch.insert({ working_with, true });
								}
							}
							break;
						}
						case 4:
						{
							if (ex.at(0) == "fourpunch") {
								if (ex.at(1) == "true") {
									four_punch.insert({ working_with, true });
								}
							}
							break;
						}
						case 5:
						{
							if (ex.at(0) == "fivepunch") {
								if (ex.at(1) == "true") {
									five_punch.insert({ working_with, true });
								}
							}
							break;
						}
						case 6:
						{
							if (ex.at(0) == "tripleplace") {
								if (ex.at(1) == "true") {
									triple_place.insert({ working_with, true });
								}
							}
							break;
						}
						case 7:
						{
							if (ex.at(0) == "fourplace") {
								if (ex.at(1) == "true") {
									four_place.insert({ working_with, true });
								}
							}
							break;
						}
						case 8:
						{
							if (ex.at(0) == "fiveplace") {
								if (ex.at(1) == "true") {
									five_place.insert({ working_with, true });
								}
							}
							break;
						}
						case 9:
						{
							if (ex.at(0) == "explosive") {
								if (ex.at(1) == "true") {
									explosive.insert({ working_with, true });
									if (one_hit.find(working_with) == one_hit.end()) {
										one_hit.insert({ working_with, true });
									}
								}
							}
							break;
						}
						case 10:
						{
							if (ex.at(0) == "breakeffect") {
								break_effect.insert({ working_with, atoi(ex.at(1).c_str()) });
							}
							break;
						}
					}
					r_line++;
				}
			}
		}
		infile.close();
	} catch (const std::out_of_range& e) {
		SendConsole("Failed to load items.xaml make sure the format is correct", "ERROR");
		system("PAUSE");
		return -1;
	}
	SendConsole("items.xaml loading completed, 0 warnings", "INFO");
	SetConsoleTitle("tm.me/htfg_public ");
	thread DailyKontol(DailyQuestReset);
	if (DailyKontol.joinable()) DailyKontol.detach(); /*Reset DailyQuest*/
	thread mampusMathMakinPinter(send_capcha_math);
	if (mampusMathMakinPinter.joinable()) mampusMathMakinPinter.detach(); /*Math Captcha every 10 minutes*/
	LoadEvents(true);
	ValentineEvent = true;
	LunarEvent = true;
	GrowganothEvent = true;
	SurgeryDay = true;
	GeigerDay = true;
	HarvestEvent = true;
	ifstream file("items.dat", std::ios::binary | std::ios::ate);
	int size = file.tellg();
	itemsDatSize = size;
	char* data = new char[size];
	file.seekg(0, std::ios::beg);
	if (file.read((char*)(data), size)) {
		itemsDat = new BYTE[60 + size];
		int MessageType = 0x4;
		int PacketType = 0x10;
		int NetID = -1;
		int CharState = 0x8;
		memset(itemsDat, 0, 60);
		memcpy(itemsDat, &MessageType, 4);
		memcpy(itemsDat + 4, &PacketType, 4);
		memcpy(itemsDat + 8, &NetID, 4);
		memcpy(itemsDat + 16, &CharState, 4);
		memcpy(itemsDat + 56, &size, 4);
		file.seekg(0, std::ios::beg);
		if (file.read((char*)(itemsDat + 60), size)) {
			uint8_t* pData;
			size = 0;
			const char filename[] = "items.dat";
			size = filesize(filename);
			pData = getA((string)filename, &size, false, false);
			SendConsole("Items.dat loaded, hash " + to_string(HashString((unsigned char*)pData, size)) + "", "INFO");
			itemdathash = HashString((unsigned char*)pData, size);
			file.close();
		}
	} else {
		SendConsole("Failed to load items.dat make sure it exists and the permissions are correct", "ERROR");
		system("PAUSE");
		return -1;
	}
	enet_initialize(); /*enet*/
	ENetAddress address;
	enet_address_set_host(&address, "0.0.0.0");
	address.port = configPort; 
	server = enet_host_create(&address, 1024, 10, 0, 0);
	if (server == nullptr) {
		SendConsole("Failed to start enet service, is port " + to_string(configPort) + " already taken?", "ERROR");
		system("PAUSE");
		return -1;
	}
	SendConsole("Enet service started, listening on " + to_string(configPort), "INFO");
	server->checksum = enet_crc32;
	enet_host_compress_with_range_coder(server);
	buildItemsDatabase();
	//std::thread two(updateAnswer);
	//two.detach();
	if (autosave) threads.push_back(std::thread(save_manager));
	ENetEvent event;
	while (true) { 
		while (enet_host_service(server, &event, 1000) > 0) {
			ENetPeer* peer = event.peer;
			switch (event.type) {
				case ENET_EVENT_TYPE_CONNECT:
				{
					if (getPlayersCountInServer() >= 170) {
						GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), " `4OOPS: `oMax player in Server is `2170 Online`o. Please click `5CANCEL `oand try again in a few seconds.``"));
						ENetPacket* packet = enet_packet_create(p.data,
							p.len,
							ENET_PACKET_FLAG_RELIABLE);
						enet_peer_send(peer, 0, packet);
						delete p.data;
						//enet_host_flush(server);
						enet_peer_disconnect_later(peer, 0);
					}
					else
					{
						event.peer->data = new PlayerInfo;
							sendData(event.peer, 1, nullptr, 0);
							ofstream write_new_online("online_count.txt");
							write_new_online << atoi(GetPlayerCountServer().c_str());
							write_new_online.close();
							break;
					}
				}
				case ENET_EVENT_TYPE_RECEIVE:
				{
					ENetPeer* peer = event.peer;
					if (peer->data == NULL) continue;
					PlayerInfo* pData = GetPeerData(peer);
					int messageType = GetMessageTypeFromPacket(event.packet);
					WorldInfo* world = worldDB.get_pointer(pData->currentWorld);
					if (world == NULL) continue;
					switch (messageType) {
						case 2:
						{
							string cch = GetTextPointerFromPacket(event.packet);
							if (cch.size() > 2048 || cch.size() <= 3 || cch == "" || cch == " " || cch == "  " || cch == "   " || cch == "    " || cch == "     " || cch == "      " || cch == "       " || cch == "        ") break;
							if (!pData->passed_data_check) { /*login*/
								try {
									stringstream ss(GetTextPointerFromPacket(event.packet));
									string to = "";
									while (std::getline(ss, to, '\n')) {
										if (to.find('|') == -1) continue;
										string id = to.substr(0, to.find("|"));
										string act = to.substr(to.find("|") + 1, to.length() - to.find("|") - 1);
										if (id == "tankIDName") {
											if (act.length() > 25) break;
											pData->tankIDName = act;
											pData->haveGrowId = true;
										}
										else if (id == "tankIDPass") {
											pData->tankIDPass = act;
										}
										else if (id == "requestedName") {
											pData->requestedName = act;
										}
										else if (id == "country") {
											pData->country = act;
										}
										else if (id == "game_version") {
											pData->gameversion = act;
										}
										else if (id == "rid") {
											pData->rid = act;
											if (act.length() < 32) break;
											if (act.length() > 36) break;
											if (act == "01405CAC015A0E02063E7F4810290291") break;
										}
										else if (id == "wk") {
											if (act.length() < 32) break;
											if (act.length() > 36) break;
											pData->sid = act;
										}
										else if (id == "zf") {
											if (act == "-1576481813") break;
											pData->zf = act;
										}
										else if (id == "meta") {
											pData->metaip = act;
										}
										else if (id == "hash2") {
											if (act.length() != 0) {
												if (act.length() > 16) break;
											}
											if (act == "231347357") break;
										}
										else if (id == "platformID") {
											if (act.length() == 0) break;
											pData->platformID = act;
										}
										else if (id == "player_age") {
											pData->player_age = act;
										}
										else if (id == "fhash") {
											pData->fhash = act;
										}
										else if (id == "mac") {
											pData->mac = act;
											if (act.length() < 16) break;
											if (act.length() > 20) break;
										}
										else if (id == "hash") {
											if (act.length() != 0) {
												if (act.length() < 6) break;
												if (act.length() > 16) break;
											}
										}
										else if (id == "aid") {
											pData->aid = act;
										}
										else if (id == "houstonProductID") {
											pData->hpid = act;
										}
										else if (id == "gid") {
											pData->gid = act;
										}
										else if (id == "vid") {
											pData->vid = act;
										}
										else if (id == "f") {
											pData->f = act;
										}
										else if (id == "fz") {
											pData->fz = act;
										}
										else if (id == "lmode") {
											pData->lmode = act;
										}
										else if (id == "user") {
											pData->user = act;
										}
										else if (id == "token") {
											pData->token = act;
										}
										else if (id == "GDPR") {
											pData->gdpr = act;
										}
										else if (id == "deviceVersion") {
											pData->deviceversion = act;
										}
										else if (id == "doorID") {
											pData->doorID = act;
										}
										char clientConnection[16];
										enet_address_get_host_ip(&peer->address, clientConnection, 16);
										pData->charIP = clientConnection;
									} if (pData->mac == "" || pData->rid == "" || pData->player_age == "") {
										enet_peer_disconnect_later(peer, 0);
									} if (std::find(blacklistedip.begin(), blacklistedip.end(), pData->charIP) != blacklistedip.end()) {
										FailLogin(peer, "action|log\nmsg|`4Your IP has been blacklisted by " + server_name + "", false);
										break;
									} if (antiproxy) {
										if (pData->charIP != "0" && http::cooldown.find(pData->charIP) == http::cooldown.end()) {
											FailLogin(peer, "action|log\nmsg|`4Error logging you in caused by antiproxy", false);
											break;
										}
										else if (pData->charIP != "0" && GetCurrentTimeInternalSeconds() - 5 >= http::cooldown.at(pData->charIP) - 6) {
											FailLogin(peer, "action|log\nmsg|`4Your wifi signal is too poor to play this server caused by antiproxy", false);
											break;
										}
									}
									gamepacket_t p;
									p.Insert("OnSuperMainStartAcceptLogonHrdxs47254722215a");
									p.Insert(itemdathash);
									p.Insert("www.growtopia1.com");
									p.Insert("cache/");
									p.Insert("cc.cz.madkite.freedom org.aqua.gg idv.aqua.bulldog com.cih.gamecih2 com.cih.gamecih com.cih.game_cih cn.maocai.gamekiller com.gmd.speedtime org.dax.attack com.x0.strai.frep com.x0.strai.free org.cheatengine.cegui org.sbtools.gamehack com.skgames.traffikrider org.sbtoods.gamehaca com.skype.ralder org.cheatengine.cegui.xx.multi1458919170111 com.prohiro.macro me.autotouch.autotouch com.cygery.repetitouch.free com.cygery.repetitouch.pro com.proziro.zacro com.slash.gamebuster");
									p.Insert("proto=200|choosemusic=audio/mp3/about_theme.mp3|active_holiday=18|wing_week_day=0|ubi_week_day=0|server_tick=22890597|clash_active=1|drop_lavacheck_faster=1|isPayingUser=0|usingStoreNavigation=1|enableInventoryTab=1|bigBackpack=1|");
									p.CreatePacket(peer);
									if (pData->haveGrowId) {
										int logStatus = PlayerDB::playerLogin(peer, pData->tankIDName, pData->tankIDPass);
										switch (logStatus) {
										case -5:
										{
											break;
										}
										case -4:
										{
											break;
										}
										case -3:
										{
											FailLogin(peer, "action|log\nmsg|`4Sorry, this account (`5" + PlayerDB::getProperName(pData->tankIDName) + "`4) has been suspended. Contact `FrAnCe#5325 or DESxKIRITO#9308 `4if you have any questions.", false);
											break;
										}
										case -6:
										{
											FailLogin(peer, "action|log\nmsg|`4Advanced Account Protection: `oYou tried to log in from the new Device and IP. A verification email was sent to the email address registered with this GrowID (" + pData->email + "). Please follow the link in that email to whitelist this device and IP.", false);
											//FailLogin(peer, "action|log\nmsg|`4Your account have been compromised, there was data breach which happened 2/28/2021 your account was in it to unlock this account message Sebia#1234", false);
											//threads.push_back(std::thread(SendAAPNotification, pData->email, pData->charIP, PlayerDB::getProperName(pData->tankIDName)));
											break;
										}
										case -7:
										{
											if (!isDev(peer));
											FailLogin(peer, "action|log\nmsg|`5Server under maintenance we will be back soon!", true);
											break;
										}
										case -8:
										{
											FailLogin(peer, "action|log\nmsg|`4Sorry, this account, device or location has been temporarily suspended.<CR>`oIf you didn't do anything wrong, it could be because you're playing from the same place or on the same device as someone who did. Contact support at `5" + server_email + " `oif you have any questions. This is a temporary ban caused by `w" + pData->rawName + " `oand will be removed in `w" + OutputBanTime(calcBanDuration(pData->timeBanned)) + "`o. If that's not your name, try playing from another location or device to fix it.", false);
											break;
										}
										case -9:
										{
											FailLogin(peer, "action|log\nmsg|`4Sorry, this device or location is perma banned.", false);
											break;
										}
										case -10:
										{
											FailLogin(peer, "action|log\nmsg|`4ALREADY ON?! `o: This account was already online, kicking it off so you can log on. (if you were just playing before, this is nothing to worry about)", false);
											break;
										}
										case -20:
										{
											FailLogin(peer, "action|log\nmsg|`4Your ip has been blacklisted by " + server_name + ".", false);
											break;
										}
										case -1:
										{
											FailLogin(peer, "action|log\nmsg|`4Unable to log on: `oThat `wGrowID `odoesn't seem valid`w, `oor the password is wrong`w. `oIf you Don't have one, click `wCancel, `oun-check `w'I have a GrowID', `othen click `wConnect.", true);
											break;
										}
										case 1:
										{
											pData->HasLogged = true;
											break;
										}
										default:
										{
											break;
										}
										}
									}
									pData->passed_data_check = true;
								}
								catch (const std::out_of_range& e) {
									std::cout << e.what() << std::endl;
								}
								break;
							}
							if (cch == "action|enter_game\n" && pData->passed_data_check) {
								if (GlobalMaintenance) {
									FailLogin(peer, "action|log\nmsg|`5The game is currently undergoing maintenance. We will be back soon.", false);
									continue;
								}
								if (!pData->haveGrowId) {
									thread Playtime(ThreadPlaytime, peer);
									if (Playtime.joinable()) Playtime.detach();
									pData->rawName = "" + PlayerDB::fixColors(pData->requestedName.substr(0, pData->requestedName.length() > 15 ? 15 : pData->requestedName.length()) + "_" + to_string(rand() % 1000));
									pData->msgName = std::to_string(peer->address.host);
									pData->displayName = PlayerDB::fixColors(pData->requestedName.substr(0, pData->requestedName.length() > 15 ? 15 : pData->requestedName.length()) + "_" + to_string(rand() % 1000));
									pData->tankIDName = PlayerDB::fixColors(pData->requestedName.substr(0, pData->requestedName.length() > 15 ? 15 : pData->requestedName.length()) + "_" + to_string(rand() % 1000));
									pData->displayNamebackup = pData->displayName;
									string lower = pData->rawName;
									std::transform(lower.begin(), lower.end(), lower.begin(), ::toupper);
									checkIpBan(peer);
								}
								else {
									if (!pData->HasLogged) {
										break;
									}
									LoadPlayerData(peer);
								}
								if (pData->country.length() > 4) {
									pData->country = "us";
								} if (pData->haveGrowId) {
									GamePacket p9 = packetEnd(appendInt(appendString(createPacket(), "SetHasAccountSecured"), 1));
									ENetPacket* packet9 = enet_packet_create(p9.data, p9.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet9);
									delete p9.data;
									GamePacket p36 = packetEnd(appendString(appendString(appendInt(appendString(createPacket(), "SetHasGrowID"), 1), pData->tankIDName), pData->tankIDPass));
									ENetPacket* packet36 = enet_packet_create(p36.data, p36.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet36);
									delete p36.data;
								}
								else {
									GamePacket p42 = packetEnd(appendString(appendString(appendInt(appendString(createPacket(), "SetHasGrowID"), 0), ""), ""));
									ENetPacket* packet42 = enet_packet_create(p42.data, p42.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet42);
									delete p42.data;
								}
								pData->isIn = true;
								GamePacket p2ssw = packetEnd(appendString(appendInt(appendString(createPacket(), "OnEmoticonDataChanged"), 0), u8"(wl)|ā|1&(yes)|Ă|1&(no)|ă|1&(love)|Ą|1&(oops)|ą|1&(shy)|Ć|1&(wink)|ć|1&(tongue)|Ĉ|1&(agree)|ĉ|1&(sleep)|Ċ|1&(punch)|ċ|1&(music)|Č|1&(build)|č|1&(megaphone)|Ď|1&(sigh)|ď|1&(mad)|Đ|1&(wow)|đ|1&(dance)|Ē|1&(see-no-evil)|ē|1&(bheart)|Ĕ|1&(heart)|ĕ|1&(grow)|Ė|1&(gems)|ė|1&(kiss)|Ę|1&(gtoken)|ę|1&(lol)|Ě|1&(smile)|Ā|1&(cool)|Ĝ|1&(cry)|ĝ|1&(vend)|Ğ|1&(bunny)|ě|1&(cactus)|ğ|1&(pine)|Ĥ|1&(peace)|ģ|1&(terror)|ġ|1&(troll)|Ġ|1&(evil)|Ģ|1&(fireworks)|Ħ|1&(football)|ĥ|1&(alien)|ħ|1&(party)|Ĩ|1&(pizza)|ĩ|1&(clap)|Ī|1&(song)|ī|1&(ghost)|Ĭ|1&(nuke)|ĭ|1&(halo)|Į|1&(turkey)|į|1&(gift)|İ|1&(cake)|ı|1&(heartarrow)|Ĳ|1&(lucky)|ĳ|1&(shamrock)|Ĵ|1&(grin)|ĵ|1&(ill)|Ķ|1&"));
								ENetPacket* packet2ssw = enet_packet_create(p2ssw.data,
									p2ssw.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet2ssw);
								delete p2ssw.data;
								if (pData->haveGrowId) {
									string name = pData->displayName;
									int onlinecount = 0;
									int totalcount = pData->friendinfo.size();
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
										if (find(pData->friendinfo.begin(), pData->friendinfo.end(), static_cast<PlayerInfo*>(currentPeer->data)->rawName) != pData->friendinfo.end()) {
											onlinecount++;
										}
									} if (onlinecount == 0) {
										Player::OnConsoleMessage(peer, "Welcome back to " + server_name + ", `w" + name + "`o. No friends are online.");
									}
									else {
										Player::OnConsoleMessage(peer, "Welcome back to " + server_name + ", `w" + name + "`o. `w" + to_string(onlinecount) + "`o friend is online.");
									}
									//if (ValentineEvent) Player::OnConsoleMessage(peer, "`4Happy Valentine's Week!``");
									//if (LunarEvent) Player::OnConsoleMessage(peer, "`9Happy Lupnar New Year``");
									Player::OnConsoleMessage(peer, "`oWhere would you like to go? (`w" + GetPlayerCountServer() + " `oonline)");
									if (gem_multiplier != 0) Player::OnConsoleMessage(peer, "`9There is a `#" + to_string(gem_multiplier) + "x `9gem event going-on! Don't miss it.");
									GamePacket p36 = packetEnd(appendString(appendString(appendInt(appendString(createPacket(), "SetHasGrowID"), 1), pData->tankIDName), pData->tankIDPass));
									ENetPacket* packet36 = enet_packet_create(p36.data, p36.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet36);
									delete p36.data;
									GamePacket p9 = packetEnd(appendInt(appendString(createPacket(), "SetHasAccountSecured"), 1));
									ENetPacket* packet9 = enet_packet_create(p9.data, p9.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet9);
									delete p9.data;
									GamePacket p12 = packetEnd(appendInt(appendInt(appendString(createPacket(), "OnTodaysDate"), 2), 6));
									ENetPacket* packet12 = enet_packet_create(p12.data, p12.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet12);
									delete p12.data;
									GamePacket p19 = packetEnd(appendInt(appendString(createPacket(), "SetShowChatOnlyFromFriends"), 0));
									ENetPacket* packet19 = enet_packet_create(p19.data, p19.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet19);
									delete p19.data;
									updateplayerset(peer, pData->cloth_hand);
									updateplayerset(peer, pData->cloth_face);
									updateplayerset(peer, pData->cloth_mask);
									updateplayerset(peer, pData->cloth_shirt);
									updateplayerset(peer, pData->cloth_ances);
									updateplayerset(peer, pData->cloth_pants);
									updateplayerset(peer, pData->cloth_necklace);
									updateplayerset(peer, pData->cloth_feet);
									updateplayerset(peer, pData->cloth_back);
									if (pData->haveGrowId) {
										sendWorldOffers(peer);
									}
									std::ifstream news("news.txt");
									std::stringstream buffer;
									buffer << news.rdbuf();
									std::string newsString(buffer.str());
									Player::OnDialogRequest(peer, newsString);
									bool iscontains = false, success = true;
									SearchInventoryItem(peer, 18, 1, iscontains);
									if (!iscontains) SaveItemMoreTimes(18, 1, peer, success);
									SearchInventoryItem(peer, 32, 1, iscontains);
									if (!iscontains) SaveItemMoreTimes(32, 1, peer, success);
								}
								else {
									PlayerInventory inventory;
									InventoryItem item{};
									item.itemCount = 1;
									item.itemID = 18;
									inventory.items.push_back(item);
									item.itemCount = 1;
									item.itemID = 32;
									inventory.items.push_back(item);
									SendInventory(peer, inventory);
									pData->inventory = inventory;
									handle_world(peer, "START");
								} for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
									string name = static_cast<PlayerInfo*>(currentPeer->data)->rawName;
									if (find(pData->friendinfo.begin(), pData->friendinfo.end(), name) != pData->friendinfo.end()) {
										Player::OnConsoleMessage(currentPeer, "`3FRIEND ALERT: `o" + pData->displayName + " `ohas `2logged on`o.");
									}
								}
								break;
							}
							if (cch == "action|refresh_item_data\n") {
								if (itemsDat != NULL) {
									ENetPacket* packet = enet_packet_create(itemsDat, static_cast<size_t>(itemsDatSize) + 60, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									pData->isUpdating = true;
									enet_peer_disconnect_later(peer, 0);
								}
								break;
							}
							else if (cch == "action|claimprogressbar\n") {
								if (ValentineEvent) {
									if (pData->bootybreaken >= 100) {
										Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wAbout Valentine's Event``|left|384|\nadd_spacer|small|\nadd_textbox|During Valentine's Week you will gain points for opening Golden Booty Chests. Claim enough points to earn bonus rewards.|left|\nadd_spacer|small|\nadd_textbox|Current Progress: " + to_string(pData->bootybreaken) + "/100|left|\nadd_spacer|small|\nadd_textbox|Reward:|left|\nadd_label_with_icon|small|Super Golden Booty Chest|left|9350|\nadd_smalltext|             - 4x chance of getting a Golden Heart Crystal when opening!|left|\nadd_spacer|small|\nadd_button|claimreward|Claim Reward|no_flags|0|0|\nend_dialog|valentines_quest||OK|");
									}
									else {
										Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wAbout Valentine's Event``|left|384|\nadd_spacer|small|\nadd_textbox|During Valentine's Week you will gain points for opening Golden Booty Chests. Claim enough points to earn bonus rewards.|left|\nadd_spacer|small|\nadd_textbox|Current Progress: " + to_string(pData->bootybreaken) + "/100|left|\nadd_spacer|small|\nadd_textbox|Reward:|left|\nadd_label_with_icon|small|Super Golden Booty Chest|left|9350|\nadd_smalltext|             - 4x chance of getting a Golden Heart Crystal when opening!|left|\nend_dialog|valentines_quest||OK|");
									}
								}
								break;
							}
							else if (cch == "action|showzodiacpets\n") {
								if (!LunarEvent) break;
								auto p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\nadd_label_with_icon|big|`wZodiac Animals : Collect them all``|left|10614|\nadd_spacer|small|\nadd_textbox|Every `2Oriental Spice Spray`` Pack purchased will add progress to unlocking the `2Zodiac Animals!``|left|\nadd_spacer|small|\nadd_textbox|There's an animal representing each anniversary of Growtopia! Each Zodiac Animal will be available for only 8 Hours. This will be the only time the item will be available in the store.|left|\nadd_spacer|small|\nadd_textbox|The first animal unlocked will be the mighty `2Zodiac Ox``! The next Animals unlocked will be chosen randomly! Any Zodiac Animals remaining locked at the end of the event will return next year along with the 2022 Animal! So the collection can continue!|left|\nadd_spacer|small|\nend_dialog|zodiacpets_quest||OK|"));
								auto respawnTimeout = 500;
								auto deathFlag = 0x19;
								memcpy(p2.data + 24, &respawnTimeout, 4);
								memcpy(p2.data + 56, &deathFlag, 4);
								const auto packet2 = enet_packet_create(p2.data, p2.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet2);
								delete p2.data;
								break;
							}
							else if (cch.find("action|input\n|text|") == 0) {
								std::stringstream ss(cch);
								std::string to;
								string idx = "     ";
								while (std::getline(ss, to, '\n'))
								{
									vector<string> infoDat = explode("|", to);
									if (infoDat.at(1) == "text") idx = infoDat.at(2);
								}
								if (idx != "") {

								}
								else
								{
									cch.clear();
									cch.erase(std::remove(cch.begin(), cch.end(), '\n'), cch.end());
									Player::OnAddNotification(peer, "`wYou have been banned for using crasher to crash " + server_name + "!", "audio/hub_open.wav", "interface/atomic_button.rttex");
									autoBan(peer, true, 100000, "using crasher");
									cout << "Player " + static_cast<PlayerInfo*>(peer->data)->displayName + " has been banned for trying to crash " + server_name + "!" << endl;
									break;
								}
							}
							else if (cch.find("action|wrench") == 0) {
								try {
									if (pData->trade) end_trade(peer);
									std::stringstream ss(cch);
									std::string to;
									int id = -1;
									while (std::getline(ss, to, '\n')) {
										vector<string> infoDat = explode("|", to);
										if (infoDat.at(1).size() <= 4 || infoDat.at(1).size() >= 6)
										{
											//break;
										}
										else if (infoDat.at(1) != "netid")
										{
											//break;g
										}
										else if (infoDat.at(1) == "netid")
										{
											id = atoi(infoDat.at(2).c_str());
										}
									}
									if (id < 0) continue;
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
										if (isHere(peer, currentPeer)) {
											if (static_cast<PlayerInfo*>(currentPeer->data)->netID == id) {
												pData->lastInfo = static_cast<PlayerInfo*>(currentPeer->data)->rawName;
												pData->lastInfoname = static_cast<PlayerInfo*>(currentPeer->data)->tankIDName;
												pData->lastDisplayname = static_cast<PlayerInfo*>(currentPeer->data)->displayName;
												int plrGems = 0;
												int adminLevel = static_cast<PlayerInfo*>(currentPeer->data)->adminLevel;
												string plrRole = role_nameko.at(adminLevel);
												ifstream getPlrGems("save/gemdb/_" + static_cast<PlayerInfo*>(currentPeer->data)->rawName + ".txt");
												getPlrGems >> plrGems;
												getPlrGems.close();
												string name = static_cast<PlayerInfo*>(currentPeer->data)->displayName;
												string rawnam = pData->rawName;
												string rawnamofwrench = static_cast<PlayerInfo*>(currentPeer->data)->rawName;
												string guildlabel = "";
												string levellabel = "";
												string gemslabel = "\nadd_label_with_icon|small|`9Gems : " + to_string(plrGems) + "|left|112|\nadd_spacer|small|";
												string rolelabel = "\nadd_label_with_icon|small|`9Role : " + plrRole + "|left|7634|\nadd_spacer|small|";
												string ntblabel = "\nadd_label_with_icon|small|`9Note : " + static_cast<PlayerInfo*>(currentPeer->data)->notebook + "|left|6336|\nadd_spacer|small|";
												if (static_cast<PlayerInfo*>(currentPeer->data)->guild == "") {
													guildlabel = "";
												}
												else {
													string guild_rank = "Member";
													if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == static_cast<PlayerInfo*>(currentPeer->data)->guildLeader) guild_rank = "`eLeader";
													if (static_cast<PlayerInfo*>(currentPeer->data)->guild != "") {
														std::ifstream ifff("save/guilds/_" + PlayerDB::getProperName(static_cast<PlayerInfo*>(currentPeer->data)->guild) + ".json");
														if (ifff.fail()) {
															ifff.close();
															continue;
														}
														if (ifff.is_open()) {
														}
														json j;
														ifff >> j; //load
														vector<string> GE;
														vector<string> GC;
														for (int i = 0; i < j["Elder-Leader"].size(); i++) {
															GE.push_back(j["Elder-Leader"][i]);
														}
														for (int i = 0; i < j["Co-Leader"].size(); i++) {
															GC.push_back(j["Co-Leader"][i]);
														}
														if (find(GE.begin(), GE.end(), static_cast<PlayerInfo*>(currentPeer->data)->rawName) != GE.end()) guild_rank = "`9Guild-Elder";
														if (find(GC.begin(), GC.end(), static_cast<PlayerInfo*>(currentPeer->data)->rawName) != GC.end()) guild_rank = "`8Co-Leader";
													}
													if (static_cast<PlayerInfo*>(currentPeer->data)->guildFg != 0 && static_cast<PlayerInfo*>(currentPeer->data)->guildBg != 0) {
														guildlabel = "\nadd_dual_layer_icon_label|small|`9Guild: `2" + static_cast<PlayerInfo*>(currentPeer->data)->guild + "``|left|" + std::to_string(static_cast<PlayerInfo*>(currentPeer->data)->guildBg) + "|" + std::to_string(static_cast<PlayerInfo*>(currentPeer->data)->guildFg) + "|1.0|1|\nadd_textbox|`9Rank: `2" + guild_rank + "``|left|\nadd_spacer|small|";
													}
													else {
														guildlabel = "";
													}
												}
												if (isDev(currentPeer) && static_cast<PlayerInfo*>(currentPeer->data)->isNicked == false) {
													levellabel = "?";
												}
												else {
													levellabel = to_string(static_cast<PlayerInfo*>(currentPeer->data)->level);
												}
												string guilddialog = ""; // \nadd_button|inviteguildbutton|`2Invite to Guild|0|0|
												if (pData->guild != "") {
													std::ifstream ifff("save/guilds/_" + PlayerDB::getProperName(pData->guild) + ".json");
													if (ifff.fail()) {
														ifff.close();
														continue;
													}
													if (ifff.is_open()) {
													}
													json j;
													ifff >> j; //load
													vector<string> GE;
													vector<string> GC;
													for (int i = 0; i < j["Elder-Leader"].size(); i++) {
														GE.push_back(j["Elder-Leader"][i]);
													}
													for (int i = 0; i < j["Co-Leader"].size(); i++) {
														GC.push_back(j["Co-Leader"][i]);
													}
													if (find(GE.begin(), GE.end(), pData->rawName) != GE.end() || find(GC.begin(), GC.end(), pData->rawName) != GC.end() || pData->rawName == pData->guildLeader) guilddialog = "\nadd_button|inviteguildbutton|`2Invite to Guild|0|0|";
												}
												if (static_cast<PlayerInfo*>(currentPeer->data)->guild != "" || static_cast<PlayerInfo*>(peer->data)->haveGrowId == false) guilddialog = "";
												if (rawnamofwrench != rawnam) {
													if (rawnamofwrench != "") {
														if (!restricted_area(peer, world, static_cast<PlayerInfo*>(currentPeer->data)->x / 32, static_cast<PlayerInfo*>(currentPeer->data)->y / 32) && world->owner == "" || world->owner == pData->rawName && pData->haveGrowId || isMod(peer)) {
															if (isMod(peer)) {
																Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`w" + name + " `w(`2" + levellabel + "`w)``|left|18|\nadd_spacer|small|" + ntblabel + gemslabel + rolelabel + guildlabel + "\nadd_button|punishview|`!Punish/View|0|0|\nadd_button|trade|`wTrade``|noflags|0|0|\nadd_textbox|(No Battle Leash equipped)|left|\nadd_textbox|Your opponent needs a valid license to battle!|left|\nadd_button|kick|`4Kick``|noflags|0|0|\nadd_button|pull|`5Pull``|noflags|0|0|\nadd_button|wban|`4World Ban``|noflags|0|0|" + guilddialog + "\nadd_button|addfriendrnbutton|`wAdd as friend``|noflags|0|0|\nadd_button|ignore_player|`wIgnore Player``|noflags|0|0|\nadd_button|report_player|`wReport Player``|noflags|0|0|\nadd_spacer|small|\nend_dialog|popup||Continue|\nadd_quick_exit|");
															}
															else {
																if (!restricted_area(peer, world, static_cast<PlayerInfo*>(currentPeer->data)->x / 32, static_cast<PlayerInfo*>(currentPeer->data)->y / 32) && world->owner == "") {
																	Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`w" + name + " `w(`2" + levellabel + "`w)``|left|18|\nadd_spacer|small|" + ntblabel + gemslabel + rolelabel + guildlabel + "\nadd_button|trade|`wTrade``|noflags|0|0|\nadd_textbox|(No Battle Leash equipped)|left|\nadd_textbox|Your opponent needs a valid license to battle!|left|\nadd_button|kick|`4Kick``|noflags|0|0|\nadd_button|pull|`5Pull``|noflags|0|0|" + guilddialog + "\nadd_button|addfriendrnbutton|`wAdd as friend``|noflags|0|0|\nadd_button|ignore_player|`wIgnore Player``|noflags|0|0|\nadd_button|report_player|`wReport Player``|noflags|0|0|\nadd_spacer|small|\nend_dialog|popup||Continue|\nadd_quick_exit|");
																}
																else {
																	Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`w" + name + " `w(`2" + levellabel + "`w)``|left|18|\nadd_spacer|small|" + ntblabel + gemslabel + rolelabel + guildlabel + "\nadd_button|trade|`wTrade``|noflags|0|0|\nadd_textbox|(No Battle Leash equipped)|left|\nadd_textbox|Your opponent needs a valid license to battle!|left|\nadd_button|kick|`4Kick``|noflags|0|0|\nadd_button|pull|`5Pull``|noflags|0|0|\nadd_button|wban|`4World Ban``|noflags|0|0|" + guilddialog + "\nadd_button|addfriendrnbutton|`wAdd as friend``|noflags|0|0|\nadd_button|ignore_player|`wIgnore Player``|noflags|0|0|\nadd_button|report_player|`wReport Player``|noflags|0|0|\nadd_spacer|small|\nend_dialog|popup||Continue|\nadd_quick_exit|");
																}
															}
														}
														else {
															Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`w" + name + " `w(`2" + levellabel + "`w)``|left|18|\nadd_spacer|small|" + ntblabel + gemslabel + rolelabel + guildlabel + "\nadd_button|trade|`wTrade``|noflags|0|0|\nadd_textbox|(No Battle Leash equipped)|left|\nadd_textbox|Your opponent needs a valid license to battle!|left|" + guilddialog + "\nadd_button|addfriendrnbutton|`wAdd as friend``|noflags|0|0|\nadd_button|ignore_player|`wIgnore Player``|noflags|0|0|\nadd_button|report_player|`wReport Player``|noflags|0|0|\nadd_spacer|small|\nend_dialog|popup||Continue|\nadd_quick_exit|");
														}
													}
												}
												else {
													if (pData->haveGrowId == true) {
														send_info(peer, pData);
													}
													else
													{
														SendRegisterDialog(peer);
														enet_host_flush(server);
													}
												}
											}
										}
									}
								}
								catch (const std::out_of_range& e) {
									std::cout << e.what() << std::endl;
								}
								break;
							}
							else if (cch.find("action|setSkin") == 0) {
								if (!world) continue;
								try {
									std::stringstream ss(cch);
									std::string to;
									int id = -1;
									string color = "";
									while (std::getline(ss, to, '\n')) {
										vector<string> infoDat = explode("|", to);
										if (infoDat.at(0) == "color") color = infoDat.at(1);
										if (has_only_digits(color) == false) continue;
										id = atoi(color.c_str());
										if (color == "2190853119") id = -2104114177;
										else if (color == "2527912447") id = -1767054849;
										else if (color == "2864971775") id = -1429995521;
										else if (color == "3033464831") id = -1261502465;
										else if (color == "3370516479") id = -924450817;
									}
									pData->skinColor = id;
									sendClothes(peer);
								}
								catch (const std::out_of_range& e) {
									std::cout << e.what() << std::endl;
								}
								break;
							}
							else if (cch == "action|respawn\n") {
								playerRespawn(world, peer, false);
								break;
							}
							else if (cch.find("action|respawn_spike") == 0) {
								playerRespawn(world, peer, false);
								break;
							}
							else if (cch.find("action|friends\n") == 0) {
								string GuildButtonDialog = "";
								if (pData->guild != "") {
									GuildButtonDialog = "\nadd_button|showguild|`wShow Guild Members``|noflags";
								} else {
									GuildButtonDialog = "\nadd_button|createguildinfo|`wCreate Guild``|noflags";
								}
								Player::OnDialogRequest(peer, " set_default_color|`o\nadd_label_with_icon|big| `wSocial Portal`` |left|1366|\nadd_spacer|small|\nadd_button|showfriend|`wShow Friends``|noflags|0|0|\nadd_button|show_apprentices|`wShow Apprentices``|noflags|0|0|" + GuildButtonDialog + "|0|0|\nadd_button|communityhub|`wCommunity Hub``|noflags|0|0|\nadd_button|trade_history|`wTrade History``|noflags|0|0|\nadd_quick_exit|\nend_dialog|friends_guilds|OK||");
								break;
							}
							else if (cch == "action|growid\n") {
								SendRegisterDialog(peer);
								enet_host_flush(server);
								break;
							}
							else if (cch == "action|eventmenu\n") {
								Player::OnTextOverlay(peer, "Events are under development!");
								break;
								// ReSharper disable once CppUnreachableCode
								if (pData->haveGrowId == false) {
									SendRegisterDialog(peer);
								} else {
									if (pData->guild == "") {
										Player::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`9Guild Rewards And Challenges``|left|7340|\nadd_spacer|small|\nadd_textbox|`5Join or Create a `^Guild `5In order to access `cGuild Rewards`5!|\nadd_spacer|small|\nadd_button|cl0se|`wClose|\nadd_quick_exit|");
										continue;
									}
									int gpoints = 0;
									ifstream guildstream1("save/guildrewards/guildpoints/" + pData->guild + ".txt");
									guildstream1 >> gpoints;
									guildstream1.close();
									int personalpoints = 0;
									ifstream guildstream3("save/guildrewards/contribution/" + pData->guild + "/" + pData->rawName + ".txt");
									guildstream3 >> personalpoints;
									guildstream3.close();
									Player::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`9Guild Rewards And Challenges``|left|7340|\nadd_label|small|`5Your guild currently have: `^" + std::to_string(gpoints) + " `5Points.|left|4||\nadd_label|small|`5Your personal contribution are: `^" + std::to_string(personalpoints) + " `5Points.|left|4||\nadd_spacer|small|\nadd_button|grewards|`wSpend Guild Points``|0|0|\nadd_button|gcontribution|`wMembers Contribution``|0|0|\nadd_spacer|small|\nadd_textbox|`2Guild `^Points `5Are `@Obtainable `5From those `9Activities`5: Usage of `9Magic Machine`5, Breaking `9Farmable Blocks`5, `6Harvesting `9Seeds`5.|\nadd_spacer|small|\nadd_button|cl0se|`wClose|\nadd_quick_exit|");
								}
								break;
							}
							else if (cch == "action|trade_cancel\n") {
								end_trade(peer, false, true);
								break;
							}
							else if (cch.find("action|trade_started\n") == 0) {
								try {
									std::stringstream ss(cch);
									std::string to;
									int id = -1;
									while (std::getline(ss, to, '\n')) {
										vector<string> infoDat = explode("|", to);
										if (infoDat.size() == 2) {
											if (infoDat.at(0) == "netid") {
												id = atoi(infoDat.at(1).c_str());
												break;
											}
										}
									}
									if (id == -1) continue;
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
										if (isHere(peer, currentPeer)) {
											if (static_cast<PlayerInfo*>(currentPeer->data)->netID == id) {
												if (pData->trade_netid == static_cast<PlayerInfo*>(currentPeer->data)->netID && static_cast<PlayerInfo*>(currentPeer->data)->trade_netid == pData->netID) {
													start_trade(peer, currentPeer);
													break;
												}
												Player::OnConsoleMessage(currentPeer, "`#TRADE ALERT:`` " + pData->displayName + " `owants to trade with you!  To start, use the `wWrench`` on that person's wrench icon, or type `w/trade " + pData->displayName + "``");
												Player::PlayAudio(currentPeer, "audio/cash_register.wav", 0);
												break;
											}
										}
									}
								}
								catch (const std::out_of_range& e) {
									std::cout << e.what() << std::endl;
								}
								break;
							}
							else if (cch.find("action|rem_trade\n") == 0) {
								try {
									std::stringstream ss(cch);
									std::string to;
									int id = -1;
									while (std::getline(ss, to, '\n')) {
										vector<string> infoDat = explode("|", to);
										if (infoDat.size() == 2) {
											if (infoDat.at(0) == "itemID") {
												id = atoi(infoDat.at(1).c_str());
												break;
											}
										}
									}
									if (id == -1) continue;
									for (int i = 0; i < pData->tradeItems.size(); i++) {
										if (pData->tradeItems.at(i).id == id) {
											pData->tradeItems.erase(pData->tradeItems.begin() + i);
											break;
										}
									}
									update_trade(peer, pData->trade_netid);
								}
								catch (const std::out_of_range& e) {
									std::cout << e.what() << std::endl;
								}
								break;
							}
							else if (cch.find("action|mod_trade\n") == 0) { 
								try {
									std::stringstream ss(cch);
									std::string to;
									int id = -1;
									while (std::getline(ss, to, '\n')) {
										vector<string> infoDat = explode("|", to);
										if (infoDat.size() == 2) {
											if (infoDat.at(0) == "itemID") {
												id = atoi(infoDat.at(1).c_str());
												break;
											}
										}
									}
									if (id == -1 || id == 18) continue;
									if (pData->tradeItems.size() >= 4) {
										Player::PlayAudio(peer, "audio/cant_place_tile.wav", 0);
										break;
									}
									if (id == 6260 || getItemDef(id).properties & Property_Untradable || id == 18 || id == 32 || id == 6336 || id == 8552 || id == 9472 || id == 9482 || id == 9356 || id == 9492 || id == 9498 || id == 8774 || id == 1790 || id == 2592 || id == 1784 || id == 1792 || id == 1794 || id == 7734 || id == 8306 || id == 9458 || id == 5640) {
										if (!isDev(peer) && !pData->Subscriber || id == 18 || id == 5640 || id == 32 || id == 6336 || id == 1486 || id == 1794) {
											Player::OnTextOverlay(peer, "You'd be sorry if you lost that!");
											Player::PlayAudio(peer, "audio/cant_place_tile.wav", 0);
											break;
										}
									}
									if (static_cast<PlayerInfo*>(peer->data)->lastdealchange + 1000 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) {
										static_cast<PlayerInfo*>(peer->data)->lastdealchange = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
										int count = 0;
										for (auto i = 0; i < pData->inventory.items.size(); i++) {
											if (pData->inventory.items.at(i).itemID == id && pData->inventory.items.at(i).itemCount >= 1) {
												count = pData->inventory.items.at(i).itemCount;
												break;
											}
										}
										if (count == 1) {
											auto contains = false;
											SearchInventoryItem(peer, id, count, contains);
											if (!contains) break;
											for (int i = 0; i < pData->tradeItems.size(); i++) {
												if (pData->tradeItems.at(i).id == id) {
													pData->tradeItems.erase(pData->tradeItems.begin() + i);
													break;
												}
											}
											TradeItem trdItem = { id, count };
											pData->tradeItems.push_back(trdItem);
											update_trade(peer, pData->trade_netid);
											break;
										}
										Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`2Trade`` `w" + getItemDef(id).name + "``|left|" + to_string(id) + "|\nadd_textbox|`2Trade how many?``|left|\nadd_text_input|count_" + to_string(id) + "||" + to_string(count) + "|5|\nend_dialog|trade_add|Cancel|OK|");
									}
									else {
										Player::OnTextOverlay(peer, "Slow down!  Please wait a second between adding and removing items");
									}
								}
								catch (const std::out_of_range& e) {
									std::cout << e.what() << std::endl;
								}
								break;
							}
							else if (cch.find("action|trade_accept\n") == 0) { 
								try {
									std::stringstream ss(cch);
									std::string to;
									int status = 0;
									while (std::getline(ss, to, '\n')) {
										vector<string> infoDat = explode("|", to);
										if (infoDat.size() == 2) {
											if (infoDat.at(0) == "status") {
												if (infoDat.at(1) == "1") {
													status = 1;
												}
												break;
											}
										}
									}
									if (!pData->trade) continue;
									pData->trade_accept = status;
									UpdateTradeAcceptedStatus(peer);
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
										if (isHere(peer, currentPeer)) {
											if (pData->trade_netid == ((PlayerInfo*)(currentPeer->data))->netID || ((PlayerInfo*)(peer->data))->netID == ((PlayerInfo*)(currentPeer->data))->trade_netid) {
												if (pData->trade_accept && static_cast<PlayerInfo*>(currentPeer->data)->trade_accept) {
													bool full_inv = false;
													int which_item = 0;
													if (static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + static_cast<PlayerInfo*>(currentPeer->data)->tradeItems.size() >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize) {
														Player::OnTextOverlay(peer, "`w" + static_cast<PlayerInfo*>(peer->data)->displayName + "`w needs more backpack room first!");
														Player::OnTextOverlay(currentPeer, "`w" + static_cast<PlayerInfo*>(peer->data)->displayName + "`w needs more backpack room first!");
														pData->trade_accept = false;
														static_cast<PlayerInfo*>(currentPeer->data)->trade_accept = false;
														UpdateTradeAcceptedStatus(peer);
														UpdateTradeAcceptedStatus(currentPeer);
														break;
													}
													for (auto& f : static_cast<PlayerInfo*>(currentPeer->data)->tradeItems) {
														if (CheckItemMaxed(peer, f.id, f.count) || pData->inventory.items.size() + 1 >= pData->currentInventorySize && CheckItemExists(peer, f.id) && CheckItemMaxed(peer, f.id, f.count) || pData->inventory.items.size() + 1 >= pData->currentInventorySize && !CheckItemExists(peer, f.id)) {
															full_inv = true;
															which_item = f.id;
															break;
														}
													}
													if (full_inv) {
														Player::OnTextOverlay(currentPeer, "`4Oops - " + pData->displayName + " `4is carrying too many " + getItemDef(which_item).name + " and can't fit that many in their backpack.");
														Player::OnTextOverlay(peer, "`4Oops - " + pData->displayName + " `4is carrying too many " + getItemDef(which_item).name + " and can't fit that many in their backpack.");
														pData->trade_accept = false;
														static_cast<PlayerInfo*>(currentPeer->data)->trade_accept = false;
														UpdateTradeAcceptedStatus(peer);
														UpdateTradeAcceptedStatus(currentPeer);
														break;
													}
													full_inv = false;
													if (static_cast<PlayerInfo*>(currentPeer->data)->inventory.items.size() + static_cast<PlayerInfo*>(peer->data)->tradeItems.size() >= static_cast<PlayerInfo*>(currentPeer->data)->currentInventorySize) {
														Player::OnTextOverlay(peer, "`w" + static_cast<PlayerInfo*>(currentPeer->data)->displayName + "`w needs more backpack room first!");
														Player::OnTextOverlay(currentPeer, "`w" + static_cast<PlayerInfo*>(currentPeer->data)->displayName + "`w needs more backpack room first!");
														pData->trade_accept = false;
														static_cast<PlayerInfo*>(currentPeer->data)->trade_accept = false;
														UpdateTradeAcceptedStatus(peer);
														UpdateTradeAcceptedStatus(currentPeer);
														break;
													}
													for (auto& f : static_cast<PlayerInfo*>(peer->data)->tradeItems) {
														if (CheckItemMaxed(currentPeer, f.id, f.count) || static_cast<PlayerInfo*>(currentPeer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(currentPeer->data)->currentInventorySize && CheckItemExists(currentPeer, f.id) && CheckItemMaxed(currentPeer, f.id, f.count) || static_cast<PlayerInfo*>(currentPeer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(currentPeer->data)->currentInventorySize && !CheckItemExists(currentPeer, f.id)) {
															full_inv = true;
															which_item = f.id;
															break;
														}
													}
													if (full_inv) {
														Player::OnTextOverlay(peer, "`4Oops - " + static_cast<PlayerInfo*>(currentPeer->data)->displayName + " `4is carrying too many " + getItemDef(which_item).name + " and can't fit that many in their backpack.");
														Player::OnTextOverlay(currentPeer, "`4Oops - " + static_cast<PlayerInfo*>(currentPeer->data)->displayName + " `4is carrying too many " + getItemDef(which_item).name + " and can't fit that many in their backpack.");
														pData->trade_accept = false;
														static_cast<PlayerInfo*>(currentPeer->data)->trade_accept = false;
														UpdateTradeAcceptedStatus(peer);
														UpdateTradeAcceptedStatus(currentPeer);
														break;
													}

													Player::OnForceTradeEnd(peer);
													Player::OnForceTradeEnd(currentPeer);
													string warning1 = "", warning2 = "", warningkeycurrent = "", warningkeypeer = "", lockedwith = "";
													if (static_cast<PlayerInfo*>(currentPeer->data)->tradeItems.size() == 0) {
														warning1 = "\nadd_spacer|small|\nadd_textbox|`4SCAM WARNING: ``You are about to do a trade without receiving anything in return. Once you do the trade you cannot get the items back.|left|\nadd_textbox|`4Do you really want to do this?``|left|\nadd_spacer|small|";
													}
													if (pData->tradeItems.size() == 0) {
														warning2 = "\nadd_spacer|small|\nadd_textbox|`4SCAM WARNING: ``You are about to do a trade without receiving anything in return. Once you do the trade you cannot get the items back.|left|\nadd_textbox|`4Do you really want to do this?``|left|\nadd_spacer|small|";
													}
													for (auto& f : static_cast<PlayerInfo*>(peer->data)->tradeItems) {
														if (f.id == 1424) {
															for (int i = 0; i < world->width * world->height; i++) {
																if (getItemDef(world->items.at(i).foreground).blockType == BlockTypes::LOCK) {
																	if (world->items.at(i).foreground == 202 || world->items.at(i).foreground == 204 || world->items.at(i).foreground == 206 || world->items.at(i).foreground == 4994) continue;
																	lockedwith = getItemDef(world->items.at(i).foreground).name;
																	break;
																}
															}
															warningkeycurrent = "\nadd_textbox|`4SCAM WARNING: ``You are buying this world, `#" + world->name + "``. Don't buy a world just to get its rare items, because scammers can easily place secret doors allowing someone to jump in and `4steal the items back`` after a trade!|left|\nadd_spacer|small|\nadd_textbox|Also, all ratings will be removed from a world when it is traded. Don't buy a world for its ranking!|left|\nadd_spacer|small|\nadd_textbox|To be safe, only buy a world for its name and placed blocks, not loose items or high ratings. Consider yourself warned!|left|\nadd_spacer|small|\nadd_textbox|This world is locked by " + lockedwith + ".|left|\nadd_spacer|small|";
															warningkeypeer = "\nadd_textbox|`4WARNING: ``You are about to sell your world `#" + world->name + "`` - the world lock ownership will be transferred over to `w" + static_cast<PlayerInfo*>(currentPeer->data)->displayName + "`o.|left|\nadd_spacer|small|";
															break;
														}
													}
													for (auto& f : static_cast<PlayerInfo*>(currentPeer->data)->tradeItems) {
														if (f.id == 1424) {
															for (int i = 0; i < world->width * world->height; i++) {
																if (getItemDef(world->items.at(i).foreground).blockType == BlockTypes::LOCK) {
																	if (world->items.at(i).foreground == 202 || world->items.at(i).foreground == 204 || world->items.at(i).foreground == 206 || world->items.at(i).foreground == 4994) continue;
																	lockedwith = getItemDef(world->items.at(i).foreground).name;
																	break;
																}
															}
															warningkeypeer = "\nadd_textbox|`4SCAM WARNING: ``You are buying this world, `#" + world->name + "``. Don't buy a world just to get its rare items, because scammers can easily place secret doors allowing someone to jump in and `4steal the items back`` after a trade!|left|\nadd_spacer|small|\nadd_textbox|Also, all ratings will be removed from a world when it is traded. Don't buy a world for its ranking!|left|\nadd_spacer|small|\nadd_textbox|To be safe, only buy a world for its name and placed blocks, not loose items or high ratings. Consider yourself warned!|left|\nadd_spacer|small|\nadd_textbox|This world is locked by " + lockedwith + ".|left|\nadd_spacer|small|";
															warningkeycurrent = "\nadd_textbox|`4WARNING: ``You are about to sell your world `#" + world->name + "`` - the world lock ownership will be transferred over to `w" + pData->displayName + "`o.|left|\nadd_spacer|small|";
															break;
														}
													}

													Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wTrade Confirmation``|left|1366|\nadd_spacer|small|\nadd_textbox|`4You'll give:``|left|\nadd_spacer|small|" + FormatTradeItemsForDialog(pData->tradeItems, 0) + "\nadd_spacer|small|\nadd_textbox|`2You'll get:``|left|\nadd_spacer|small|" + FormatTradeItemsForDialog(static_cast<PlayerInfo*>(currentPeer->data)->tradeItems, 1) + "\nadd_spacer|small|" + warningkeypeer + warning1 + "\nadd_button|accept|Do The Trade!|noflags|0|0|\nadd_button|back|Cancel|noflags|0|0|\nend_dialog|trade_confirm|||");
													Player::OnDialogRequest(currentPeer, "set_default_color|`o\nadd_label_with_icon|big|`wTrade Confirmation``|left|1366|\nadd_spacer|small|\nadd_textbox|`4You'll give:``|left|\nadd_spacer|small|" + FormatTradeItemsForDialog(static_cast<PlayerInfo*>(currentPeer->data)->tradeItems, 0) + "\nadd_spacer|small|\nadd_textbox|`2You'll get:``|left|\nadd_spacer|small|" + FormatTradeItemsForDialog(pData->tradeItems, 1) + "\nadd_spacer|small|" + warningkeycurrent + warning2 + "\nadd_button|accept|Do The Trade!|noflags|0|0|\nadd_button|back|Cancel|noflags|0|0|\nend_dialog|trade_confirm|||");
												}
												break;
											}
										}
									}
								}
								catch (const std::out_of_range& e) {
									std::cout << e.what() << std::endl;
								}
								break;
							}
							if (cch.find("action|dialog_return\ndialog_name|updatefish") != std::string::npos) {
								int x = stoi(explode("|", explode("tilex|", cch)[1])[0]);
								int y = stoi(explode("|", explode("tiley|", cch)[1])[0]);
								if (cch.find("fishid|") != std::string::npos) {
									int id = stoi(explode("\n", explode("fishid|", cch)[1])[0]);
									if (isValidFish(peer, id)) {
										world->items[x + (y * world->width)].text += to_string(id) + "|60|" + to_string(rand() % 5000) + ",";
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
											if (isHere(peer, currentPeer)) {
												UpdatePort(currentPeer, x, y, 3002, 3004, world->items[x + (y * world->width)].text);
											}
										}
									}
								}
								else if (cch.find("buttonClicked|remove_fish") != std::string::npos) {
									auto keren = explode("buttonClicked|remove_fish\n\n", cch)[1];
									keren = explode("\nsinarfish|", keren)[0];
									auto lol = explode("\n", keren);
									for (auto& gg : lol) {
										auto s = explode("|", gg);
										if (s[1] == "1") {
											auto xd = explode("_", s[0]);
											string newfish = replace1(world->items[x + (y * world->width)].text, xd[1] + "|" + xd[2] + "|" + xd[3] + ",", "");
											world->items[x + (y * world->width)].text = newfish;
											Player::OnConsoleMessage(peer, "`oRemoved " + xd[2] + "lb. " + itemDefs[stoi(xd[1])].name);
											for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
												if (isHere(peer, currentPeer)) {
													UpdatePort(currentPeer, x, y, 3002, 3004, world->items[x + (y * world->width)].text);
												}
											}
										}
									}
								}
							}
							if (cch.find("action|dialog_return\ndialog_name|editemoji\ntilex|") != std::string::npos) {
								int x = stoi(explode("\n", explode("tilex|", cch).at(1)).at(0));
								int y = stoi(explode("\n", explode("tiley|", cch).at(1)).at(0));
								int fg = world->items.at(x + (y * world->width)).foreground, bg = world->items.at(x + (y * world->width)).background;
								if (cch.find("buttonClicked|erasepaint") != std::string::npos) {
									ENetPeer* currentPeer;
									for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
										if (isHere(peer, currentPeer)) Portrait(currentPeer, x, y, fg, bg, 0, 0, 0, 0, 0, "", 65536 + getBlockState(world, x, y));
									}
									world->items.at(x + (y * world->width)).text = "";
									break;
								}
								string ggwp = world->items.at(x + (y * world->width)).text;
								auto dt = explode("|", ggwp);
								int hair = stoi(dt.at(0)), mask = stoi(dt.at(1)), face = stoi(dt[2]), skin = stoi(dt[3]);
								string title = explode("\n", explode("porttitle|", cch).at(1)).at(0);
								replaceAll(cch, "action|dialog_return\ndialog_name|editemoji\ntilex|" + to_string(x) + "\ntiley|" + to_string(y) + "\n", "");
								auto apa = explode("port", cch);
								for (auto& a : apa) {
									auto s = explode("|", a);
									if (s.size() == 2) {
										string id = s.at(0);
										string op = s.at(1);
										replaceAll(id, "\n", "");
										replaceAll(op, "\n", "");
										if (op == "1") {
											ENetPeer* currentPeer;
											for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
												if (isHere(peer, currentPeer)) {
													string idkok = explode("|", world->items.at(x + (y * world->width)).text)[4];
													Portrait(currentPeer, x, y, fg, bg, mask, hair, face, skin, stoi(id), title, 65536 + getBlockState(world, x, y));
													replaceAll(world->items.at(x + (y * world->width)).text, idkok, title);
													replaceAll(world->items.at(x + (y * world->width)).text, "|" + dt[5] + "|", "|" + id + "|");
												}
											}
										}
									}
								}
							}
							if (cch.find("action|dialog_return\ndialog_name|editcanvas\ntilex|") != std::string::npos) {
								int netid = stoi(explode("\n", explode("portrait|", cch).at(1)).at(0));
								int x = stoi(explode("\n", explode("tilex|", cch).at(1)).at(0));
								int y = stoi(explode("\n", explode("tiley|", cch).at(1)).at(0));
								if (world->items.at(x + (y * world->width)).foreground == 3818) {
									ENetPeer* currentPeer;
									for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
										if (((PlayerInfo*)(currentPeer->data))->netID == netid && isHere(peer, currentPeer)) {
											PlayerInfo* info = ((PlayerInfo*)(currentPeer->data));
											int fg = world->items.at(x + (y * world->width)).foreground, bg = world->items.at(x + (y * world->width)).background;
											Portrait(currentPeer, x, y, fg, bg, info->cloth_mask, info->cloth_hair, info->cloth_face, info->skinColor, 1, info->displayName, 65536 + getBlockState(world, x, y));
											string datas = to_string(info->cloth_hair) + "|" + to_string(info->cloth_mask) + "|" + to_string(info->cloth_face) + "|" + to_string(info->skinColor) + "|" + info->displayName + "|" + to_string(1) + "|";
											world->items.at(x + (y * world->width)).text = datas;
											ENetPeer* currentPeer2;
											for (currentPeer2 = server->peers; currentPeer2 < &server->peers[server->peerCount]; ++currentPeer2) {
												if (currentPeer2->state != ENET_PEER_STATE_CONNECTED) continue;
												if (isHere(peer, currentPeer2)) {
													Portrait(currentPeer2, x, y, fg, bg, info->cloth_mask, info->cloth_hair, info->cloth_face, info->skinColor, 1, info->displayName, 65536 + getBlockState(world, x, y));
												}
											}
										}
									}
								}
								else enet_peer_disconnect_later(peer, 0);
							}
							if (cch.find("action|dialog_return\ndialog_name|sign_edit") == 0) {
								if (world != NULL) {
									if (((PlayerInfo*)(peer->data))->rawName == PlayerDB::getProperName(world->owner)) {
										std::stringstream ss(GetTextPointerFromPacket(event.packet));
										std::string to;
										int x = 0;
										int y = 0;
										bool created = false;
										string text = "";
										string world = ((PlayerInfo*)(peer->data))->currentWorld;
										while (std::getline(ss, to, '\n')) {
											string id = to.substr(0, to.find("|"));
											string act = to.substr(to.find("|") + 1, to.length() - to.find("|") - 1);
											if (id == "tilex")
											{
												x = atoi(act.c_str());

											}
											else if (id == "tiley")
											{
												y = atoi(act.c_str());
											}
											else if (id == "ch3")
											{
												text = act;
												created = true;
											}
											if (created == true) {
												if (text == "__%&P&%__") {
													Player::OnConsoleMessage(peer, ">> Can't use this!");
													continue;
												}
											}
											if (text.length() < 255) {
												WorldInfo* worldInfo = getPlyersWorld(peer);
												int squaresign = ((PlayerInfo*)(peer->data))->wrenchx + (((PlayerInfo*)(peer->data))->wrenchy * 100);
												updateSignSound(peer, worldInfo->items[squaresign].foreground, squaresign % worldInfo->width, squaresign / worldInfo->width, text, worldInfo->items[squaresign].background);
												worldInfo->items[squaresign].text = text;
											}
										}
									}
								}
							}
							else if (cch == "action|store\nlocation|gem\n" || cch == "action|store\nlocation|bottommenu\n" || cch == "action|buy\nitem|main\n" || cch == "action|storenavigate\nitem|main\nselection|gems_rain\n") {
								if (!pData->haveGrowId) {
									SendRegisterDialog(peer); 
									break;
								}
								try {
									string text1 = "set_description_text|Welcome to the `2Growtopia Store``! Select the item you'd like more info on.`o `wWant to get `5Supporter`` status? Any Gem purchase (or `57,000`` Gems earned with free `5Tapjoy`` offers) will make you one. You'll get new skin colors, the `5Recycle`` tool to convert unwanted items into Gems, and more bonuses!";
									string text2 = "|enable_tabs|1";
									string text3 = "|\nadd_tab_button|main_menu|Home|interface/large/btn_shop2.rttex||1|0|0|0||||-1|-1||||";;
									string text4 = "|\nadd_tab_button|locks_menu|Locks And Stuff|interface/large/btn_shop2.rttex||0|1|0|0||||-1|-1|||";
									string text5 = "|\nadd_tab_button|itempack_menu|Item Packs|interface/large/btn_shop2.rttex||0|3|0|0||||-1|-1||||";
									string text6 = "|\nadd_tab_button|bigitems_menu|Awesome Items|interface/large/btn_shop2.rttex||0|4|0|0||||-1|-1||||";
									string text7 = "|\nadd_tab_button|weather_menu|Weather Machines|interface/large/btn_shop2.rttex|Tired of the same sunny sky?  We offer alternatives within...|0|5|0|0||||-1|-1||||";
									string text8 = "|\nadd_tab_button|token_menu|Growtoken Items|interface/large/btn_shop2.rttex||0|2|0|0||||-1|-1||||";
									string text9 = "|\nadd_banner|interface/large/gui_shop_featured_header.rttex|0|1|";
									string text10 = "|\add_image_button|banner|interface/large/gui_shop_grow_pass.rttex|bannerlayout|OPENSURVEY||";
									string text11 = "|\nadd_button|itemomonth|`oItem Of The Month``|interface/large/store_buttons/store_buttons37.rttex|January 2022:`` `9Royal Grow Pass``!<CR><CR>`2You Get:`` 1 `#Guardian Armor``.<CR><CR>`5Description: `0The New Item Of The Month The `#Royal Guardian Armor|4|2|150000|0||interface/large/gui_store_button_overlays1.rttex|0|0|/interface/large/gui_shop_buybanner.rttex|0|2||1||||||0|0|";
									string text12 = "|\nadd_button|riftwing|`oRift Wings``|interface/large/store_buttons/store_buttons37.rttex|October 2021:`` `9Rift Wings``!<CR><CR>`2You Get:`` 1 `9Rift Wings``.<CR><CR>`5Description: `0Rip a hole in the fabric of reality with these amazing Waings! To avoid refund fraud this item has been made untradeable until 1st of may, 2022.|4|2|150000|0||interface/large/gui_store_button_overlays1.rttex|0|0|/interface/large/gui_shop_buybanner.rttex|0|5||4||||||0|0|";
									string text16 = "|\nadd_banner|interface/large/gui_shop_featured_header.rttex|0|2|";
									string text17 = "|\nadd_button|gems_glory|Road To Glory|interface/large/store_buttons/store_buttons30.rttex|rt_grope_loyalty_bundle01|0|0|0|0||interface/large/gui_store_button_overlays1.rttex|0|0|/interface/large/gui_shop_buybanner.rttex|1|0|`2You Get:`` Road To Glory and 100k Gems Instantly.<CR>`5Description:`` Earn Gem rewards when you level up. Every 10 levels you will get additional Gem rewards up to Level 50! Claim all rewards instantly if you are over level 50!! 1.6M Gems in total!! |1|||||||";
									string text18 = "|\nadd_button|gems_rain|It's Rainin' Gems|interface/large/store_buttons/store_buttons.rttex|rt_grope_gem_rain|1|5|0|0|||-1|-1||-1|-1|`2You Get:`` 200,000 Gems, 2 Growtoken, and 1 Megaphone.<CR><CR>`5Description:`` All the gems you could ever want and more plus 2 Growtokens and a Megaphone to tell the whole world about it.|1|||||||";
									string text19 = "|\nadd_button|gems_fountain|Gem Fountain|interface/large/store_buttons/store_buttons2.rttex|rt_grope_gem_fountain|0|2|0|0|||-1|-1||-1|-1|`2You Get:`` 90,000 Gems and 1 Growtoken.<CR><CR>`5Description:`` Get a pile of gems to shop to your hearts desire and 1 Growtoken.|1|||||||";
									string text20 = "|\nadd_button|gems_chest|Chest o' Gems|interface/large/store_buttons/store_buttons.rttex|rt_grope_gem_chest|0|5|0|0|||-1|-1||-1|-1|`2You Get:`` 30,000 Gems.<CR><CR>`5Description:`` Get a chest containing gems.|1|||||||";
									string text21 = "|\nadd_button|gems_bag|Bag o' Gems|interface/large/store_buttons/store_buttons.rttex|rt_grope_gem_bag|1|0|0|0|||-1|-1||-1|-1|`2You Get:`` 14,000 Gems.<CR><CR>`5Description:`` Get a small bag of gems.|1|||||||";
									string text22 = "|\nadd_button|tapjoy|Earn Free Gems|interface/large/store_buttons/store_buttons.rttex||1|2|0|0|||-1|-1||-1|-1||1|||||||";
									string text23 = "|\nadd_banner|interface/large/gui_shop_featured_header.rttex|0|3|";
									string text24 = "|\nadd_button|365d|`o1-Year Subscription Token``|interface/large/store_buttons/store_buttons22.rttex|rt_grope_subs_bundle02|0|5|0|0|||-1|-1||-1|-1|`2You Get:`` 1x 1-Year Subscription Token and 25 Growtokens.<CR><CR>`5Description:`` One full year of special treatment AND 25 Growtokens upfront! You'll get 70 season tokens (as long as there's a seasonal clash running), and 2500 gems every day and a chance of doubling any XP earned, growtime reduction on all seeds planted and Exclusive Skins!|1||||||";
									string text25 = "|\nadd_button|30d|`o30-Day Subscription Token``|interface/large/store_buttons/store_buttons22.rttex|rt_grope_subs_bundle01|0|4|0|0|||-1|-1||-1|-1|`2You Get:`` 1x 30-Day Free Subscription Token and 2 Growtokens.<CR><CR>`5Description:`` 30 full days of special treatment AND 2 Growtokens upfront! You'll get 70 season tokens (as long as there's a seasonal clash running), and 2500 gems every day and a chance of doubling any XP earned, growtime reduction on all seeds planted and Exclusive Skins!|1||||||";
									string text26 = "|\nadd_button|video_tapjoy|Watch Videos For Gems|interface/large/store_buttons/store_buttons29.rttex||0|1|0|0|1/5 VIDEOS WATCHED||-1|-1||-1|-1||1||||||";

									/*
									string text1 = "set_description_text|Welcome to the `2Growtopia Store``!  Tap the item you'd like more info on.`o  `wWant to get `5Supporter`` status? Any Gem purchase (or `57,000`` Gems earned with free `5Tapjoy`` offers) will make you one. You'll get new skin colors, the `5Recycle`` tool to convert unwanted items into Gems, and more bonuses!";
									string text2 = "|\nadd_button|iapp_menu|Buy Gems|interface/large/store_buttons5.rttex||0|2|0|0|";
									string text3 = "|\nadd_button|subs_menu|Subscriptions|interface/large/store_buttons22.rttex||0|1|0|0|";
									string text4 = "|\nadd_button|itemomonth|`oItem Of The Month``|interface/large/store_buttons16.rttex|`2September 2018:`` `9Sorcerer's Tunic of Mystery!`` Capable of reflecting the true colors of the world around it, this rare tunic is made of captured starlight and aether. If you think knitting with thread is hard, just try doing it with moonbeams and magic! The result is worth it though, as these clothes won't just make you look amazing - you'll be able to channel their inherent power into blasts of cosmic energy!``|0|3|200000|0|";
									string text5 = "|\nadd_button|locks_menu|Locks And Stuff|interface/large/store_buttons3.rttex||0|4|0|0|";
									string text6 = "|\nadd_button|itempack_menu|Item Packs|interface/large/store_buttons3.rttex||0|3|0|0|";
									string text7 = "|\nadd_button|bigitems_menu|Awesome Items|interface/large/store_buttons4.rttex||0|6|0|0|";
									string text8 = "|\nadd_button|weather_menu|Weather Machines|interface/large/store_buttons5.rttex|Tired of the same sunny sky?  We offer alternatives within...|0|4|0|0||";
									string text9 = "|\nadd_button|token_menu|Growtoken Items|interface/large/store_buttons9.rttex||0|0|0|0|";
									*/
									storerequest(peer, text1 + text2 + text3 + text4 + text5 + text6 + text7 + text8 + text9 + text10 + text11  + text16 + text17 + text18 + text19 + text20 + text21 + text22 + text23 + text24 + text25 + text26);
								}
								catch (const std::out_of_range& e) {
									std::cout << e.what() << std::endl;
								}
								break;
							}
							if (cch.find("action|buy\nitem|store") == 0)
							{

								string text1 = "set_description_text|Welcome to the `2Growtopia Store``! Select the item you'd like more info on.`o `wWant to get `5Supporter`` status? Any Gem purchase (or `57,000`` Gems earned with free `5Tapjoy`` offers) will make you one. You'll get new skin colors, the `5Recycle`` tool to convert unwanted items into Gems, and more bonuses!";
								string text2 = "|enable_tabs|1";
								string text3 = "|\nadd_tab_button|main_menu|Home|interface/large/btn_shop2.rttex||1|0|0|0||||-1|-1||||";;
								string text4 = "|\nadd_tab_button|locks_menu|Locks And Stuff|interface/large/btn_shop2.rttex||0|1|0|0||||-1|-1|||";
								string text5 = "|\nadd_tab_button|itempack_menu|Item Packs|interface/large/btn_shop2.rttex||0|3|0|0||||-1|-1||||";
								string text6 = "|\nadd_tab_button|bigitems_menu|Awesome Items|interface/large/btn_shop2.rttex||0|4|0|0||||-1|-1||||";
								string text7 = "|\nadd_tab_button|weather_menu|Weather Machines|interface/large/btn_shop2.rttex|Tired of the same sunny sky?  We offer alternatives within...|0|5|0|0||||-1|-1||||";
								string text8 = "|\nadd_tab_button|token_menu|Growtoken Items|interface/large/btn_shop2.rttex||0|2|0|0||||-1|-1||||";
								string text9 = "|\nadd_banner|interface/large/gui_shop_featured_header.rttex|0|1|";
								string text10 = "|\add_image_button|banner|interface/large/gui_shop_grow_pass.rttex|bannerlayout|OPENSURVEY||";
								string text11 = "|\nadd_button|itemomonth|`oItem Of The Month``|interface/large/store_buttons/store_buttons37.rttex|October 2021:`` `9Royal Grow Pass``!<CR><CR>`2You Get:`` 1 `9Royal Grow Pass Token``.<CR><CR>`5Description: `0Play to earn points and level up your Grow Pass to eam rewards. Consume to earn exclusive Royal rewards as your level up you Grow Pass as well as unlocking all daly bonuses and exclusive Royal Perks for the entire month. Upon consuming you will instantly receive 300 Free points towards your pass progress. Note: The token is `#UNTRADEABLE.|4|2|150000|0||interface/large/gui_store_button_overlays1.rttex|0|0|/interface/large/gui_shop_buybanner.rttex|0|2||1||||||0|0|";
								string text13 = "|\nadd_button|riftwing|`oRift Wings``|interface/large/store_buttons/store_buttons37.rttex|October 2021:`` `9Rift Wings``!<CR><CR>`2You Get:`` 1 `9Rift Wings``.<CR><CR>`5Description: `0Rip a hole in the fabric of reality with these amazing Waings! To avoid refund fraud this item has been made untradeable until 1st of may, 2022.|4|2|150000|0||interface/large/gui_store_button_overlays1.rttex|0|0|/interface/large/gui_shop_buybanner.rttex|0|5||4||||||0|0|";
								//string text12 = "|\nadd_banner|interface/large/gui_shop_featured_header.rttex|0|2|";
								//string text13 = "|\nadd_button|gems_glory|Road To Glory|interface/large/store_buttons/store_buttons30.rttex|rt_grope_loyalty_bundle01|0|0|0|0||interface/large/gui_store_button_overlays1.rttex|0|0|/interface/large/gui_shop_buybanner.rttex|1|0|`2You Get:`` Road To Glory and 100k Gems Instantly.<CR>`5Description:`` Earn Gem rewards when you level up. Every 10 levels you will get additional Gem rewards up to Level 50! Claim all rewards instantly if you are over level 50!! 1.6M Gems in total!! |1|||||||";
								//string text14 = "|\nadd_button|gems_rain|It's Rainin' Gems|interface/large/store_buttons/store_buttons.rttex|rt_grope_gem_rain|1|5|0|0|||-1|-1||-1|-1|`2You Get:`` 200,000 Gems, 2 Growtoken, and 1 Megaphone.<CR><CR>`5Description:`` All the gems you could ever want and more plus 2 Growtokens and a Megaphone to tell the whole world about it.|1|||||||";
								//string text15 = "|\nadd_button|gems_fountain|Gem Fountain|interface/large/store_buttons/store_buttons2.rttex|rt_grope_gem_fountain|0|2|0|0|||-1|-1||-1|-1|`2You Get:`` 90,000 Gems and 1 Growtoken.<CR><CR>`5Description:`` Get a pile of gems to shop to your hearts desire and 1 Growtoken.|1|||||||";
								//string text16 = "|\nadd_button|gems_chest|Chest o' Gems|interface/large/store_buttons/store_buttons.rttex|rt_grope_gem_chest|0|5|0|0|||-1|-1||-1|-1|`2You Get:`` 30,000 Gems.<CR><CR>`5Description:`` Get a chest containing gems.|1|||||||";
								//string text17 = "|\nadd_button|gems_bag|Bag o' Gems|interface/large/store_buttons/store_buttons.rttex|rt_grope_gem_bag|1|0|0|0|||-1|-1||-1|-1|`2You Get:`` 14,000 Gems.<CR><CR>`5Description:`` Get a small bag of gems.|1|||||||";
								//string text18 = "|\nadd_button|tapjoy|Earn Free Gems|interface/large/store_buttons/store_buttons.rttex||1|2|0|0|||-1|-1||-1|-1||1|||||||";
								//string text19 = "|\nadd_banner|interface/large/gui_shop_featured_header.rttex|0|3|";
								//string text20 = "|\nadd_button|365d|`o1-Year Subscription Token``|interface/large/store_buttons/store_buttons22.rttex|rt_grope_subs_bundle02|0|5|0|0|||-1|-1||-1|-1|`2You Get:`` 1x 1-Year Subscription Token and 25 Growtokens.<CR><CR>`5Description:`` One full year of special treatment AND 25 Growtokens upfront! You'll get 70 season tokens (as long as there's a seasonal clash running), and 2500 gems every day and a chance of doubling any XP earned, growtime reduction on all seeds planted and Exclusive Skins!|1||||||";
								//string text21 = "|\nadd_button|30d|`o30-Day Subscription Token``|interface/large/store_buttons/store_buttons22.rttex|rt_grope_subs_bundle01|0|4|0|0|||-1|-1||-1|-1|`2You Get:`` 1x 30-Day Free Subscription Token and 2 Growtokens.<CR><CR>`5Description:`` 30 full days of special treatment AND 2 Growtokens upfront! You'll get 70 season tokens (as long as there's a seasonal clash running), and 2500 gems every day and a chance of doubling any XP earned, growtime reduction on all seeds planted and Exclusive Skins!|1||||||";
								//string text22 = "|\nadd_button|video_tapjoy|Watch Videos For Gems|interface/large/store_buttons/store_buttons29.rttex||0|1|0|0|1/5 VIDEOS WATCHED||-1|-1||-1|-1||1||||||";

								/*
								string text1 = "set_description_text|Welcome to the `2Growtopia Store``!  Tap the item you'd like more info on.`o  `wWant to get `5Supporter`` status? Any Gem purchase (or `57,000`` Gems earned with free `5Tapjoy`` offers) will make you one. You'll get new skin colors, the `5Recycle`` tool to convert unwanted items into Gems, and more bonuses!";
								string text2 = "|\nadd_button|iapp_menu|Buy Gems|interface/large/store_buttons5.rttex||0|2|0|0|";
								string text3 = "|\nadd_button|subs_menu|Subscriptions|interface/large/store_buttons22.rttex||0|1|0|0|";
								string text4 = "|\nadd_button|itemomonth|`oItem Of The Month``|interface/large/store_buttons16.rttex|`2September 2018:`` `9Sorcerer's Tunic of Mystery!`` Capable of reflecting the true colors of the world around it, this rare tunic is made of captured starlight and aether. If you think knitting with thread is hard, just try doing it with moonbeams and magic! The result is worth it though, as these clothes won't just make you look amazing - you'll be able to channel their inherent power into blasts of cosmic energy!``|0|3|200000|0|";
								string text5 = "|\nadd_button|locks_menu|Locks And Stuff|interface/large/store_buttons3.rttex||0|4|0|0|";
								string text6 = "|\nadd_button|itempack_menu|Item Packs|interface/large/store_buttons3.rttex||0|3|0|0|";
								string text7 = "|\nadd_button|bigitems_menu|Awesome Items|interface/large/store_buttons4.rttex||0|6|0|0|";
								string text8 = "|\nadd_button|weather_menu|Weather Machines|interface/large/store_buttons5.rttex|Tired of the same sunny sky?  We offer alternatives within...|0|4|0|0||";
								string text9 = "|\nadd_button|token_menu|Growtoken Items|interface/large/store_buttons9.rttex||0|0|0|0|";
								*/
								storerequest(peer, text1 + text2 + text3 + text4 + text5 + text6 + text7 + text8 + text9 + text10 + text11 + text13); // + text12 + text13 + text14 + text15 + text16 + text17 + text18 + text19 + text20 + text21 + text22);

							}
							if (cch.find("action|buy\nitem|itempack") == 0) {
								string text1 = "set_description_text|`2Item Packs!``  Select the item you'd like more info on, or BACK to go back.";
								string text2 = "|enable_tabs|1";
								string text3 = "|\nadd_tab_button|main_menu|Home|interface/large/btn_shop2.rttex||0|0|0|0||||-1|-1||||";
								string text4 = "|\nadd_tab_button|locks_menu|Locks And Stuff|interface/large/btn_shop2.rttex||0|1|0|0||||-1|-1||||";
								string text5 = "|\nadd_tab_button|itempack_menu|Item Packs|interface/large/btn_shop2.rttex||1|3|0|0||||-1|-1||||";
								string text6 = "|\nadd_tab_button|bigitems_menu|Awesome Items|interface/large/btn_shop2.rttex||0|4|0|0||||-1|-1||||";
								string text7 = "|\nadd_tab_button|weather_menu|Weather Machines|interface/large/btn_shop2.rttex|Tired of the same sunny sky?  We offer alternatives within...|0|5|0|0||||-1|-1||||";
								string text8 = "|\nadd_tab_button|token_menu|Growtoken Items|interface/large/btn_shop2.rttex||0|2|0|0||||-1|-1||||";
								string text9 = "|\nadd_button|world_lock|`oWorld Lock``|interface/large/store_buttons/store_buttons.rttex|`2You Get:`` 1 World Lock.<CR><CR>`5Description:`` Become the undisputed ruler of your domain with one of these babies.  It works like a normal lock except it locks the `$entire world``!  Won't work on worlds that other people already have locks on. You can even add additional normal locks to give access to certain areas to friends. `5It's a perma-item, is never lost when destroyed.``  `wRecycles for 200 Gems.``|0|7|2000|0|||-1|-1||-1|-1||1|||||||";
								string text10 = "|\nadd_button|10_wl|`oWorld Lock Pack``|interface/large/store_buttons/store_buttons18.rttex|`2You Get:`` 10 World Locks.<CR><CR>`5Description:`` 10-pack of World Locks. Become the undisputed ruler of up to TEN kingdoms with these babies. Each works like a normal lock except it locks the `$entire world``!  Won't work on worlds that other people already have locks on. You can even add additional normal locks to give access to certain areas to friends. `5It's a perma-item, is never lost when destroyed.`` `wEach recycles for 200 Gems.``|0|3|20000|0|||-1|-1||-1|-1||1|||||||";
								string text12 = "|\nadd_button|small_lock|`oSmall Lock``|interface/large/store_buttons/store_buttons.rttex|`2You Get:`` 1 Small Lock.<CR><CR>`5Description:`` Protect up to `$10`` tiles.  Can add friends to the lock so others can edit that area as well. `5It's a perma-item, is never lost when destroyed.``|1|3|50|0|||-1|-1||-1|-1||1|||||||";
								string text15 = "|\nadd_button|dpack|`oDoor And Sign Hello Pack``|interface/large/store_buttons/store_buttons.rttex|`2You Get:`` 1 Door and 1 Sign.<CR><CR>`5Description:`` Own your very own door and sign! This pack comes with one of each. Leave cryptic messages and create a door that can open to, well, anywhere.|0|3|15|0|||-1|-1||-1|-1||1|||||||";
								string text16 = "|\nadd_button|dmover|`oDoor Mover``|interface/large/store_buttons/store_buttons8.rttex|`2You Get:`` 1 Door Mover.<CR><CR>`5Description:`` Unsatisfied with your world's layout?  This one-use device can be used to move the White Door to any new location in your world, provided there are 2 empty spaces for it to fit in. Disappears when used. `2Only usable on a world you have World Locked.``|0|6|5000|0|||-1|-1||-1|-1||1|||||||";
								string text17 = "|\nadd_button|vending_machine|`oVending Machine``|interface/large/store_buttons/store_buttons13.rttex|`2You Get:`` 1 Vending Machine.<CR><CR>`5Description:`` Tired of interacting with human beings? Try a Vending Machine! You can put a stack of items inside it, set a price in World Locks, and people can buy from the machine while you sit back and rake in the profits! `5It's a perma-item, is never lost when destroyed, and it is not available any other way.``|0|6|8000|0|||-1|-1||-1|-1||1|||||||";
								string text21 = "|\nadd_button|signal_jammer|`oSignal Jammer``|interface/large/store_buttons/store_buttons.rttex|`2You Get:`` 1 Signal Jammer.<CR><CR>`5Description:`` Get off the grid! Install a `$Signal Jammer``! A single punch will cause it to whir to life, tireless hiding your world and its population from pesky snoopers - only those who know the world name will be able to enter. `5It's a perma-item, is never lost when destroyed.``|1|6|2000|0|||-1|-1||-1|-1||1|||||||";
								string text22 = "|\nadd_button|punch_jammer|`oPunch Jammer``|interface/large/store_buttons/store_buttons7.rttex|`2You Get:`` 1 Punch Jammer.<CR><CR>`5Description:`` Tired of getting bashed around? Set up a Punch Jammer in your world, and people won't be able to punch each other! Can be turned on and off as needed. `5It's a perma-item, is never lost when destroyed.``|0|4|15000|0|||-1|-1||-1|-1||1|||||||";
								string text23 = "|\nadd_button|zombie_jammer|`oZombie Jammer``|interface/large/store_buttons/store_buttons7.rttex|`2You Get:`` 1 Zombie Jammer.<CR><CR>`5Description:`` Got a parkour or race that you don't want slowed down? Turn this on and nobody can be infected by zombie bites in your world. It does not prevent direct infection by the g-Virus itself though. `5It's a perma-item, is never lost when destroyed.``|0|5|15000|0|||-1|-1||-1|-1||1|||||||";
								string text24 = "|\nadd_button|starship_blast|`oImperial Starship Blast``|interface/large/store_buttons/store_buttons21.rttex|`2You Get:`` 1 Imperial Starship Blast.<CR><CR>`5Description:`` Command your very own Starship and explore the cosmos! This blast contains one of 3 possible Imperial ship types - which will you get? Note: Each Starship comes with a full tank of gas, an Imperial Helm - Mk. I, Imperial Reactor - Mk. I and an Imperial Viewscreen - Mk. I, so you'll be all set for your adventure among the stars! Note: A Starship also comes with an assortment of space-age blocks!|0|1|20000|0|||-1|-1||-1|-1||1|||||||";
								string text25 = "|\nadd_button|surg_blast|`oSurgWorld Blast``|interface/large/store_buttons/store_buttons27.rttex|`2You Get:`` 1 SurgWorld Blast and 1 Caduceaxe.<CR><CR>`5Description:`` Your gateway to a world of medical wonders! SurgWorld is a place of care and healing, with all kinds of interesting blocks, top tips on how to treat people with surgery, and an increased chance of getting maladies while you work! Also comes with 1 Caduceaxe to extract Vaccine Drops from blocks. `6Warning:`` May break when extracting vaccine.|0|2|10000|0|||-1|-1||-1|-1||1|||||||";
								string text26 = "|\nadd_button|bountiful_blast|`oBountiful Blast``|interface/large/store_buttons/store_buttons27.rttex|`2You Get:`` 1 Bountiful Blast.<CR><CR>`5Description:`` Enter a world of fertile soil, cheerful sunshine and lush green hills, and bountiful new trees! This blast is your ticket to a different kind of farming!|0|3|5000|0|||-1|-1||-1|-1||1|||||||";
								string text27 = "|\nadd_button|thermo_blast|`oThermonuclear Blast``|interface/large/store_buttons/store_buttons8.rttex|`2You Get:`` 1 Thermonuclear Blast.<CR><CR>`5Description:`` This supervillainous device will blast you to a new world that has been scoured completely empty - it contains nothing but Bedrock and a White Door. Remember: When using this, you are creating a NEW world by typing in a new name. It would be irresponsible to let you blow up an entire existing world.|0|5|15000|0|||-1|-1||-1|-1||1|||||||";
								string text28 = "|\nadd_button|antigravity_generator|`oAntigravity Generator``|interface/large/store_buttons/store_buttons17.rttex|`2You Get:`` 1 Antigravity Generator.<CR><CR>`5Description:`` Disables gravity in your world when activated! Well, it reduces gravity, and lets everybody jump as much as they want! `5It's a perma-item - never lost when destroyed! `4Not available any other way!````|0|3|450000|0|||-1|-1||-1|-1||1|||||||";
								string text29 = "|\nadd_button|building_blocks_machine|`oBuilding Blocks Machine``|interface/large/store_buttons/store_buttons26.rttex|`2You Get:`` 1 Building Blocks Machine.<CR><CR>`5Description:`` Eager to add some new building materials to your construction stockpile? Tired of collecting them from random worlds and weirdos? Well, pop this beauty in your world and it'll start cranking out awesome blocks in no time! Contains the `5RARE Creepy Baby Block and Digital Dirt`` amongst a heap of other new blocks! Careful, though - blocks don't just come from nothing, and this machine will eventually run out of power once it makes a bunch!|0|3|8000|0|||-1|-1||-1|-1||1|||||||";
								string text30 = "|\nadd_button|builders_lock|`oBuilder's Lock``|interface/large/store_buttons/store_buttons17.rttex|`2You Get:`` 1 Builders Lock.<CR><CR>`5Description:`` Protect up to `$200`` tiles. Wrench the lock to limit it - it can either only allow building, or only allow breaking! `5It's a perma-item, is never lost when destroyed.``|0|2|50000|0|||-1|-1||-1|-1||1|||||||";
								string text31 = "|\nadd_button|weather_sunny|`oWeather Machine - Sunny``|interface/large/store_buttons/store_buttons5.rttex|`2You Get:`` 1 Weather Machine - Sunny.<CR><CR>`5Description:`` You probably don't need this one... but if you ever have a desire to turn a sunset or desert world back to normal, grab a Sunny Weather Machine to restore the default Growtopia sky! `5It's a perma-item, is never lost when destroyed.``|0|5|1000|0|||-1|-1||-1|-1||1|||||||";
								string text32 = "|\nadd_button|weather_night|`oWeather Machine - Night``|interface/large/store_buttons/store_buttons5.rttex|`2You Get:`` 1 Weather Machine - Night.<CR><CR>`5Description:`` You might not call it weather, but we do! This will turn the background of your world into a lovely night scene with stars and moon. `5It's a perma-item, is never lost when destroyed.``|0|6|10000|0|||-1|-1||-1|-1||1|||||||";
								string text33 = "|\nadd_button|weather_arid|`oWeather Machine - Arid``|interface/large/store_buttons/store_buttons5.rttex|`2You Get:`` 1 Weather Machine - Arid.<CR><CR>`5Description:`` Want your world to look like a cartoon desert? This will turn the background of your world into a desert scene with all the trimmings. `5It's a perma-item, is never lost when destroyed.``|0|7|10000|0|||-1|-1||-1|-1||1|||||||";
								string text34 = "|\nadd_button|weather_rainy|`oWeather Machine - Rainy City``|interface/large/store_buttons/store_buttons6.rttex|`2You Get:`` 1 Weather Machine - Rainy City.<CR><CR>`5Description:`` This will turn the background of your world into a dark, rainy city scene complete with sound effects. `5It's a perma-item, is never lost when destroyed.``|0|5|10000|0|||-1|-1||-1|-1||1|||||||";
								string text35 = "|\nadd_button|weather_warp|`oWeather Machine - Warp Speed``|interface/large/store_buttons/store_buttons11.rttex|`2You Get:`` 1 Weather Machine - Warp Speed.<CR><CR>`5Description:`` This Weather Machine will launch your world through space at relativistic speeds, which will cause you to age more slowly, as well as see stars flying by rapidly in the background. `5It's a perma-item, is never lost when destroyed.``|0|3|10000|0|||-1|-1||-1|-1||1|||||||";
								string text36 = "|\nadd_button|mars_blast|`oMars Blast``|interface/large/store_buttons/store_buttons6.rttex|`2You Get:`` 1 Mars Blast.<CR><CR>`5Description:`` Blast off to Mars!  This powerful rocket ship will launch you to a new world set up like the surface of Mars, with a special martian sky background, and unique terrain not found elsewhere in the solar system. Mars even has lower gravity than Growtopia normally does! Remember: When using this, you are creating a NEW world by typing in a new name. You can't convert an existing world to Mars, that would be dangerous.|0|7|15000|0|||-1|-1||-1|-1||1|||||||";
								string text37 = "|\nadd_button|undersea_blast|`oUndersea Blast``|interface/large/store_buttons/store_buttons9.rttex|`2You Get:`` 1 Undersea Blast.<CR><CR>`5Description:`` Explore the ocean!  This advanced device will terraform a new world set up like the bottom of the ocean, with a special ocean background, and special blocks like Seaweed, Coral, Jellyfish, Sharks, and maybe a special surprise... Remember, by using this you are creating a NEW world by typing in a new name. You can't convert an existing world to an ocean, that would be dangerous.|0|7|15000|0|||-1|-1||-1|-1||1|||||||";
								string text38 = "|\nadd_button|cave_blast|`oCave Blast``|interface/large/store_buttons/store_buttons15.rttex|`2You Get:`` 1 Cave Blast.<CR><CR>`5Description:`` This explosive device will punch a hole in the ground, giving you a dark cavern to explore. There are even rumors of treasure and the entrance to ancient mines, hidden deep in the caves... but make sure you bring a World Lock. The blasted world is not locked when it's created, so lock it before somebody shows up! Remember: When using this, you are creating a NEW world by typing in a new name. You can't convert an existing world to a cave, that would be dangerous.|0|2|30000|0|||-1|-1||-1|-1||1|||||||";
								string text39 = "|\nadd_button|weather_stuff|`oWeather Machine - Stuff``|interface/large/store_buttons/store_buttons15.rttex|`2You Get:`` 1 Weather Machine - Stuff.<CR><CR>`5Description:`` This is the most fun weather imaginable - Choose any item from your inventory, adjust some settings, and watch it rain down from the sky! Or up, if you prefer reversing the gravity. `5It's a perma-item, is never lost when destroyed.``|0|6|50000|0|||-1|-1||-1|-1||1|||||||";
								string text40 = "|\nadd_button|weather_jungle|`oWeather Machine - Jungle``|interface/large/store_buttons/store_buttons16.rttex|`2You Get:`` 1 Weather Machine - Jungle.<CR><CR>`5Description:`` This weather machine will turn the background of your world into a steamy jungle. `5It's a perma-item, is never lost when destroyed.``|0|5|20000|0|||-1|-1||-1|-1||1|||||||";
								string text41 = "|\nadd_button|weather_backgd|`oWeather Machine - Background``|interface/large/store_buttons/store_buttons17.rttex|`2You Get:`` 1 Weather Machine - Background.<CR><CR>`5Description:`` This amazing device can scan any Background Block, and will make your entire world look like it's been filled with that block. Also handy for hiding music notes! `5It's a perma-item, is never lost when destroyed.``|0|1|150000|0|||-1|-1||-1|-1||1|||||||";
								string text42 = "|\nadd_button|digital_rain_weather|`oWeather Machine - Digital Rain``|interface/large/store_buttons/store_buttons22.rttex|`2You Get:`` 1 Weather Machine - Digital Rain.<CR><CR>`5Description:`` Take the grow pill, and we'll show you how deep the rabbit hole goes! Splash the scrolling code of creation across the skies of your worlds. They say you learn to understand it after a while... Note: You can only have one of these per world. `5It's a perma-item, is never lost when destroyed.``|0|6|30000|0|||-1|-1||-1|-1||1|||||||";
								string text43 = "|\nadd_button|treasure_blast|`oTreasure Blast``|interface/large/store_buttons/store_buttons26.rttex|`2You Get:`` 1 Treasure Blast.<CR><CR>`5Description:`` Enter a world of snow-capped peaks and long-forgotten mysteries! Riddles and secrets - and a ton of treasure - await those who brave this blast's blocks! Remember, when you use this, it'll create a new world by typing in a new name! No sense in searching for clues to great treasures in well-trod worlds, is there?|0|6|10000|0|||-1|-1||-1|-1||1|||||||";


								storerequest(peer, text1 + text2 + text3 + text4 + text5 + text6 + text7 + text8 + text9 + text10 + text12 + text15 + text16 + text17 + text21 + text22 + text23 + text24 + text25 + text26 + text27 + text28 + text29 + text30 + text31 + text32 + text33 + text34 + text35 + text36 + text37 + text38 + text39 + text40 + text41 + text42 + text43);

							}
							if (cch.find("action|buy\nitem|bigitems") == 0) {
								string text1 = "set_description_text|`2Awesome Items!``  Select the item you'd like more info on, or BACK to go back.";
								string text2 = "|enable_tabs|1";
								string text3 = "|\nadd_tab_button|main_menu|Home|interface/large/btn_shop2.rttex||0|0|0|0||||-1|-1||||";
								string text4 = "|\nadd_tab_button|locks_menu|Locks And Stuff|interface/large/btn_shop2.rttex||0|1|0|0||||-1|-1||||";
								string text5 = "|\nadd_tab_button|itempack_menu|Item Packs|interface/large/btn_shop2.rttex||0|3|0|0||||-1|-1||||";
								string text6 = "|\nadd_tab_button|bigitems_menu|Awesome Items|interface/large/btn_shop2.rttex||1|4|0|0||||-1|-1||||";
								string text7 = "|\nadd_tab_button|weather_menu|Weather Machines|interface/large/btn_shop2.rttex|Tired of the same sunny sky?  We offer alternatives within...|0|5|0|0||||-1|-1||||";
								string text8 = "|\nadd_tab_button|token_menu|Growtoken Items|interface/large/btn_shop2.rttex||0|2|0|0||||-1|-1||||";
								string text9 = "|\nadd_button|sspitems|`oSmall Seed Pack``|interface/large/store_buttons/store_buttons.rttex|`2You Get:`` 1 Small Seed Pack.<CR><CR>`5Description:`` Contains one Small Seed Pack. Open it for `$5`` randomly chosen seeds, including 1 rare seed! Who knows what you'll get?!|1|4|100|0|||-1|-1||-1|-1||1|||||||";
								string text11 = "|\nadd_button|rare_seed|`oRare Seed Pack``|interface/large/store_buttons/store_buttons.rttex|`2You Get:`` 5 Randomly Chosen Rare Seeds.<CR><CR>`5Description:`` Expect some wondrous crops with these!|1|7|500|0|||-1|-1||-1|-1||1|||||||";
								string text12 = "|\nadd_button|grow_spray|`o5-pack of Grow Spray Fertilizer``|interface/large/store_buttons/store_buttons.rttex|`2You Get:`` 5 Grow Spray Fertilizers.<CR><CR>`5Description:`` Why wait?!  Treat yourself to a `$5-pack`` of amazing `wGrow Spray Fertilizer`` by GrowTech Corp.  Each bottle instantly ages a tree by `$1 hour``.|0|6|200|0|||-1|-1||-1|-1||1|||||||";
								string text13 = "|\nadd_button|deluxe_grow_spray|`oDeluxe Grow Spray``|interface/large/store_buttons/store_buttons11.rttex|`2You Get:`` 1 Deluxe Grow Spray.<CR><CR>`5Description:`` GrowTech's new `$Deluxe`` `wGrow Spray`` instantly ages a tree by `$24 hours`` per bottle! That's somewhere around 25 times as much as regular Grow Spray!|0|2|900|0|||-1|-1||-1|-1||1|||||||";
								string text16 = "|\nadd_button|surgical_kit|`oSurgical Kit``|interface/large/store_buttons/store_buttons7.rttex|`2You Get:`` 1 `#Rare Heart Monitor``, 1 Hospital Bed, 1 Train-E Bot, 5 of each of the 13 different Surical Tools and 10 Med-a-Checks.<CR><CR>`5Description:`` Get all the tools you need to become Chief of Surgery at Growtopia General Hospital! `#Rare`` Heart Monitor that lets people know when you are online, Hospital Bed that lets you perform surgery on anybody laying (or standing) on it, Med-a-Checks to identify patients with maladies, The Train-E bot to practice on, and 5 each of the thirteen different Surgical Tools you'll need to do that surgery!|0|2|12000|0|||-1|-1||-1|-1||1|||||||";
								string text18 = "|\nadd_button|fishin_pack|`oFishin' Pack``|interface/large/store_buttons/store_buttons14.rttex|`2You Get:`` 1 Fishing Rod, 5 Wiggly Worms, 1 Hand Drill, 1 Nuclear Detonator,  1 `#Rare Tackle Box``, 10 Fish Tanks and 1 `#Rare Fish Tank Port`` .<CR><CR>`5Description:`` Relax and sit by the shore... this pack includes a Fishing Rod, Wiggly Worms for bait, Hand Drill, Nuclear Detonator, and a `#Rare`` Tackle Box which provides you with more free bait every two days, Fish Tanks, and a `#Rare`` Fish Tank Port to put the fish you catch into your fish tank!|0|0|10000|0|||-1|-1||-1|-1||1|||||||";
								string text26 = "|\nadd_button|geiger|`oGeiger Counter``|interface/large/store_buttons/store_buttons12.rttex|`2You Get:`` 1 Geiger Counter.<CR><CR>`5Description:`` With this fantabulous device, you can detect radiation around you. It bleeps red, then yellow, then green as you get closer to the source. Who knows what you might find? `4Not available any other way!``|0|1|25000|0|||-1|-1||-1|-1||1|||||||";



								storerequest(peer, text1 + text2 + text3 + text4 + text5 + text6 + text7 + text8 + text9 + text11 + text12 + text13 + text16 + text18 + text26);

							}
							if (cch.find("action|buy\nitem|weather") == 0) {
								string text1 = "set_description_text|`2Weather Machines!``  Select the item you'd like more info on, or BACK to go back.";
								string text2 = "|enable_tabs|1";
								string text3 = "|\nadd_tab_button|main_menu|Home|interface/large/btn_shop2.rttex||0|0|0|0||||-1|-1||||";
								string text4 = "|\nadd_tab_button|locks_menu|Locks And Stuff|interface/large/btn_shop2.rttex||0|1|0|0||||-1|-1||||";
								string text5 = "|\nadd_tab_button|itempack_menu|Item Packs|interface/large/btn_shop2.rttex||0|3|0|0||||-1|-1||||";
								string text6 = "|\nadd_tab_button|bigitems_menu|Awesome Items|interface/large/btn_shop2.rttex||0|4|0|0||||-1|-1||||";
								string text7 = "|\nadd_tab_button|weather_menu|Weather Machines|interface/large/btn_shop2.rttex|Tired of the same sunny sky?  We offer alternatives within...|1|5|0|0||||-1|-1||||";
								string text8 = "|\nadd_tab_button|token_menu|Growtoken Items|interface/large/btn_shop2.rttex||0|2|0|0||||-1|-1||||";
								string text14 = "|\nadd_button|vegas_pack|`oVegas Pack``|interface/large/store_buttons/store_buttons4.rttex|`2You Get:`` 10 Neon Lights, 1 Card Block Seed, 1 `#Rare Pink Cadillac`` 4 Flipping Coins, 1 Dice Block, 1 Gamblers Visor, 1 Slot Machine, 1 Roulette Wheel and 1 Showgirl Hat, 1 Showgirl top and 1 Showgirl Leggins.<CR><CR>`5Description:`` What happens in Growtopia stays in Growtopia!|0|5|20000|0|||-1|-1||-1|-1||1|||||||";
								string text15 = "|\nadd_button|farm_pack|`oFarm Pack``|interface/large/store_buttons/store_buttons5.rttex|`2You Get:`` 1 Cow, 1 Chicken, 10 Wheat, 10 Barn Block, 10 Red Wood Walls, 1 Barn Door, 1 Straw Hat, 1 Overalls, 1 Pitchfork, 1 Farmgirl Hair, 1 `#Rare`` `2Dear John Tractor``.<CR><CR>`5Description:`` Put the `2Grow`` in Growtopia with this pack, including a Cow you can milk, a Chicken that lays eggs and a farmer's outfit. Best of all? You get a `#Rare`` `2Dear John Tractor`` you can ride that will mow down trees!|0|0|15000|0|||-1|-1||-1|-1||1|||||||";
								string text16 = "|\nadd_button|science_pack|`oMad Science Kit``|interface/large/store_buttons/store_buttons5.rttex|`2You Get:`` 1 Science Station, 1 Laboratory, 1 LabCoat, 1 Combover Hair, 1 Goggles, 5 Chemical 5, 10 Chemical G, 5 Chemical Y, 5 Chemical B, 5 Chemical P and 1 `#Rare`` `2Death Ray``.<CR><CR>`5Description:`` It's SCIENCE! Defy the natural order with a Science Station that produces chemicals, a Laboratory in which to mix them and a full outfit to do so safely! You'll also get a starter pack of assorted chemicals. Mix them up! Special bonus: A `#Rare`` `2Death Ray`` to make your science truly mad!|0|3|5000|0|||-1|-1||-1|-1||1|||||||";
								string text17 = "|\nadd_button|city_pack|`oCity Pack``|interface/large/store_buttons/store_buttons6.rttex|`2You Get:`` 10 Sidewalks, 3 Street Signs, 3 Streetlamps, 10 Gothic Building tiles, 10 Tenement Building tiles, 10 Fire Escapes, 3 Gargoyles, 10 Hedges, 1 Blue Mailbox, 1 Fire Hydrant and A `#Rare`` `2ATM Machine``.<CR><CR>`5Description:`` Life in the big city is rough but a `#Rare`` `2ATM Machine`` that dishes out gems once a day is very nice!|0|0|8000|0|||-1|-1||-1|-1||1|||||||";
								string text18 = "|\nadd_button|west_pack|`oWild West Pack``|interface/large/store_buttons/store_buttons6.rttex|`2You Get:`` 1 Cowboy Hat, 1 Cowboy Boots, 1 War Paint, 1 Face Bandana, 1 Sheriff Vest, 1 Layer Cake Dress,  1 Corset, 1 Kansas Curls, 10 Western Building 1 Saloon Doors, 5 Western Banners, 1 Buffalo, 10 Rustic Fences, 1 Campfire and 1 Parasol.<CR><CR>`5Description:`` Yippee-kai-yay! This pack includes everything you need to have wild time in the wild west! The Campfire plays cowboy music, and the `#Parasol`` lets you drift down slowly. Special bonus: A `#Rare`` `2Six Shooter`` to blast criminals with!|0|2|8000|0|||-1|-1||-1|-1||1|||||||";
								string text21 = "|\nadd_button|shop_pack|`oShop Pack``|interface/large/store_buttons/store_buttons8.rttex|`2You Get:`` 4 Display Boxes, 1 For Sale Sign, 1 Gem Sign, 1 Exclamation Sign, 1 Shop Sign, 1 Open Sign, 1 Cash Register, 1 Mannequin and 1 Security Camera.<CR><CR>`5Description:`` Run a fancy shop with these new items! Advertise your wares with an Open/Closed Sign you can switch with a punch, a Cash Register, a Mannequin you can dress up to show off clothing, and a `#Rare`` Security Camera, which reports when people enter and take items!|0|7|10000|0|||-1|-1||-1|-1||1|||||||";
								string text32 = "|\nadd_button|paintbrush|`oPainter's Pack``|interface/large/store_buttons/store_buttons15.rttex|`2You Get:`` 1 `#Rare Paintbrush`` and 20 Random Colored Paint Buckets.<CR><CR>`5Description:`` Want to paint your world? This pack includes 20 buckets of random paint colors (may include Varnish, to clean up your messes)! You can paint any block in your world different colors to personalize it.|0|1|30000|0|||-1|-1||-1|-1||1|||||||";
								string text33 = "|\nadd_button|paleo_kit|`oPaleontologist's Kit``|interface/large/store_buttons/store_buttons16.rttex|`2You Get:`` 5 Fossil Brushes, 1 Rock Hammer, 1 Rock Chisel, 1 Blue Hardhat and 1 `#Rare Fossil Prep Station``.<CR><CR>`5Description:`` If you want to dig up fossils, this is the kit for you! Includes everything you need! Use the prepstation to get your fossils ready for display.|0|0|20000|0|||-1|-1||-1|-1||1|||||||";

								storerequest(peer, text1 + text2 + text3 + text4 + text5 + text6 + text7 + text8 + text14 + text15 + text16 + text17 + text32 + text33);

							}
							if (cch.find("action|buy\nitem|token") == 0) {
								string text1 = "set_description_text|`2Spend your Growtokens!`` (You have `52``) You earn Growtokens from Crazy Jim and Sales-Man. Select the item you'd like more info on, or BACK to go back.";
								string text2 = "|enable_tabs|1";
								string text3 = "|\nadd_tab_button|main_menu|Home|interface/large/btn_shop2.rttex||0|0|0|0||||-1|-1||||";
								string text4 = "|\nadd_tab_button|locks_menu|Locks And Stuff|interface/large/btn_shop2.rttex||0|1|0|0||||-1|-1||||";
								string text5 = "|\nadd_tab_button|itempack_menu|Item Packs|interface/large/btn_shop2.rttex||0|3|0|0||||-1|-1||||";
								string text6 = "|\nadd_tab_button|bigitems_menu|Awesome Items|interface/large/btn_shop2.rttex||0|4|0|0||||-1|-1||||";
								string text7 = "|\nadd_tab_button|weather_menu|Weather Machines|interface/large/btn_shop2.rttex|Tired of the same sunny sky?  We offer alternatives within...|0|5|0|0||||-1|-1||||";
								string text8 = "|\nadd_tab_button|token_menu|Growtoken Items|interface/large/btn_shop2.rttex||1|2|0|0||||-1|-1||||";
								string text11 = "|\nadd_button|megaphone|`oMegaphone``|interface/large/store_buttons/store_buttons15.rttex|`2You Get:`` 1 Megaphone.<CR><CR>`5Description:`` You like broadcasting messages, but you're not so big on spending gems? Buy a Megaphone with Growtokens! Each Megaphone can be used once to send a super broadcast to all players in the game.|0|7|-10|0|||-1|-1||-1|-1||1|||||||";
								string text16 = "|\nadd_button|nothingness|`oWeather Machine - Nothingness``|interface/large/store_buttons/store_buttons9.rttex|`2You Get:`` 1 Weather Machine - Nothingness.<CR><CR>`5Description:`` Tired of all that fancy weather?  This machine will turn your world completely black. Yup, that's it. Not a single pixel in the background except pure blackness.|0|3|-50|0|||-1|-1||-1|-1||1|||||||";
								string text18 = "|\nadd_button|doodad|`oDoodad``|interface/large/store_buttons/store_buttons9.rttex|`2You Get:`` 1 Doodad.<CR><CR>`5Description:`` I have no idea what this thing does. It's something electronic? Maybe?|0|5|-75|0|||-1|-1||-1|-1||1|||||||";
								string text19 = "|\nadd_button|crystal_cape|`oCrystal Cape``|interface/large/store_buttons/store_buttons11.rttex|`2You Get:`` 1 Crystal Cape.<CR><CR>`5Description:`` This cape is woven of pure crystal, which makes it pretty uncomfortable. But it also makes it magical! It lets you double-jump off of an imaginary Crystal Block in mid-air. Sponsored by Edvoid20, HemeTems, and Aboge.|0|5|-90|0|||-1|-1||-1|-1||1|||||||";
								string text20 = "|\nadd_button|focused_eyes|`oFocused Eyes``|interface/large/store_buttons/store_buttons9.rttex|`2You Get:`` 1 Focused Eyes.<CR><CR>`5Description:`` This `#Untradeable`` item lets you shoot electricity from your eyes! Wear them with pride, and creepiness.|0|4|-100|0|||-1|-1||-1|-1||1|||||||";
								string text22 = "|\nadd_button|cat_eyes|`oCat Eyes``|interface/large/store_buttons/store_buttons23.rttex|`2You Get:`` 1 Cat Eyes.<CR><CR>`5Description:`` Wow, pawesome! These new eyes are the cat's meow, and the purrfect addition to any style.|0|5|-100|0|||-1|-1||-1|-1||1|||||||";
								string text23 = "|\nadd_button|night_vision|`oNight Vision Goggles``|interface/large/store_buttons/store_buttons15.rttex|`2You Get:`` 1 Night Vision Goggles.<CR><CR>`5Description:`` Scared of the dark? We have a solution. You can wear these goggles just to look cool, but if you also happen to have a D Battery (`4batteries not included``) on you, you will be able to see through darkness like it's not even there! Each D Battery can power your goggles for 1 minute. `2If you are in a world you own, the goggles will not require batteries!`` Note: you can't turn the goggles off without removing them, so you'll be wasting your battery if you wear them in daylight while carrying D Batteries.|0|3|-110|0|||-1|-1||-1|-1||1|||||||";
								string text27 = "|\nadd_button|golden_axe|`oGolden Pickaxe``|interface/large/store_buttons/store_buttons9.rttex|`2You Get:`` 1 Golden Pickaxe.<CR><CR>`5Description:`` Get your own sparkly pickaxe! This `#Untradeable`` item is a status symbol! Oh sure, it isn't any more effective than a normal pickaxe, but it sparkles!|0|1|-200|0|||-1|-1||-1|-1||1|||||||";
								string text28 = "|\nadd_button|puppy_leash|`oPuppy Leash``|interface/large/store_buttons/store_buttons11.rttex|`2You Get:`` 1 Puppy Leash.<CR><CR>`5Description:`` Get your own pet puppy! This little dog will follow you around forever, never wavering in her loyalty, thus making her `#Untradeable``.|0|4|-200|0|||-1|-1||-1|-1||1|||||||";
								string text29 = "|\nadd_button|diggers_spade|`oDigger's Spade``|interface/large/store_buttons/store_buttons13.rttex|`2You Get:`` 1 Digger's Spade.<CR><CR>`5Description:`` This may appear to be a humble shovel, but in fact it is enchanted with the greatest magic in Growtopia. It can smash Dirt or Cave Background in a single hit! Unfortunately, it's worthless at digging through anything else. Note: The spade is `#UNTRADEABLE``.|0|7|-200|0|||-1|-1||-1|-1||1|||||||";
								string text30 = "|\nadd_button|meow_ears|`oMeow Ears``|interface/large/store_buttons/store_buttons22.rttex|`2You Get:`` 1 Meow Ears.<CR><CR>`5Description:`` Meow's super special ears that everyone can now get! Note: These ears are `#UNTRADEABLE``.|0|0|-200|0|||-1|-1||-1|-1||1|||||||";
								string text31 = "|\nadd_button|frosty_hair|`oFrosty Hair``|interface/large/store_buttons/store_buttons23.rttex|`2You Get:`` 1 Frosty Hair.<CR><CR>`5Description:`` Coldplay is cold, but you can be freezing! Note: The frosty hair is `#UNTRADEABLE``.|0|0|-200|0|||-1|-1||-1|-1||1|||||||";


								storerequest(peer, text1 + text2 + text3 + text4 + text5 + text6 + text7 + text8 + text11 + text16 + text18 + text19 + text20 + text22 + text23 + text27 + text28 + text29 + text30 + text31);

							}
							if (cch.find("action|storenavigate\nitem|main\nselection|gems_rain") == 0) {
								string text1 = "set_description_text|Welcome to the `2Growtopia Store``! Select the item you'd like more info on.`o `wWant to get `5Supporter`` status? Any Gem purchase (or `57,000`` Gems earned with free `5Tapjoy`` offers) will make you one. You'll get new skin colors, the `5Recycle`` tool to convert unwanted items into Gems, and more bonuses!";
								string text2 = "|enable_tabs|1";
								string text3 = "|\nadd_tab_button|main_menu|Home|interface/large/btn_shop2.rttex||1|0|0|0||||-1|-1||||";
								string text4 = "|\nadd_tab_button|locks_menu|Locks And Stuff|interface/large/btn_shop2.rttex||0|1|0|0||||-1|-1||||";
								string text5 = "|\nadd_tab_button|itempack_menu|Item Packs|interface/large/btn_shop2.rttex||0|3|0|0||||-1|-1||||";
								string text6 = "|\nadd_tab_button|bigitems_menu|Awesome Items|interface/large/btn_shop2.rttex||0|4|0|0||||-1|-1||||";
								string text7 = "|\nadd_tab_button|weather_menu|Weather Machines|interface/large/btn_shop2.rttex|Tired of the same sunny sky?  We offer alternatives within...|0|5|0|0||||-1|-1||||";
								string text8 = "|\nadd_tab_button|token_menu|Growtoken Items|interface/large/btn_shop2.rttex||0|2|0|0||||-1|-1||||";
								string text9 = "|\nadd_banner|interface/large/gui_shop_featured_header.rttex|0|1|";


								storerequest(peer, text1 + text2 + text3 + text4 + text5 + text6 + text7 + text8 + text9);

							}
							else if (cch == "action|buy\nitem|locks\n" || cch == "action|storenavigate\nitem|locks\nselection|upgrade_backpack\n") {
								string UpgradeInventoryDialog = "";
								if (pData->currentInventorySize <= 190) {
									UpgradeInventoryDialog = "\nadd_button|upgrade_backpack|`0Upgrade Backpack`` (`w10 Slots``)|interface/large/store_buttons/store_buttons.rttex|`2You Get:`` 10 Additional Backpack Slots.<CR><CR>`5Description:`` Sewing an extra pocket onto your backpack will allow you to store `$10`` additional item types.  How else are you going to fit all those toilets and doors?|0|1|6500|0|||-1|-1||-1|-1||1||||||0|";
								}
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStoreRequest"), "set_description_text|`2Locks And Stuff!``  Select the item you'd like more info on, or BACK to go back.\nenable_tabs|1\nadd_tab_button|main_menu|Home|interface/large/btn_shop2.rttex||0|0|0|0||||-1|-1|||0|\nadd_tab_button|locks_menu|Locks And Stuff|interface/large/btn_shop2.rttex||1|1|0|0||||-1|-1|||0|\nadd_tab_button|itempack_menu|Item Packs|interface/large/btn_shop2.rttex||0|3|0|0||||-1|-1|||0|\nadd_tab_button|bigitems_menu|Awesome Items|interface/large/btn_shop2.rttex||0|4|0|0||||-1|-1|||0|\nadd_tab_button|weather_menu|Weather Machines|interface/large/btn_shop2.rttex|Tired of the same sunny sky?  We offer alternatives within...|0|5|0|0||||-1|-1|||0|\nadd_tab_button|token_menu|Growtoken Items|interface/large/btn_shop2.rttex||0|2|0|0||||-1|-1|||0|" + UpgradeInventoryDialog + "\nadd_button|rename|`oBirth Certificate``|interface/large/store_buttons/store_buttons7.rttex|`2You Get:`` 1 Birth Certificate.<CR><CR>`5Description:`` Tired of being who you are? By forging a new birth certificate, you can change your GrowID! The Birth Certificate will be consumed when used. This item only works if you have a GrowID, and you can only use one every 60 days, so you're not confusing everybody.|0|6|20000|0|||-1|-1||-1|-1||1||||||0|\nadd_button|clothes|`oClothes Pack``|interface/large/store_buttons/store_buttons2.rttex|`2You Get:`` 3 Randomly Wearble Items.<CR><CR>`5Description:`` Why not look the part? Some may even have special powers...|0|0|50|0|||-1|-1||-1|-1||1||||||0|\nadd_button|rare_clothes|`oRare Clothes Pack``|interface/large/store_buttons/store_buttons2.rttex|`2You Get:`` 3 Randomly Chosen Wearbale Items.<CR><CR>`5Description:`` Enjoy the garb of kings! Some may even have special powers...|0|1|500|0|||-1|-1||-1|-1||1||||||0|\nadd_button|transmutation_device|`oTransmutabooth``|interface/large/store_buttons/store_buttons27.rttex|`2You Get:`` 1 Transmutabooth.<CR><CR>`5Description:`` Behold! A wondrous technological achievement from the innovative minds at GrowTech, the Transmutabooth allows you to merge clothing items, transferring the visual appearance of one onto another in the same slot! If you've ever wanted your Cyclopean Visor to look like Shades (while keeping its mod), now you can!|0|7|25000|0|||-1|-1||-1|-1||1||||||0|\nadd_button|nyan_hat|`oTurtle Hat``|interface/large/store_buttons/store_buttons3.rttex|`2You Get:`` 1 Turtle Hat.<CR><CR>`5Description:`` It's the greatest hat ever. It bloops out bubbles as you run! `4Not available any other way!``|0|2|25000|0|||-1|-1||-1|-1||1||||||0|\nadd_button|tiny_horsie|`oTiny Horsie``|interface/large/store_buttons/store_buttons3.rttex|`2You Get:`` 1 Tiny Horsie.<CR><CR>`5Description:`` Tired of wearing shoes? Wear a Tiny Horsie instead! Or possibly a large dachshund, we're not sure. Regardless, it lets you run around faster than normal, plus you're on a horse! `4Not available any other way!``|0|5|25000|0|||-1|-1||-1|-1||1||||||0|\nadd_button|star_ship|`oPleiadian Star Ship``|interface/large/store_buttons/store_buttons4.rttex|`2You Get:`` 1 Pleiadian Star Ship.<CR><CR>`5Description:`` Float on, my brother. It's all groovy. This star ship can't fly, but you can still zoom around in it, leaving a trail of energy rings and moving at enhanced speed. Sponsored by Pleiadian. `4Not available any other way!``|0|3|25000|0|||-1|-1||-1|-1||1||||||0|\nadd_button|dragon_hand|`oDragon Hand``|interface/large/store_buttons/store_buttons5.rttex|`2You Get:`` 1 Dragon Hand.<CR><CR>`5Description:`` Call forth the dragons of legend!  With the Dragon Hand, you will command your own pet dragon. Instead of punching blocks or players, you can order your dragon to incinerate them! In addition to just being awesome, this also does increased damage, and pushes other players farther. `4Not available any other way!``|0|1|50000|0|||-1|-1||-1|-1||1||||||0|\nadd_button|corvette|`oLittle Red Corvette``|interface/large/store_buttons/store_buttons6.rttex|`2You Get:`` 1 Little Red Corvette.<CR><CR>`5Description:`` Cruise around the neighborhood in style with this sweet convertible. It moves at enhanced speed and leaves other Growtopians in your dust. `4Not available any other way!``|0|1|25000|0|||-1|-1||-1|-1||1||||||0|\nadd_button|stick_horse|`oStick Horse``|interface/large/store_buttons/store_buttons6.rttex|`2You Get:`` 1 Stick Horse.<CR><CR>`5Description:`` Nobody looks cooler than a person bouncing along on a stick with a fake horse head attached. NOBODY. `4Not available any other way!``|0|3|25000|0|||-1|-1||-1|-1||1||||||0|\nadd_button|ambulance|`oAmbulance``|interface/large/store_buttons/store_buttons7.rttex|`2You Get:`` 1 Ambulance.<CR><CR>`5Description:`` Rush to the scene of an accident while lawyers chase you in this speedy rescue vehicle. `4Not available any other way!``|0|3|25000|0|||-1|-1||-1|-1||1||||||0|\nadd_button|raptor|`oRiding Raptor``|interface/large/store_buttons/store_buttons7.rttex|`2You Get:`` 1 Riding Raptor.<CR><CR>`5Description:`` Long thought to be extinct, it turns out that these dinosaurs are actually alive and easily tamed. And riding one lets you run around faster than normal! `4Not available any other way!``|0|7|25000|0|||-1|-1||-1|-1||1||||||0|\nadd_button|owl|`oMid-Pacific Owl``|interface/large/store_buttons/store_buttons10.rttex|`2You Get:`` 1 Mid-Pacific Owl.<CR><CR>`5Description:`` This owl is a bit lazy - if you stop moving around, he'll land on your head and fall asleep. Dedicated to the students of the Mid-Pacific Institute. `4Not available any other way!``|0|1|30000|0|||-1|-1||-1|-1||1||||||0|\nadd_button|unicorn|`oUnicorn Garland``|interface/large/store_buttons/store_buttons10.rttex|`2You Get:`` 1 Unicorn Garland.<CR><CR>`5Description:`` Prance about in the fields with your very own pet unicorn! It shoots `1R`2A`3I`4N`5B`6O`7W`8S``. `4Not available any other way!``|0|4|50000|0|||-1|-1||-1|-1||1||||||0|\nadd_button|starboard|`oStarBoard``|interface/large/store_buttons/store_buttons11.rttex|`2You Get:`` 1 StarBoard.<CR><CR>`5Description:`` Hoverboards are here at last! Zoom around Growtopia on this brand new model, which is powered by fusion energy (that means stars spit out of the bottom). Moves faster than walking. Sponsored by Miwsky, Chudy, and Dawid. `4Not available any other way!``|0|1|30000|0|||-1|-1||-1|-1||1||||||0|\nadd_button|motorcycle|`oGrowley Motorcycle``|interface/large/store_buttons/store_buttons11.rttex|`2You Get:`` 1 Growley Motorcycle.<CR><CR>`5Description:`` The coolest motorcycles available are Growley Dennisons. Get a sporty blue one today! It even moves faster than walking, which is pretty good for a motorcycle. `4Not available any other way!``|0|6|50000|0|||-1|-1||-1|-1||1||||||0|\nadd_button|monkey_on_back|`oMonkey On Your Back``|interface/large/store_buttons/store_buttons13.rttex|`2You Get:`` 1 Monkey On Your Back.<CR><CR>`5Description:`` Most people work really hard to get rid of these, but hey, if you want one, it's available! `4But not available any other way!`` Sponsored by SweGamerHD's subscribers, Kizashi, and Inforced. `#Note: This is a neck item, not a back item. He's grabbing your neck!``|0|2|50000|0|||-1|-1||-1|-1||1||||||0|\nadd_button|carrot_sword|`oCarrot Sword``|interface/large/store_buttons/store_buttons13.rttex|`2You Get:`` 1 Carrot Sword.<CR><CR>`5Description:`` Razor sharp, yet oddly tasty. This can carve bunny symbols into your foes! `4Not available any other way!`` Sponsored by MrMehMeh.|0|3|15000|0|||-1|-1||-1|-1||1||||||0|\nadd_button|red_bicycle|`oRed Bicycle``|interface/large/store_buttons/store_buttons13.rttex|`2You Get:`` 1 Red Bicycle.<CR><CR>`5Description:`` It's the environmentally friendly way to get around! Ride this bicycle at high speed hither and zither throughout Growtopia. `4Not available any other way!``|0|5|30000|0|||-1|-1||-1|-1||1||||||0|\nadd_button|fire_truck|`oFire Truck``|interface/large/store_buttons/store_buttons14.rttex|`2You Get:`` 1 Fire Truck.<CR><CR>`5Description:`` Race to the scene of the fire in this speedy vehicle! `4Not available any other way!``|0|2|50000|0|||-1|-1||-1|-1||1||||||0|\nadd_button|pet_slime|`oPet Slime``|interface/large/store_buttons/store_buttons14.rttex|`2You Get:`` 1 Pet Slime.<CR><CR>`5Description:`` What could be better than a blob of greasy slime that follows you around? How about a blob of greasy slime that follows you around and spits corrosive acid, melting blocks more quickly than a normal punch? `4Not available any other way!``|0|4|100000|0|||-1|-1||-1|-1||1||||||0|\nadd_button|dabstep_shoes|`oDabstep Low Top Sneakers``|interface/large/store_buttons/store_buttons21.rttex|`2You Get:`` 1 Dabstep Low Top Sneakers.<CR><CR>`5Description:`` Light up every footfall and move to a better beat with these dabulous shoes! When you're wearing these, the world is your dance floor! `4Not available any other way!``|0|2|30000|0|||-1|-1||-1|-1||1||||||0|"));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
								break;
							}
							else if (cch.find("action|buy") == 0) {
								if (cch.find("action|buy\nitem|pineapple_party_pack") == 0) {
									std::ifstream ifsz("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									std::string content((std::istreambuf_iterator<char>(ifsz)),
										(std::istreambuf_iterator<char>()));
									int b = atoi(content.c_str());
									if (b >= 10000)
									{
										bool success = true;
										string text = "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0\n";
										BYTE* data = new BYTE[5 + text.length()];
										BYTE zero = 0;
										int type = 3;
										memcpy(data, &type, 4);
										memcpy(data + 4, text.c_str(), text.length()); // change memcpy here
										memcpy(data + 4 + text.length(), &zero, 1); // change memcpy here, revert to 4
										ENetPacket* packetsou = enet_packet_create(data,
											5 + text.length(),
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetsou);
										int gemcalc10k = b - 10000;
										ofstream myfile2;
										myfile2.open("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										myfile2 << std::to_string(gemcalc10k);
										myfile2.close();
										std::ifstream ifszi("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										std::string contentx((std::istreambuf_iterator<char>(ifszi)),
											(std::istreambuf_iterator<char>()));
										int updgem = atoi(contentx.c_str());
										GamePacket pp = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), updgem));
										ENetPacket* packetpp = enet_packet_create(pp.data,
											pp.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetpp);
										delete pp.data;
										Player::OnConsoleMessage(peer, "`5Got `o1 `2Super Pineapple Party Crate");
										OnStorePurchaseResults(peer, "`oReceived: `o1 `2Super Pineapple Party Crate.");

										SaveItemMoreTimes(8522, 1, peer, success);

										sendSound(peer, "cash_register.wav");
									}
									else {
										OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Gems To Buy This Item. `5Try again later.");
									}
								}
								if (cch.find("action|buy\nitem|pineapple_panic") == 0) {
									std::ifstream ifsz("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									std::string content((std::istreambuf_iterator<char>(ifsz)),
										(std::istreambuf_iterator<char>()));
									int b = atoi(content.c_str());
									if (b >= 18000)
									{
										bool success = true;
										string text = "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0\n";
										BYTE* data = new BYTE[5 + text.length()];
										BYTE zero = 0;
										int type = 3;
										memcpy(data, &type, 4);
										memcpy(data + 4, text.c_str(), text.length()); // change memcpy here
										memcpy(data + 4 + text.length(), &zero, 1); // change memcpy here, revert to 4
										ENetPacket* packetsou = enet_packet_create(data,
											5 + text.length(),
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetsou);
										int gemcalc10k = b - 18000;
										ofstream myfile2;
										myfile2.open("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										myfile2 << std::to_string(gemcalc10k);
										myfile2.close();
										std::ifstream ifszi("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										std::string contentx((std::istreambuf_iterator<char>(ifszi)),
											(std::istreambuf_iterator<char>()));
										int updgem = atoi(contentx.c_str());
										GamePacket pp = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), updgem));
										ENetPacket* packetpp = enet_packet_create(pp.data,
											pp.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetpp);
										delete pp.data;
										Player::OnConsoleMessage(peer, "`5Got `o2 `2Super Pineapple Party Crate");
										OnStorePurchaseResults(peer, "`oReceived: `o2 `2Super Pineapple Party Crate.");

										SaveItemMoreTimes(8522, 2, peer, success);

										sendSound(peer, "cash_register.wav");
									}
									else {
										OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Gems To Buy This Item. `5Try again later.");
									}
								}
								if (cch.find("action|buy\nitem|vending_machine") == 0) {
									std::ifstream ifsz("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									std::string content((std::istreambuf_iterator<char>(ifsz)),
										(std::istreambuf_iterator<char>()));
									int b = atoi(content.c_str());
									if (b >= 8000)
									{
										bool success = true;
										string text = "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0\n";
										BYTE* data = new BYTE[5 + text.length()];
										BYTE zero = 0;
										int type = 3;
										memcpy(data, &type, 4);
										memcpy(data + 4, text.c_str(), text.length()); // change memcpy here
										memcpy(data + 4 + text.length(), &zero, 1); // change memcpy here, revert to 4
										ENetPacket* packetsou = enet_packet_create(data,
											5 + text.length(),
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetsou);
										int gemcalc10k = b - 8000;
										ofstream myfile2;
										myfile2.open("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										myfile2 << std::to_string(gemcalc10k);
										myfile2.close();
										std::ifstream ifszi("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										std::string contentx((std::istreambuf_iterator<char>(ifszi)),
											(std::istreambuf_iterator<char>()));
										int updgem = atoi(contentx.c_str());
										GamePacket pp = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), updgem));
										ENetPacket* packetpp = enet_packet_create(pp.data,
											pp.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetpp);
										delete pp.data;
										Player::OnConsoleMessage(peer, "`5Got `o1 `2Vending Machine");
										OnStorePurchaseResults(peer, "`oReceived: `o1 `2Vending Machine.");

										SaveItemMoreTimes(2978, 1, peer, success);

										sendSound(peer, "cash_register.wav");
									}
									else {
										OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Gems To Buy This Item. `5Try again later.");
									}
								}
								if (cch.find("action|buy\nitem|signal_jammer") == 0) {
									std::ifstream ifsz("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									std::string content((std::istreambuf_iterator<char>(ifsz)),
										(std::istreambuf_iterator<char>()));
									int b = atoi(content.c_str());
									if (b >= 2000)
									{
										bool success = true;
										string text = "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0\n";
										BYTE* data = new BYTE[5 + text.length()];
										BYTE zero = 0;
										int type = 3;
										memcpy(data, &type, 4);
										memcpy(data + 4, text.c_str(), text.length()); // change memcpy here
										memcpy(data + 4 + text.length(), &zero, 1); // change memcpy here, revert to 4
										ENetPacket* packetsou = enet_packet_create(data,
											5 + text.length(),
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetsou);
										int gemcalc10k = b - 2000;
										ofstream myfile2;
										myfile2.open("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										myfile2 << std::to_string(gemcalc10k);
										myfile2.close();
										std::ifstream ifszi("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										std::string contentx((std::istreambuf_iterator<char>(ifszi)),
											(std::istreambuf_iterator<char>()));
										int updgem = atoi(contentx.c_str());
										GamePacket pp = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), updgem));
										ENetPacket* packetpp = enet_packet_create(pp.data,
											pp.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetpp);
										delete pp.data;
										Player::OnConsoleMessage(peer, "`5Got `o1 `2Signal Jammer");
										OnStorePurchaseResults(peer, "`oReceived: `o1 Signal Jammer.");

										SaveItemMoreTimes(226, 1, peer, success);

										sendSound(peer, "cash_register.wav");
									}
									else {
										OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Gems To Buy This Item. `5Try again later.");
									}
								}
								if (cch.find("action|buy\nitem|thermo_blast") == 0) {
									std::ifstream ifsz("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									std::string content((std::istreambuf_iterator<char>(ifsz)),
										(std::istreambuf_iterator<char>()));
									int b = atoi(content.c_str());
									if (b >= 15000)
									{
										bool success = true;
										string text = "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0\n";
										BYTE* data = new BYTE[5 + text.length()];
										BYTE zero = 0;
										int type = 3;
										memcpy(data, &type, 4);
										memcpy(data + 4, text.c_str(), text.length()); // change memcpy here
										memcpy(data + 4 + text.length(), &zero, 1); // change memcpy here, revert to 4
										ENetPacket* packetsou = enet_packet_create(data,
											5 + text.length(),
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetsou);
										int gemcalc10k = b - 15000;
										ofstream myfile2;
										myfile2.open("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										myfile2 << std::to_string(gemcalc10k);
										myfile2.close();
										std::ifstream ifszi("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										std::string contentx((std::istreambuf_iterator<char>(ifszi)),
											(std::istreambuf_iterator<char>()));
										int updgem = atoi(contentx.c_str());
										GamePacket pp = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), updgem));
										ENetPacket* packetpp = enet_packet_create(pp.data,
											pp.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetpp);
										delete pp.data;
										Player::OnConsoleMessage(peer, "`5Got `o1 `2Thermonuclear Blast");
										OnStorePurchaseResults(peer, "`oReceived: `o1 `2Thermonuclear Blast.");

										SaveItemMoreTimes(1402, 1, peer, success);

										sendSound(peer, "cash_register.wav");
									}
									else {
										OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Gems To Buy This Item. `5Try again later.");
									}
								}
								if (cch.find("action|buy\nitem|surg_blast") == 0) {
									std::ifstream ifsz("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									std::string content((std::istreambuf_iterator<char>(ifsz)),
										(std::istreambuf_iterator<char>()));
									int b = atoi(content.c_str());
									if (b >= 10000)
									{
										bool success = true;
										string text = "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0\n";
										BYTE* data = new BYTE[5 + text.length()];
										BYTE zero = 0;
										int type = 3;
										memcpy(data, &type, 4);
										memcpy(data + 4, text.c_str(), text.length()); // change memcpy here
										memcpy(data + 4 + text.length(), &zero, 1); // change memcpy here, revert to 4
										ENetPacket* packetsou = enet_packet_create(data,
											5 + text.length(),
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetsou);
										int gemcalc10k = b - 10000;
										ofstream myfile2;
										myfile2.open("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										myfile2 << std::to_string(gemcalc10k);
										myfile2.close();
										std::ifstream ifszi("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										std::string contentx((std::istreambuf_iterator<char>(ifszi)),
											(std::istreambuf_iterator<char>()));
										int updgem = atoi(contentx.c_str());
										GamePacket pp = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), updgem));
										ENetPacket* packetpp = enet_packet_create(pp.data,
											pp.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetpp);
										delete pp.data;
										Player::OnConsoleMessage(peer, "`5Got `o1 `2SurgWorld Blast.");
										Player::OnConsoleMessage(peer, "`5Got `o1 `2Caduceaxe.");
										OnStorePurchaseResults(peer, "`oReceived: `o1 `2SurgWorld Blast `oand 1 `2Caduceaxe.");

										SaveItemMoreTimes(8556, 1, peer, success);
										SaveItemMoreTimes(8554, 1, peer, success);

										sendSound(peer, "cash_register.wav");
									}
									else {
										OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Gems To Buy This Item. `5Try again later.");
									}
								}
								if (cch.find("action|buy\nitem|bountiful_blast") == 0) {
									std::ifstream ifsz("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									std::string content((std::istreambuf_iterator<char>(ifsz)),
										(std::istreambuf_iterator<char>()));
									int b = atoi(content.c_str());
									if (b >= 5000)
									{
										bool success = true;
										string text = "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0\n";
										BYTE* data = new BYTE[5 + text.length()];
										BYTE zero = 0;
										int type = 3;
										memcpy(data, &type, 4);
										memcpy(data + 4, text.c_str(), text.length()); // change memcpy here
										memcpy(data + 4 + text.length(), &zero, 1); // change memcpy here, revert to 4
										ENetPacket* packetsou = enet_packet_create(data,
											5 + text.length(),
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetsou);
										int gemcalc10k = b - 5000;
										ofstream myfile2;
										myfile2.open("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										myfile2 << std::to_string(gemcalc10k);
										myfile2.close();
										std::ifstream ifszi("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										std::string contentx((std::istreambuf_iterator<char>(ifszi)),
											(std::istreambuf_iterator<char>()));
										int updgem = atoi(contentx.c_str());
										GamePacket pp = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), updgem));
										ENetPacket* packetpp = enet_packet_create(pp.data,
											pp.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetpp);
										delete pp.data;
										Player::OnConsoleMessage(peer, "`5Got `o1 `2Bountiful Blast.");
										OnStorePurchaseResults(peer, "`oReceived: `o1 `2Bountiful Blast.");

										SaveItemMoreTimes(8738, 1, peer, success);

										sendSound(peer, "cash_register.wav");
									}
									else {
										OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Gems To Buy This Item. `5Try again later.");
									}
								}
								if (cch.find("action|buy\nitem|weather_sunny") == 0) {
									std::ifstream ifsz("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									std::string content((std::istreambuf_iterator<char>(ifsz)),
										(std::istreambuf_iterator<char>()));
									int b = atoi(content.c_str());
									if (b >= 1000)
									{
										bool success = true;
										string text = "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0\n";
										BYTE* data = new BYTE[5 + text.length()];
										BYTE zero = 0;
										int type = 3;
										memcpy(data, &type, 4);
										memcpy(data + 4, text.c_str(), text.length()); // change memcpy here
										memcpy(data + 4 + text.length(), &zero, 1); // change memcpy here, revert to 4
										ENetPacket* packetsou = enet_packet_create(data,
											5 + text.length(),
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetsou);
										int gemcalc10k = b - 1000;
										ofstream myfile2;
										myfile2.open("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										myfile2 << std::to_string(gemcalc10k);
										myfile2.close();
										std::ifstream ifszi("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										std::string contentx((std::istreambuf_iterator<char>(ifszi)),
											(std::istreambuf_iterator<char>()));
										int updgem = atoi(contentx.c_str());
										GamePacket pp = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), updgem));
										ENetPacket* packetpp = enet_packet_create(pp.data,
											pp.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetpp);
										delete pp.data;
										Player::OnConsoleMessage(peer, "`5Got `o1 `2Weather Machine - Sunny.");
										OnStorePurchaseResults(peer, "`oReceived: `o1 `2Weather Machine - Sunny.");

										SaveItemMoreTimes(932, 1, peer, success);

										sendSound(peer, "cash_register.wav");
									}
									else {
										OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Gems To Buy This Item. `5Try again later.");
									}
								}
								if (cch.find("action|buy\nitem|weather_night") == 0) {
									std::ifstream ifsz("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									std::string content((std::istreambuf_iterator<char>(ifsz)),
										(std::istreambuf_iterator<char>()));
									int b = atoi(content.c_str());
									if (b >= 10000)
									{
										bool success = true;
										string text = "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0\n";
										BYTE* data = new BYTE[5 + text.length()];
										BYTE zero = 0;
										int type = 3;
										memcpy(data, &type, 4);
										memcpy(data + 4, text.c_str(), text.length()); // change memcpy here
										memcpy(data + 4 + text.length(), &zero, 1); // change memcpy here, revert to 4
										ENetPacket* packetsou = enet_packet_create(data,
											5 + text.length(),
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetsou);
										int gemcalc10k = b - 10000;
										ofstream myfile2;
										myfile2.open("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										myfile2 << std::to_string(gemcalc10k);
										myfile2.close();
										std::ifstream ifszi("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										std::string contentx((std::istreambuf_iterator<char>(ifszi)),
											(std::istreambuf_iterator<char>()));
										int updgem = atoi(contentx.c_str());
										GamePacket pp = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), updgem));
										ENetPacket* packetpp = enet_packet_create(pp.data,
											pp.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetpp);
										delete pp.data;
										Player::OnConsoleMessage(peer, "`5Got `o1 `2Weather Machine - Night.");
										OnStorePurchaseResults(peer, "`oReceived: `o1 `2Weather Machine - Night.");

										SaveItemMoreTimes(934, 1, peer, success);

										sendSound(peer, "cash_register.wav");
									}
									else {
										OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Gems To Buy This Item. `5Try again later.");
									}
								}
								if (cch.find("action|buy\nitem|weather_arid") == 0) {
									std::ifstream ifsz("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									std::string content((std::istreambuf_iterator<char>(ifsz)),
										(std::istreambuf_iterator<char>()));
									int b = atoi(content.c_str());
									if (b >= 10000)
									{
										bool success = true;
										string text = "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0\n";
										BYTE* data = new BYTE[5 + text.length()];
										BYTE zero = 0;
										int type = 3;
										memcpy(data, &type, 4);
										memcpy(data + 4, text.c_str(), text.length()); // change memcpy here
										memcpy(data + 4 + text.length(), &zero, 1); // change memcpy here, revert to 4
										ENetPacket* packetsou = enet_packet_create(data,
											5 + text.length(),
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetsou);
										int gemcalc10k = b - 10000;
										ofstream myfile2;
										myfile2.open("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										myfile2 << std::to_string(gemcalc10k);
										myfile2.close();
										std::ifstream ifszi("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										std::string contentx((std::istreambuf_iterator<char>(ifszi)),
											(std::istreambuf_iterator<char>()));
										int updgem = atoi(contentx.c_str());
										GamePacket pp = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), updgem));
										ENetPacket* packetpp = enet_packet_create(pp.data,
											pp.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetpp);
										delete pp.data;
										Player::OnConsoleMessage(peer, "`5Got `o1 `2Weather Machine - Arid.");
										OnStorePurchaseResults(peer, "`oReceived: `o1 `2Weather Machine - Arid.");

										SaveItemMoreTimes(946, 1, peer, success);

										sendSound(peer, "cash_register.wav");
									}
									else {
										OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Gems To Buy This Item. `5Try again later.");
									}
								}
								if (cch.find("action|buy\nitem|weather_rainy") == 0) {
									std::ifstream ifsz("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									std::string content((std::istreambuf_iterator<char>(ifsz)),
										(std::istreambuf_iterator<char>()));
									int b = atoi(content.c_str());
									if (b >= 10000)
									{
										bool success = true;
										string text = "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0\n";
										BYTE* data = new BYTE[5 + text.length()];
										BYTE zero = 0;
										int type = 3;
										memcpy(data, &type, 4);
										memcpy(data + 4, text.c_str(), text.length()); // change memcpy here
										memcpy(data + 4 + text.length(), &zero, 1); // change memcpy here, revert to 4
										ENetPacket* packetsou = enet_packet_create(data,
											5 + text.length(),
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetsou);
										int gemcalc10k = b - 10000;
										ofstream myfile2;
										myfile2.open("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										myfile2 << std::to_string(gemcalc10k);
										myfile2.close();
										std::ifstream ifszi("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										std::string contentx((std::istreambuf_iterator<char>(ifszi)),
											(std::istreambuf_iterator<char>()));
										int updgem = atoi(contentx.c_str());
										GamePacket pp = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), updgem));
										ENetPacket* packetpp = enet_packet_create(pp.data,
											pp.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetpp);
										delete pp.data;
										Player::OnConsoleMessage(peer, "`5Got `o1 `2Weather Machine - Rainy City.");
										OnStorePurchaseResults(peer, "`oReceived: `o1 `2Weather Machine - Rainy City.");

										SaveItemMoreTimes(984, 1, peer, success);

										sendSound(peer, "cash_register.wav");
									}
									else {
										OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Gems To Buy This Item. `5Try again later.");
									}
								}
								if (cch.find("action|buy\nitem|weather_warp") == 0) {
									std::ifstream ifsz("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									std::string content((std::istreambuf_iterator<char>(ifsz)),
										(std::istreambuf_iterator<char>()));
									int b = atoi(content.c_str());
									if (b >= 10000)
									{
										bool success = true;
										string text = "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0\n";
										BYTE* data = new BYTE[5 + text.length()];
										BYTE zero = 0;
										int type = 3;
										memcpy(data, &type, 4);
										memcpy(data + 4, text.c_str(), text.length()); // change memcpy here
										memcpy(data + 4 + text.length(), &zero, 1); // change memcpy here, revert to 4
										ENetPacket* packetsou = enet_packet_create(data,
											5 + text.length(),
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetsou);
										int gemcalc10k = b - 10000;
										ofstream myfile2;
										myfile2.open("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										myfile2 << std::to_string(gemcalc10k);
										myfile2.close();
										std::ifstream ifszi("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										std::string contentx((std::istreambuf_iterator<char>(ifszi)),
											(std::istreambuf_iterator<char>()));
										int updgem = atoi(contentx.c_str());
										GamePacket pp = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), updgem));
										ENetPacket* packetpp = enet_packet_create(pp.data,
											pp.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetpp);
										delete pp.data;
										Player::OnConsoleMessage(peer, "`5Got `o1 `2Weather Machine - Warp Speed.");
										OnStorePurchaseResults(peer, "`oReceived: `o1 `2Weather Machine - Warp Speed.");

										SaveItemMoreTimes(1750, 1, peer, success);

										sendSound(peer, "cash_register.wav");
									}
									else {
										OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Gems To Buy This Item. `5Try again later.");
									}
								}
								if (cch.find("action|buy\nitem|mars_blast") == 0) {
									std::ifstream ifsz("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									std::string content((std::istreambuf_iterator<char>(ifsz)),
										(std::istreambuf_iterator<char>()));
									int b = atoi(content.c_str());
									if (b >= 15000)
									{
										bool success = true;
										string text = "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0\n";
										BYTE* data = new BYTE[5 + text.length()];
										BYTE zero = 0;
										int type = 3;
										memcpy(data, &type, 4);
										memcpy(data + 4, text.c_str(), text.length()); // change memcpy here
										memcpy(data + 4 + text.length(), &zero, 1); // change memcpy here, revert to 4
										ENetPacket* packetsou = enet_packet_create(data,
											5 + text.length(),
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetsou);
										int gemcalc10k = b - 15000;
										ofstream myfile2;
										myfile2.open("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										myfile2 << std::to_string(gemcalc10k);
										myfile2.close();
										std::ifstream ifszi("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										std::string contentx((std::istreambuf_iterator<char>(ifszi)),
											(std::istreambuf_iterator<char>()));
										int updgem = atoi(contentx.c_str());
										GamePacket pp = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), updgem));
										ENetPacket* packetpp = enet_packet_create(pp.data,
											pp.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetpp);
										delete pp.data;
										Player::OnConsoleMessage(peer, "`5Got `o1 `2Mars Blast.");
										OnStorePurchaseResults(peer, "`oReceived: `o1 `2Mars Blast.");

										SaveItemMoreTimes(1136, 1, peer, success);

										sendSound(peer, "cash_register.wav");
									}
									else {
										OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Gems To Buy This Item. `5Try again later.");
									}
								}
								if (cch.find("action|buy\nitem|undersea_blast") == 0) {
									std::ifstream ifsz("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									std::string content((std::istreambuf_iterator<char>(ifsz)),
										(std::istreambuf_iterator<char>()));
									int b = atoi(content.c_str());
									if (b >= 15000)
									{
										bool success = true;
										string text = "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0\n";
										BYTE* data = new BYTE[5 + text.length()];
										BYTE zero = 0;
										int type = 3;
										memcpy(data, &type, 4);
										memcpy(data + 4, text.c_str(), text.length()); // change memcpy here
										memcpy(data + 4 + text.length(), &zero, 1); // change memcpy here, revert to 4
										ENetPacket* packetsou = enet_packet_create(data,
											5 + text.length(),
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetsou);
										int gemcalc10k = b - 15000;
										ofstream myfile2;
										myfile2.open("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										myfile2 << std::to_string(gemcalc10k);
										myfile2.close();
										std::ifstream ifszi("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										std::string contentx((std::istreambuf_iterator<char>(ifszi)),
											(std::istreambuf_iterator<char>()));
										int updgem = atoi(contentx.c_str());
										GamePacket pp = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), updgem));
										ENetPacket* packetpp = enet_packet_create(pp.data,
											pp.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetpp);
										delete pp.data;
										Player::OnConsoleMessage(peer, "`5Got `o1 `2Undersea Blast.");
										OnStorePurchaseResults(peer, "`oReceived: `o1 `2Undersea Blast.");

										SaveItemMoreTimes(1532, 1, peer, success);

										sendSound(peer, "cash_register.wav");
									}
									else {
										OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Gems To Buy This Item. `5Try again later.");
									}
								}
								if (cch.find("action|buy\nitem|cave_blast") == 0) {
									std::ifstream ifsz("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									std::string content((std::istreambuf_iterator<char>(ifsz)),
										(std::istreambuf_iterator<char>()));
									int b = atoi(content.c_str());
									if (b >= 30000)
									{
										bool success = true;
										string text = "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0\n";
										BYTE* data = new BYTE[5 + text.length()];
										BYTE zero = 0;
										int type = 3;
										memcpy(data, &type, 4);
										memcpy(data + 4, text.c_str(), text.length()); // change memcpy here
										memcpy(data + 4 + text.length(), &zero, 1); // change memcpy here, revert to 4
										ENetPacket* packetsou = enet_packet_create(data,
											5 + text.length(),
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetsou);
										int gemcalc10k = b - 30000;
										ofstream myfile2;
										myfile2.open("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										myfile2 << std::to_string(gemcalc10k);
										myfile2.close();
										std::ifstream ifszi("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										std::string contentx((std::istreambuf_iterator<char>(ifszi)),
											(std::istreambuf_iterator<char>()));
										int updgem = atoi(contentx.c_str());
										GamePacket pp = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), updgem));
										ENetPacket* packetpp = enet_packet_create(pp.data,
											pp.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetpp);
										delete pp.data;
										Player::OnConsoleMessage(peer, "`5Got `o1 `2Cave Blast.");
										OnStorePurchaseResults(peer, "`oReceived: `o1 `2Cave Blast.");

										SaveItemMoreTimes(3562, 1, peer, success);

										sendSound(peer, "cash_register.wav");
									}
									else {
										OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Gems To Buy This Item. `5Try again later.");
									}
								}
								if (cch.find("action|buy\nitem|weather_stuff") == 0) {
									std::ifstream ifsz("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									std::string content((std::istreambuf_iterator<char>(ifsz)),
										(std::istreambuf_iterator<char>()));
									int b = atoi(content.c_str());
									if (b >= 50000)
									{
										bool success = true;
										string text = "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0\n";
										BYTE* data = new BYTE[5 + text.length()];
										BYTE zero = 0;
										int type = 3;
										memcpy(data, &type, 4);
										memcpy(data + 4, text.c_str(), text.length()); // change memcpy here
										memcpy(data + 4 + text.length(), &zero, 1); // change memcpy here, revert to 4
										ENetPacket* packetsou = enet_packet_create(data,
											5 + text.length(),
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetsou);
										int gemcalc10k = b - 50000;
										ofstream myfile2;
										myfile2.open("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										myfile2 << std::to_string(gemcalc10k);
										myfile2.close();
										std::ifstream ifszi("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										std::string contentx((std::istreambuf_iterator<char>(ifszi)),
											(std::istreambuf_iterator<char>()));
										int updgem = atoi(contentx.c_str());
										GamePacket pp = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), updgem));
										ENetPacket* packetpp = enet_packet_create(pp.data,
											pp.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetpp);
										delete pp.data;
										Player::OnConsoleMessage(peer, "`5Got `o1 `2Weather Machine - Stuff.");
										OnStorePurchaseResults(peer, "`oReceived: `o1 `2CWeather Machine - Stuff.");

										SaveItemMoreTimes(3832, 1, peer, success);

										sendSound(peer, "cash_register.wav");
									}
									else {
										OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Gems To Buy This Item. `5Try again later.");
									}
								}
								if (cch.find("action|buy\nitem|weather_jungle") == 0) {
									std::ifstream ifsz("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									std::string content((std::istreambuf_iterator<char>(ifsz)),
										(std::istreambuf_iterator<char>()));
									int b = atoi(content.c_str());
									if (b >= 20000)
									{
										bool success = true;
										string text = "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0\n";
										BYTE* data = new BYTE[5 + text.length()];
										BYTE zero = 0;
										int type = 3;
										memcpy(data, &type, 4);
										memcpy(data + 4, text.c_str(), text.length()); // change memcpy here
										memcpy(data + 4 + text.length(), &zero, 1); // change memcpy here, revert to 4
										ENetPacket* packetsou = enet_packet_create(data,
											5 + text.length(),
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetsou);
										int gemcalc10k = b - 20000;
										ofstream myfile2;
										myfile2.open("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										myfile2 << std::to_string(gemcalc10k);
										myfile2.close();
										std::ifstream ifszi("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										std::string contentx((std::istreambuf_iterator<char>(ifszi)),
											(std::istreambuf_iterator<char>()));
										int updgem = atoi(contentx.c_str());
										GamePacket pp = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), updgem));
										ENetPacket* packetpp = enet_packet_create(pp.data,
											pp.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetpp);
										delete pp.data;
										Player::OnConsoleMessage(peer, "`5Got `o1 `2Weather Machine - Jungle.");
										OnStorePurchaseResults(peer, "`oReceived: `o1 `2CWeather Machine - Jungle.");

										SaveItemMoreTimes(4776, 1, peer, success);

										sendSound(peer, "cash_register.wav");
									}
									else {
										OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Gems To Buy This Item. `5Try again later.");
									}
								}
								if (cch.find("action|buy\nitem|weather_backgd") == 0) {
									std::ifstream ifsz("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									std::string content((std::istreambuf_iterator<char>(ifsz)),
										(std::istreambuf_iterator<char>()));
									int b = atoi(content.c_str());
									if (b >= 150000)
									{
										bool success = true;
										string text = "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0\n";
										BYTE* data = new BYTE[5 + text.length()];
										BYTE zero = 0;
										int type = 3;
										memcpy(data, &type, 4);
										memcpy(data + 4, text.c_str(), text.length()); // change memcpy here
										memcpy(data + 4 + text.length(), &zero, 1); // change memcpy here, revert to 4
										ENetPacket* packetsou = enet_packet_create(data,
											5 + text.length(),
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetsou);
										int gemcalc10k = b - 150000;
										ofstream myfile2;
										myfile2.open("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										myfile2 << std::to_string(gemcalc10k);
										myfile2.close();
										std::ifstream ifszi("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										std::string contentx((std::istreambuf_iterator<char>(ifszi)),
											(std::istreambuf_iterator<char>()));
										int updgem = atoi(contentx.c_str());
										GamePacket pp = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), updgem));
										ENetPacket* packetpp = enet_packet_create(pp.data,
											pp.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetpp);
										delete pp.data;
										Player::OnConsoleMessage(peer, "`5Got `o1 `2Weather Machine - Background.");
										OnStorePurchaseResults(peer, "`oReceived: `o1 `2CWeather Machine - Background.");

										SaveItemMoreTimes(5000, 1, peer, success);

										sendSound(peer, "cash_register.wav");
									}
									else {
										OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Gems To Buy This Item. `5Try again later.");
									}
								}
								if (cch.find("action|buy\nitem|digital_rain_weather") == 0) {
									std::ifstream ifsz("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									std::string content((std::istreambuf_iterator<char>(ifsz)),
										(std::istreambuf_iterator<char>()));
									int b = atoi(content.c_str());
									if (b >= 30000)
									{
										bool success = true;
										string text = "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0\n";
										BYTE* data = new BYTE[5 + text.length()];
										BYTE zero = 0;
										int type = 3;
										memcpy(data, &type, 4);
										memcpy(data + 4, text.c_str(), text.length()); // change memcpy here
										memcpy(data + 4 + text.length(), &zero, 1); // change memcpy here, revert to 4
										ENetPacket* packetsou = enet_packet_create(data,
											5 + text.length(),
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetsou);
										int gemcalc10k = b - 30000;
										ofstream myfile2;
										myfile2.open("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										myfile2 << std::to_string(gemcalc10k);
										myfile2.close();
										std::ifstream ifszi("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										std::string contentx((std::istreambuf_iterator<char>(ifszi)),
											(std::istreambuf_iterator<char>()));
										int updgem = atoi(contentx.c_str());
										GamePacket pp = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), updgem));
										ENetPacket* packetpp = enet_packet_create(pp.data,
											pp.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetpp);
										delete pp.data;
										Player::OnConsoleMessage(peer, "`5Got `o1 `2Weather Machine - Digital Rain.");
										OnStorePurchaseResults(peer, "`oReceived: `o1 `2Weather Machine - Digital Rain.");

										SaveItemMoreTimes(6854, 1, peer, success);

										sendSound(peer, "cash_register.wav");
									}
									else {
										OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Gems To Buy This Item. `5Try again later.");
									}
								}
								if (cch.find("action|buy\nitem|treasure_blast") == 0) {
									std::ifstream ifsz("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									std::string content((std::istreambuf_iterator<char>(ifsz)),
										(std::istreambuf_iterator<char>()));
									int b = atoi(content.c_str());
									if (b >= 10000)
									{
										bool success = true;
										string text = "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0\n";
										BYTE* data = new BYTE[5 + text.length()];
										BYTE zero = 0;
										int type = 3;
										memcpy(data, &type, 4);
										memcpy(data + 4, text.c_str(), text.length()); // change memcpy here
										memcpy(data + 4 + text.length(), &zero, 1); // change memcpy here, revert to 4
										ENetPacket* packetsou = enet_packet_create(data,
											5 + text.length(),
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetsou);
										int gemcalc10k = b - 10000;
										ofstream myfile2;
										myfile2.open("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										myfile2 << std::to_string(gemcalc10k);
										myfile2.close();
										std::ifstream ifszi("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										std::string contentx((std::istreambuf_iterator<char>(ifszi)),
											(std::istreambuf_iterator<char>()));
										int updgem = atoi(contentx.c_str());
										GamePacket pp = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), updgem));
										ENetPacket* packetpp = enet_packet_create(pp.data,
											pp.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetpp);
										delete pp.data;
										Player::OnConsoleMessage(peer, "`5Got `o1 `2Treasure Blast.");
										OnStorePurchaseResults(peer, "`oReceived: `o1 `2Treasure Blast.");

										SaveItemMoreTimes(7588, 1, peer, success);

										sendSound(peer, "cash_register.wav");
									}
									else {
										OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Gems To Buy This Item. `5Try again later.");
									}
								}
								if (cch.find("action|buy\nitem|builders_lock") == 0) {
									std::ifstream ifsz("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									std::string content((std::istreambuf_iterator<char>(ifsz)),
										(std::istreambuf_iterator<char>()));
									int b = atoi(content.c_str());
									if (b >= 50000)
									{
										bool success = true;
										string text = "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0\n";
										BYTE* data = new BYTE[5 + text.length()];
										BYTE zero = 0;
										int type = 3;
										memcpy(data, &type, 4);
										memcpy(data + 4, text.c_str(), text.length()); // change memcpy here
										memcpy(data + 4 + text.length(), &zero, 1); // change memcpy here, revert to 4
										ENetPacket* packetsou = enet_packet_create(data,
											5 + text.length(),
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetsou);
										int gemcalc10k = b - 50000;
										ofstream myfile2;
										myfile2.open("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										myfile2 << std::to_string(gemcalc10k);
										myfile2.close();
										std::ifstream ifszi("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										std::string contentx((std::istreambuf_iterator<char>(ifszi)),
											(std::istreambuf_iterator<char>()));
										int updgem = atoi(contentx.c_str());
										GamePacket pp = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), updgem));
										ENetPacket* packetpp = enet_packet_create(pp.data,
											pp.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetpp);
										delete pp.data;
										Player::OnConsoleMessage(peer, "`5Got `o1 `2Builder's Lock.");
										OnStorePurchaseResults(peer, "`oReceived: `o1 `2Builder's Lock.");

										SaveItemMoreTimes(4994, 1, peer, success);

										sendSound(peer, "cash_register.wav");
									}
									else {
										OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Gems To Buy This Item. `5Try again later.");
									}
								}
								if (cch.find("action|buy\nitem|building_blocks_machine") == 0) {
									std::ifstream ifsz("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									std::string content((std::istreambuf_iterator<char>(ifsz)),
										(std::istreambuf_iterator<char>()));
									int b = atoi(content.c_str());
									if (b >= 8000)
									{
										bool success = true;
										string text = "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0\n";
										BYTE* data = new BYTE[5 + text.length()];
										BYTE zero = 0;
										int type = 3;
										memcpy(data, &type, 4);
										memcpy(data + 4, text.c_str(), text.length()); // change memcpy here
										memcpy(data + 4 + text.length(), &zero, 1); // change memcpy here, revert to 4
										ENetPacket* packetsou = enet_packet_create(data,
											5 + text.length(),
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetsou);
										int gemcalc10k = b - 8000;
										ofstream myfile2;
										myfile2.open("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										myfile2 << std::to_string(gemcalc10k);
										myfile2.close();
										std::ifstream ifszi("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										std::string contentx((std::istreambuf_iterator<char>(ifszi)),
											(std::istreambuf_iterator<char>()));
										int updgem = atoi(contentx.c_str());
										GamePacket pp = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), updgem));
										ENetPacket* packetpp = enet_packet_create(pp.data,
											pp.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetpp);
										delete pp.data;
										Player::OnConsoleMessage(peer, "`5Got `o1 `2Building Blocks Machine.");
										OnStorePurchaseResults(peer, "`oReceived: `o1 `2Building Blocks Machine.");

										SaveItemMoreTimes(8196, 1, peer, success);

										sendSound(peer, "cash_register.wav");
									}
									else {
										OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Gems To Buy This Item. `5Try again later.");
									}
								}
								if (cch.find("action|buy\nitem|antigravity_generator") == 0) {
									std::ifstream ifsz("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									std::string content((std::istreambuf_iterator<char>(ifsz)),
										(std::istreambuf_iterator<char>()));
									int b = atoi(content.c_str());
									if (b >= 450000)
									{
										bool success = true;
										string text = "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0\n";
										BYTE* data = new BYTE[5 + text.length()];
										BYTE zero = 0;
										int type = 3;
										memcpy(data, &type, 4);
										memcpy(data + 4, text.c_str(), text.length()); // change memcpy here
										memcpy(data + 4 + text.length(), &zero, 1); // change memcpy here, revert to 4
										ENetPacket* packetsou = enet_packet_create(data,
											5 + text.length(),
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetsou);
										int gemcalc10k = b - 450000;
										ofstream myfile2;
										myfile2.open("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										myfile2 << std::to_string(gemcalc10k);
										myfile2.close();
										std::ifstream ifszi("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										std::string contentx((std::istreambuf_iterator<char>(ifszi)),
											(std::istreambuf_iterator<char>()));
										int updgem = atoi(contentx.c_str());
										GamePacket pp = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), updgem));
										ENetPacket* packetpp = enet_packet_create(pp.data,
											pp.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetpp);
										delete pp.data;
										Player::OnConsoleMessage(peer, "`5Got `o1 `2Antigravity Generator.");
										OnStorePurchaseResults(peer, "`oReceived: `o1 `2Antigravity Generator.");

										SaveItemMoreTimes(4992, 1, peer, success);

										sendSound(peer, "cash_register.wav");
									}
									else {
										OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Gems To Buy This Item. `5Try again later.");
									}
								}
								if (cch.find("action|buy\nitem|starship_blast") == 0) {
									std::ifstream ifsz("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									std::string content((std::istreambuf_iterator<char>(ifsz)),
										(std::istreambuf_iterator<char>()));
									int b = atoi(content.c_str());
									if (b >= 20000)
									{
										bool success = true;
										string text = "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0\n";
										BYTE* data = new BYTE[5 + text.length()];
										BYTE zero = 0;
										int type = 3;
										memcpy(data, &type, 4);
										memcpy(data + 4, text.c_str(), text.length()); // change memcpy here
										memcpy(data + 4 + text.length(), &zero, 1); // change memcpy here, revert to 4
										ENetPacket* packetsou = enet_packet_create(data,
											5 + text.length(),
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetsou);
										int gemcalc10k = b - 20000;
										ofstream myfile2;
										myfile2.open("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										myfile2 << std::to_string(gemcalc10k);
										myfile2.close();
										std::ifstream ifszi("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										std::string contentx((std::istreambuf_iterator<char>(ifszi)),
											(std::istreambuf_iterator<char>()));
										int updgem = atoi(contentx.c_str());
										GamePacket pp = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), updgem));
										ENetPacket* packetpp = enet_packet_create(pp.data,
											pp.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetpp);
										delete pp.data;
										Player::OnConsoleMessage(peer, "`5Got `o1 `2Imperial Starship Blast.");
										OnStorePurchaseResults(peer, "`oReceived: `o1 `2Imperial Starship Blast.");

										SaveItemMoreTimes(6240, 1, peer, success);

										sendSound(peer, "cash_register.wav");
									}
									else {
										OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Gems To Buy This Item. `5Try again later.");
									}
								}
								if (cch.find("action|buy\nitem|clothes") == 0) {
									std::ifstream ifsz("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									std::string content((std::istreambuf_iterator<char>(ifsz)),
										(std::istreambuf_iterator<char>()));
									int b = atoi(content.c_str());
									if (b >= 50)
									{
										bool success = true;
										string text = "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0\n";
										BYTE* data = new BYTE[5 + text.length()];
										BYTE zero = 0;
										int type = 3;
										memcpy(data, &type, 4);
										memcpy(data + 4, text.c_str(), text.length()); // change memcpy here
										memcpy(data + 4 + text.length(), &zero, 1); // change memcpy here, revert to 4
										ENetPacket* packetsou = enet_packet_create(data,
											5 + text.length(),
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetsou);
										int gemcalc10k = b - 50;
										ofstream myfile2;
										myfile2.open("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										myfile2 << std::to_string(gemcalc10k);
										myfile2.close();
										std::ifstream ifszi("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										std::string contentx((std::istreambuf_iterator<char>(ifszi)),
											(std::istreambuf_iterator<char>()));
										int updgem = atoi(contentx.c_str());
										GamePacket pp = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), updgem));
										ENetPacket* packetpp = enet_packet_create(pp.data,
											pp.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetpp);
										delete pp.data;

										vector<int> list{ 234, 236, 238, 240, 250, 48, 68, 142, 34, 138 };
										int clothesid1 = list[rand() % list.size()];
										int clothesid2 = list[rand() % list.size()];
										int clothesid3 = list[rand() % list.size()];

										Player::OnConsoleMessage(peer, "`5Got `o1 `2" + getItemDef(clothesid1).name + " `oand 1 `2" + getItemDef(clothesid2).name + " `oand 1 `2" + getItemDef(clothesid3).name + "`o.");
										OnStorePurchaseResults(peer, "`oReceived: `o1 `2" + getItemDef(clothesid1).name + " `oand 1 `2" + getItemDef(clothesid2).name + " `oand 1 `2" + getItemDef(clothesid3).name + "`o.");

										SaveItemMoreTimes(clothesid1, 1, peer, success);
										SaveItemMoreTimes(clothesid2, 1, peer, success);
										SaveItemMoreTimes(clothesid3, 1, peer, success);

										sendSound(peer, "cash_register.wav");
									}
									else {
										OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Gems To Buy This Item. `5Try again later.");
									}
								}
								if (cch.find("action|buy\nitem|nyan_hat") == 0) {
									std::ifstream ifsz("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									std::string content((std::istreambuf_iterator<char>(ifsz)),
										(std::istreambuf_iterator<char>()));
									int b = atoi(content.c_str());
									if (b >= 25000)
									{
										bool success = true;
										string text = "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0\n";
										BYTE* data = new BYTE[5 + text.length()];
										BYTE zero = 0;
										int type = 3;
										memcpy(data, &type, 4);
										memcpy(data + 4, text.c_str(), text.length()); // change memcpy here
										memcpy(data + 4 + text.length(), &zero, 1); // change memcpy here, revert to 4
										ENetPacket* packetsou = enet_packet_create(data,
											5 + text.length(),
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetsou);
										int gemcalc10k = b - 25000;
										ofstream myfile2;
										myfile2.open("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										myfile2 << std::to_string(gemcalc10k);
										myfile2.close();
										std::ifstream ifszi("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										std::string contentx((std::istreambuf_iterator<char>(ifszi)),
											(std::istreambuf_iterator<char>()));
										int updgem = atoi(contentx.c_str());
										GamePacket pp = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), updgem));
										ENetPacket* packetpp = enet_packet_create(pp.data,
											pp.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetpp);
										delete pp.data;
										Player::OnConsoleMessage(peer, "`5Got `o1 `2Turtle Hat.");
										OnStorePurchaseResults(peer, "`oReceived: `o1 `2Turtle Hat.");

										SaveItemMoreTimes(574, 1, peer, success);

										sendSound(peer, "cash_register.wav");
									}
									else {
										OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Gems To Buy This Item. `5Try again later.");
									}
								}
								if (cch.find("action|buy\nitem|tiny_horsie") == 0) {
									std::ifstream ifsz("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									std::string content((std::istreambuf_iterator<char>(ifsz)),
										(std::istreambuf_iterator<char>()));
									int b = atoi(content.c_str());
									if (b >= 25000)
									{
										bool success = true;
										string text = "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0\n";
										BYTE* data = new BYTE[5 + text.length()];
										BYTE zero = 0;
										int type = 3;
										memcpy(data, &type, 4);
										memcpy(data + 4, text.c_str(), text.length()); // change memcpy here
										memcpy(data + 4 + text.length(), &zero, 1); // change memcpy here, revert to 4
										ENetPacket* packetsou = enet_packet_create(data,
											5 + text.length(),
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetsou);
										int gemcalc10k = b - 25000;
										ofstream myfile2;
										myfile2.open("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										myfile2 << std::to_string(gemcalc10k);
										myfile2.close();
										std::ifstream ifszi("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										std::string contentx((std::istreambuf_iterator<char>(ifszi)),
											(std::istreambuf_iterator<char>()));
										int updgem = atoi(contentx.c_str());
										GamePacket pp = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), updgem));
										ENetPacket* packetpp = enet_packet_create(pp.data,
											pp.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetpp);
										delete pp.data;
										Player::OnConsoleMessage(peer, "`5Got `o1 `2Tiny Horsie.");
										OnStorePurchaseResults(peer, "`oReceived: `o1 `2Tiny Horsie.");

										SaveItemMoreTimes(592, 1, peer, success);

										sendSound(peer, "cash_register.wav");
									}
									else {
										OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Gems To Buy This Item. `5Try again later.");
									}
								}
								if (cch.find("action|buy\nitem|dragon_hand") == 0) {
									std::ifstream ifsz("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									std::string content((std::istreambuf_iterator<char>(ifsz)),
										(std::istreambuf_iterator<char>()));
									int b = atoi(content.c_str());
									if (b >=50000)
									{
										bool success = true;
										string text = "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0\n";
										BYTE* data = new BYTE[5 + text.length()];
										BYTE zero = 0;
										int type = 3;
										memcpy(data, &type, 4);
										memcpy(data + 4, text.c_str(), text.length()); // change memcpy here
										memcpy(data + 4 + text.length(), &zero, 1); // change memcpy here, revert to 4
										ENetPacket* packetsou = enet_packet_create(data,
											5 + text.length(),
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetsou);
										int gemcalc10k = b - 50000;
										ofstream myfile2;
										myfile2.open("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										myfile2 << std::to_string(gemcalc10k);
										myfile2.close();
										std::ifstream ifszi("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										std::string contentx((std::istreambuf_iterator<char>(ifszi)),
											(std::istreambuf_iterator<char>()));
										int updgem = atoi(contentx.c_str());
										GamePacket pp = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), updgem));
										ENetPacket* packetpp = enet_packet_create(pp.data,
											pp.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetpp);
										delete pp.data;
										Player::OnConsoleMessage(peer, "`5Got `o1 `2Dragon Hand.");
										OnStorePurchaseResults(peer, "`oReceived: `o1 `2Dragon Hand.");

										SaveItemMoreTimes(900, 1, peer, success);

										sendSound(peer, "cash_register.wav");
									}
									else {
										OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Gems To Buy This Item. `5Try again later.");
									}
								}
								if (cch.find("action|buy\nitem|corvette") == 0) {
									std::ifstream ifsz("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									std::string content((std::istreambuf_iterator<char>(ifsz)),
										(std::istreambuf_iterator<char>()));
									int b = atoi(content.c_str());
									if (b >= 25000)
									{
										bool success = true;
										string text = "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0\n";
										BYTE* data = new BYTE[5 + text.length()];
										BYTE zero = 0;
										int type = 3;
										memcpy(data, &type, 4);
										memcpy(data + 4, text.c_str(), text.length()); // change memcpy here
										memcpy(data + 4 + text.length(), &zero, 1); // change memcpy here, revert to 4
										ENetPacket* packetsou = enet_packet_create(data,
											5 + text.length(),
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetsou);
										int gemcalc10k = b - 25000;
										ofstream myfile2;
										myfile2.open("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										myfile2 << std::to_string(gemcalc10k);
										myfile2.close();
										std::ifstream ifszi("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										std::string contentx((std::istreambuf_iterator<char>(ifszi)),
											(std::istreambuf_iterator<char>()));
										int updgem = atoi(contentx.c_str());
										GamePacket pp = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), updgem));
										ENetPacket* packetpp = enet_packet_create(pp.data,
											pp.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetpp);
										delete pp.data;
										Player::OnConsoleMessage(peer, "`5Got `o1 `2Little Red Corvette.");
										OnStorePurchaseResults(peer, "`oReceived: `o1 `2Little Red Corvette.");

										SaveItemMoreTimes(766, 1, peer, success);

										sendSound(peer, "cash_register.wav");
									}
									else {
										OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Gems To Buy This Item. `5Try again later.");
									}
								}
								if (cch.find("action|buy\nitem|owl") == 0) {
									std::ifstream ifsz("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									std::string content((std::istreambuf_iterator<char>(ifsz)),
										(std::istreambuf_iterator<char>()));
									int b = atoi(content.c_str());
									if (b >= 30000)
									{
										bool success = true;
										string text = "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0\n";
										BYTE* data = new BYTE[5 + text.length()];
										BYTE zero = 0;
										int type = 3;
										memcpy(data, &type, 4);
										memcpy(data + 4, text.c_str(), text.length()); // change memcpy here
										memcpy(data + 4 + text.length(), &zero, 1); // change memcpy here, revert to 4
										ENetPacket* packetsou = enet_packet_create(data,
											5 + text.length(),
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetsou);
										int gemcalc10k = b - 30000;
										ofstream myfile2;
										myfile2.open("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										myfile2 << std::to_string(gemcalc10k);
										myfile2.close();
										std::ifstream ifszi("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										std::string contentx((std::istreambuf_iterator<char>(ifszi)),
											(std::istreambuf_iterator<char>()));
										int updgem = atoi(contentx.c_str());
										GamePacket pp = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), updgem));
										ENetPacket* packetpp = enet_packet_create(pp.data,
											pp.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetpp);
										delete pp.data;
										Player::OnConsoleMessage(peer, "`5Got `o1 `2Mid-Pacific Owl.");
										OnStorePurchaseResults(peer, "`oReceived: `o1 `2Mid-Pacific Owl.");

										SaveItemMoreTimes(1540, 1, peer, success);

										sendSound(peer, "cash_register.wav");
									}
									else {
										OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Gems To Buy This Item. `5Try again later.");
									}
								}
								if (cch.find("action|buy\nitem|unicorn") == 0) {
									std::ifstream ifsz("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									std::string content((std::istreambuf_iterator<char>(ifsz)),
										(std::istreambuf_iterator<char>()));
									int b = atoi(content.c_str());
									if (b >= 50000)
									{
										bool success = true;
										string text = "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0\n";
										BYTE* data = new BYTE[5 + text.length()];
										BYTE zero = 0;
										int type = 3;
										memcpy(data, &type, 4);
										memcpy(data + 4, text.c_str(), text.length()); // change memcpy here
										memcpy(data + 4 + text.length(), &zero, 1); // change memcpy here, revert to 4
										ENetPacket* packetsou = enet_packet_create(data,
											5 + text.length(),
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetsou);
										int gemcalc10k = b - 50000;
										ofstream myfile2;
										myfile2.open("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										myfile2 << std::to_string(gemcalc10k);
										myfile2.close();
										std::ifstream ifszi("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										std::string contentx((std::istreambuf_iterator<char>(ifszi)),
											(std::istreambuf_iterator<char>()));
										int updgem = atoi(contentx.c_str());
										GamePacket pp = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), updgem));
										ENetPacket* packetpp = enet_packet_create(pp.data,
											pp.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetpp);
										delete pp.data;
										Player::OnConsoleMessage(peer, "`5Got `o1 `2Unicorn Garland.");
										OnStorePurchaseResults(peer, "`oReceived: `o1 `2Unicorn Garland.");

										SaveItemMoreTimes(1648, 1, peer, success);

										sendSound(peer, "cash_register.wav");
									}
									else {
										OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Gems To Buy This Item. `5Try again later.");
									}
								}
								if (cch.find("action|buy\nitem|starboard") == 0) {
									std::ifstream ifsz("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									std::string content((std::istreambuf_iterator<char>(ifsz)),
										(std::istreambuf_iterator<char>()));
									int b = atoi(content.c_str());
									if (b >= 30000)
									{
										bool success = true;
										string text = "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0\n";
										BYTE* data = new BYTE[5 + text.length()];
										BYTE zero = 0;
										int type = 3;
										memcpy(data, &type, 4);
										memcpy(data + 4, text.c_str(), text.length()); // change memcpy here
										memcpy(data + 4 + text.length(), &zero, 1); // change memcpy here, revert to 4
										ENetPacket* packetsou = enet_packet_create(data,
											5 + text.length(),
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetsou);
										int gemcalc10k = b - 30000;
										ofstream myfile2;
										myfile2.open("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										myfile2 << std::to_string(gemcalc10k);
										myfile2.close();
										std::ifstream ifszi("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										std::string contentx((std::istreambuf_iterator<char>(ifszi)),
											(std::istreambuf_iterator<char>()));
										int updgem = atoi(contentx.c_str());
										GamePacket pp = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), updgem));
										ENetPacket* packetpp = enet_packet_create(pp.data,
											pp.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetpp);
										delete pp.data;
										Player::OnConsoleMessage(peer, "`5Got `o1 `2StarBoard.");
										OnStorePurchaseResults(peer, "`oReceived: `o1 `2StarBoard.");

										SaveItemMoreTimes(1740, 1, peer, success);

										sendSound(peer, "cash_register.wav");
									}
									else {
										OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Gems To Buy This Item. `5Try again later.");
									}
								}
								if (cch.find("action|buy\nitem|monkey_on_back") == 0) {
									std::ifstream ifsz("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									std::string content((std::istreambuf_iterator<char>(ifsz)),
										(std::istreambuf_iterator<char>()));
									int b = atoi(content.c_str());
									if (b >= 50000)
									{
										bool success = true;
										string text = "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0\n";
										BYTE* data = new BYTE[5 + text.length()];
										BYTE zero = 0;
										int type = 3;
										memcpy(data, &type, 4);
										memcpy(data + 4, text.c_str(), text.length()); // change memcpy here
										memcpy(data + 4 + text.length(), &zero, 1); // change memcpy here, revert to 4
										ENetPacket* packetsou = enet_packet_create(data,
											5 + text.length(),
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetsou);
										int gemcalc10k = b - 50000;
										ofstream myfile2;
										myfile2.open("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										myfile2 << std::to_string(gemcalc10k);
										myfile2.close();
										std::ifstream ifszi("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										std::string contentx((std::istreambuf_iterator<char>(ifszi)),
											(std::istreambuf_iterator<char>()));
										int updgem = atoi(contentx.c_str());
										GamePacket pp = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), updgem));
										ENetPacket* packetpp = enet_packet_create(pp.data,
											pp.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetpp);
										delete pp.data;
										Player::OnConsoleMessage(peer, "`5Got `o1 `2Monkey On Your Back.");
										OnStorePurchaseResults(peer, "`oReceived: `o1 `2Monkey On Your Back.");

										SaveItemMoreTimes(2900, 1, peer, success);

										sendSound(peer, "cash_register.wav");
									}
									else {
										OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Gems To Buy This Item. `5Try again later.");
									}
								}
								if (cch.find("action|buy\nitem|red_bicycle") == 0) {
									std::ifstream ifsz("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									std::string content((std::istreambuf_iterator<char>(ifsz)),
										(std::istreambuf_iterator<char>()));
									int b = atoi(content.c_str());
									if (b >= 30000)
									{
										bool success = true;
										string text = "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0\n";
										BYTE* data = new BYTE[5 + text.length()];
										BYTE zero = 0;
										int type = 3;
										memcpy(data, &type, 4);
										memcpy(data + 4, text.c_str(), text.length()); // change memcpy here
										memcpy(data + 4 + text.length(), &zero, 1); // change memcpy here, revert to 4
										ENetPacket* packetsou = enet_packet_create(data,
											5 + text.length(),
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetsou);
										int gemcalc10k = b - 30000;
										ofstream myfile2;
										myfile2.open("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										myfile2 << std::to_string(gemcalc10k);
										myfile2.close();
										std::ifstream ifszi("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										std::string contentx((std::istreambuf_iterator<char>(ifszi)),
											(std::istreambuf_iterator<char>()));
										int updgem = atoi(contentx.c_str());
										GamePacket pp = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), updgem));
										ENetPacket* packetpp = enet_packet_create(pp.data,
											pp.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetpp);
										delete pp.data;
										Player::OnConsoleMessage(peer, "`5Got `o1 `2Red Bicyle.");
										OnStorePurchaseResults(peer, "`oReceived: `o1 `2Red Bicyle.");

										SaveItemMoreTimes(2974, 1, peer, success);

										sendSound(peer, "cash_register.wav");
									}
									else {
										OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Gems To Buy This Item. `5Try again later.");
									}
								}
								if (cch.find("action|buy\nitem|fire_truck") == 0) {
									std::ifstream ifsz("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									std::string content((std::istreambuf_iterator<char>(ifsz)),
										(std::istreambuf_iterator<char>()));
									int b = atoi(content.c_str());
									if (b >= 50000)
									{
										bool success = true;
										string text = "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0\n";
										BYTE* data = new BYTE[5 + text.length()];
										BYTE zero = 0;
										int type = 3;
										memcpy(data, &type, 4);
										memcpy(data + 4, text.c_str(), text.length()); // change memcpy here
										memcpy(data + 4 + text.length(), &zero, 1); // change memcpy here, revert to 4
										ENetPacket* packetsou = enet_packet_create(data,
											5 + text.length(),
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetsou);
										int gemcalc10k = b - 50000;
										ofstream myfile2;
										myfile2.open("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										myfile2 << std::to_string(gemcalc10k);
										myfile2.close();
										std::ifstream ifszi("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										std::string contentx((std::istreambuf_iterator<char>(ifszi)),
											(std::istreambuf_iterator<char>()));
										int updgem = atoi(contentx.c_str());
										GamePacket pp = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), updgem));
										ENetPacket* packetpp = enet_packet_create(pp.data,
											pp.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetpp);
										delete pp.data;
										Player::OnConsoleMessage(peer, "`5Got `o1 `2Fire Truck.");
										OnStorePurchaseResults(peer, "`oReceived: `o1 `2Fire Truck.");

										SaveItemMoreTimes(3068, 1, peer, success);

										sendSound(peer, "cash_register.wav");
									}
									else {
										OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Gems To Buy This Item. `5Try again later.");
									}
								}
								if (cch.find("action|buy\nitem|dabstep_shoes") == 0) {
									std::ifstream ifsz("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									std::string content((std::istreambuf_iterator<char>(ifsz)),
										(std::istreambuf_iterator<char>()));
									int b = atoi(content.c_str());
									if (b >= 30000)
									{
										bool success = true;
										string text = "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0\n";
										BYTE* data = new BYTE[5 + text.length()];
										BYTE zero = 0;
										int type = 3;
										memcpy(data, &type, 4);
										memcpy(data + 4, text.c_str(), text.length()); // change memcpy here
										memcpy(data + 4 + text.length(), &zero, 1); // change memcpy here, revert to 4
										ENetPacket* packetsou = enet_packet_create(data,
											5 + text.length(),
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetsou);
										int gemcalc10k = b - 30000;
										ofstream myfile2;
										myfile2.open("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										myfile2 << std::to_string(gemcalc10k);
										myfile2.close();
										std::ifstream ifszi("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										std::string contentx((std::istreambuf_iterator<char>(ifszi)),
											(std::istreambuf_iterator<char>()));
										int updgem = atoi(contentx.c_str());
										GamePacket pp = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), updgem));
										ENetPacket* packetpp = enet_packet_create(pp.data,
											pp.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetpp);
										delete pp.data;
										Player::OnConsoleMessage(peer, "`5Got `o1 `2Dabstep Low Top Sneakers.");
										OnStorePurchaseResults(peer, "`oReceived: `o1 `2Dabstep Low Top Sneakers.");

										SaveItemMoreTimes(6780, 1, peer, success);

										sendSound(peer, "cash_register.wav");
									}
									else {
										OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Gems To Buy This Item. `5Try again later.");
									}
								}
								if (cch.find("action|buy\nitem|pet_slime") == 0) {
									std::ifstream ifsz("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									std::string content((std::istreambuf_iterator<char>(ifsz)),
										(std::istreambuf_iterator<char>()));
									int b = atoi(content.c_str());
									if (b >= 100000)
									{
										bool success = true;
										string text = "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0\n";
										BYTE* data = new BYTE[5 + text.length()];
										BYTE zero = 0;
										int type = 3;
										memcpy(data, &type, 4);
										memcpy(data + 4, text.c_str(), text.length()); // change memcpy here
										memcpy(data + 4 + text.length(), &zero, 1); // change memcpy here, revert to 4
										ENetPacket* packetsou = enet_packet_create(data,
											5 + text.length(),
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetsou);
										int gemcalc10k = b - 100000;
										ofstream myfile2;
										myfile2.open("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										myfile2 << std::to_string(gemcalc10k);
										myfile2.close();
										std::ifstream ifszi("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										std::string contentx((std::istreambuf_iterator<char>(ifszi)),
											(std::istreambuf_iterator<char>()));
										int updgem = atoi(contentx.c_str());
										GamePacket pp = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), updgem));
										ENetPacket* packetpp = enet_packet_create(pp.data,
											pp.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetpp);
										delete pp.data;
										Player::OnConsoleMessage(peer, "`5Got `o1 `2Pet Slime.");
										OnStorePurchaseResults(peer, "`oReceived: `o1 `2Pet Slime.");

										SaveItemMoreTimes(3166, 1, peer, success);

										sendSound(peer, "cash_register.wav");
									}
									else {
										OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Gems To Buy This Item. `5Try again later.");
									}
								}
								if (cch.find("action|buy\nitem|carrot_sword") == 0) {
									std::ifstream ifsz("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									std::string content((std::istreambuf_iterator<char>(ifsz)),
										(std::istreambuf_iterator<char>()));
									int b = atoi(content.c_str());
									if (b >= 15000)
									{
										bool success = true;
										string text = "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0\n";
										BYTE* data = new BYTE[5 + text.length()];
										BYTE zero = 0;
										int type = 3;
										memcpy(data, &type, 4);
										memcpy(data + 4, text.c_str(), text.length()); // change memcpy here
										memcpy(data + 4 + text.length(), &zero, 1); // change memcpy here, revert to 4
										ENetPacket* packetsou = enet_packet_create(data,
											5 + text.length(),
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetsou);
										int gemcalc10k = b - 15000;
										ofstream myfile2;
										myfile2.open("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										myfile2 << std::to_string(gemcalc10k);
										myfile2.close();
										std::ifstream ifszi("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										std::string contentx((std::istreambuf_iterator<char>(ifszi)),
											(std::istreambuf_iterator<char>()));
										int updgem = atoi(contentx.c_str());
										GamePacket pp = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), updgem));
										ENetPacket* packetpp = enet_packet_create(pp.data,
											pp.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetpp);
										delete pp.data;
										Player::OnConsoleMessage(peer, "`5Got `o1 `2Carrot Sword.");
										OnStorePurchaseResults(peer, "`oReceived: `o1 `2Carrot Sword.");

										SaveItemMoreTimes(2908, 1, peer, success);

										sendSound(peer, "cash_register.wav");
									}
									else {
										OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Gems To Buy This Item. `5Try again later.");
									}
								}
								if (cch.find("action|buy\nitem|motorcycle") == 0) {
									std::ifstream ifsz("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									std::string content((std::istreambuf_iterator<char>(ifsz)),
										(std::istreambuf_iterator<char>()));
									int b = atoi(content.c_str());
									if (b >= 50000)
									{
										bool success = true;
										string text = "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0\n";
										BYTE* data = new BYTE[5 + text.length()];
										BYTE zero = 0;
										int type = 3;
										memcpy(data, &type, 4);
										memcpy(data + 4, text.c_str(), text.length()); // change memcpy here
										memcpy(data + 4 + text.length(), &zero, 1); // change memcpy here, revert to 4
										ENetPacket* packetsou = enet_packet_create(data,
											5 + text.length(),
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetsou);
										int gemcalc10k = b - 50000;
										ofstream myfile2;
										myfile2.open("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										myfile2 << std::to_string(gemcalc10k);
										myfile2.close();
										std::ifstream ifszi("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										std::string contentx((std::istreambuf_iterator<char>(ifszi)),
											(std::istreambuf_iterator<char>()));
										int updgem = atoi(contentx.c_str());
										GamePacket pp = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), updgem));
										ENetPacket* packetpp = enet_packet_create(pp.data,
											pp.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetpp);
										delete pp.data;
										Player::OnConsoleMessage(peer, "`5Got `o1 `2Growley Motorcycle.");
										OnStorePurchaseResults(peer, "`oReceived: `o1 `2Growley Motorcycle.");

										SaveItemMoreTimes(1950, 1, peer, success);

										sendSound(peer, "cash_register.wav");
									}
									else {
										OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Gems To Buy This Item. `5Try again later.");
									}
								}
								if (cch.find("action|buy\nitem|stick_horse") == 0) {
									std::ifstream ifsz("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									std::string content((std::istreambuf_iterator<char>(ifsz)),
										(std::istreambuf_iterator<char>()));
									int b = atoi(content.c_str());
									if (b >= 25000)
									{
										bool success = true;
										string text = "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0\n";
										BYTE* data = new BYTE[5 + text.length()];
										BYTE zero = 0;
										int type = 3;
										memcpy(data, &type, 4);
										memcpy(data + 4, text.c_str(), text.length()); // change memcpy here
										memcpy(data + 4 + text.length(), &zero, 1); // change memcpy here, revert to 4
										ENetPacket* packetsou = enet_packet_create(data,
											5 + text.length(),
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetsou);
										int gemcalc10k = b - 25000;
										ofstream myfile2;
										myfile2.open("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										myfile2 << std::to_string(gemcalc10k);
										myfile2.close();
										std::ifstream ifszi("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										std::string contentx((std::istreambuf_iterator<char>(ifszi)),
											(std::istreambuf_iterator<char>()));
										int updgem = atoi(contentx.c_str());
										GamePacket pp = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), updgem));
										ENetPacket* packetpp = enet_packet_create(pp.data,
											pp.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetpp);
										delete pp.data;
										Player::OnConsoleMessage(peer, "`5Got `o1 `2Stick Horse.");
										OnStorePurchaseResults(peer, "`oReceived: `o1 `2Stick Horse.");

										SaveItemMoreTimes(1012, 1, peer, success);

										sendSound(peer, "cash_register.wav");
									}
									else {
										OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Gems To Buy This Item. `5Try again later.");
									}
								}
								if (cch.find("action|buy\nitem|transmutation_device") == 0) {
									std::ifstream ifsz("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									std::string content((std::istreambuf_iterator<char>(ifsz)),
										(std::istreambuf_iterator<char>()));
									int b = atoi(content.c_str());
									if (b >= 25000)
									{
										bool success = true;
										string text = "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0\n";
										BYTE* data = new BYTE[5 + text.length()];
										BYTE zero = 0;
										int type = 3;
										memcpy(data, &type, 4);
										memcpy(data + 4, text.c_str(), text.length()); // change memcpy here
										memcpy(data + 4 + text.length(), &zero, 1); // change memcpy here, revert to 4
										ENetPacket* packetsou = enet_packet_create(data,
											5 + text.length(),
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetsou);
										int gemcalc10k = b - 25000;
										ofstream myfile2;
										myfile2.open("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										myfile2 << std::to_string(gemcalc10k);
										myfile2.close();
										std::ifstream ifszi("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										std::string contentx((std::istreambuf_iterator<char>(ifszi)),
											(std::istreambuf_iterator<char>()));
										int updgem = atoi(contentx.c_str());
										GamePacket pp = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), updgem));
										ENetPacket* packetpp = enet_packet_create(pp.data,
											pp.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetpp);
										delete pp.data;
										Player::OnConsoleMessage(peer, "`5Got `o1 `2Transmutabooth.");
										OnStorePurchaseResults(peer, "`oReceived: `o1 `2Transmutabooth.");

										SaveItemMoreTimes(9170, 1, peer, success);

										sendSound(peer, "cash_register.wav");
									}
									else {
										OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Gems To Buy This Item. `5Try again later.");
									}
								}
								if (cch.find("action|buy\nitem|surgical_kit") == 0) {
									std::ifstream ifsz("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									std::string content((std::istreambuf_iterator<char>(ifsz)),
										(std::istreambuf_iterator<char>()));
									int b = atoi(content.c_str());
									if (b >= 12000)
									{
										bool success = true;
										string text = "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0\n";
										BYTE* data = new BYTE[5 + text.length()];
										BYTE zero = 0;
										int type = 3;
										memcpy(data, &type, 4);
										memcpy(data + 4, text.c_str(), text.length()); // change memcpy here
										memcpy(data + 4 + text.length(), &zero, 1); // change memcpy here, revert to 4
										ENetPacket* packetsou = enet_packet_create(data,
											5 + text.length(),
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetsou);
										int gemcalc10k = b - 12000;
										ofstream myfile2;
										myfile2.open("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										myfile2 << std::to_string(gemcalc10k);
										myfile2.close();
										std::ifstream ifszi("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										std::string contentx((std::istreambuf_iterator<char>(ifszi)),
											(std::istreambuf_iterator<char>()));
										int updgem = atoi(contentx.c_str());
										GamePacket pp = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), updgem));
										ENetPacket* packetpp = enet_packet_create(pp.data,
											pp.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetpp);
										delete pp.data;

										vector<int> list{ 1262, 1264, 1266, 1268, 1270, 1260, 1258,  };
										int surgkit1 = list[rand() % list.size()];
										int surgkit2 = list[rand() % list.size()];
										int surgkit3 = list[rand() % list.size()];
										int surgkit4 = list[rand() % list.size()];
										int surgkit5 = list[rand() % list.size()];

										Player::OnConsoleMessage(peer, "`5Got `o1 `2Heart Monitor, 1 Hospital Bed, 1 Train-E Bot, 1 " + getItemDef(surgkit1).name + ",1 " + getItemDef(surgkit2).name + ",1 " + getItemDef(surgkit3).name + ",1 " + getItemDef(surgkit4).name + ",1 " + getItemDef(surgkit5).name + ", 10 Medical Checks.");
										OnStorePurchaseResults(peer, "`oReceived: `o1 `2Heart Monitor, 1 Hospital Bed, 1 Train-E Bot, 1 " + getItemDef(surgkit1).name + ",1 " + getItemDef(surgkit2).name + ",1 " + getItemDef(surgkit3).name + ",1 " + getItemDef(surgkit4).name + ",1 " + getItemDef(surgkit5).name + ", 10 Medical Checks.");

										SaveItemMoreTimes(1240, 1, peer, success);
										SaveItemMoreTimes(1256, 1, peer, success);
										SaveItemMoreTimes(8558, 1, peer, success);
										SaveItemMoreTimes(8500, 10, peer, success);
										SaveItemMoreTimes(surgkit1, 12, peer, success);
										SaveItemMoreTimes(surgkit2, 11, peer, success);
										SaveItemMoreTimes(surgkit3, 16, peer, success);
										SaveItemMoreTimes(surgkit4, 15, peer, success);
										SaveItemMoreTimes(surgkit5, 14, peer, success);

										sendSound(peer, "cash_register.wav");
									}
									else {
										OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Gems To Buy This Item. `5Try again later.");
									}
								}
								if (cch.find("action|buy\nitem|rare_clothes") == 0) {
									std::ifstream ifsz("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									std::string content((std::istreambuf_iterator<char>(ifsz)),
										(std::istreambuf_iterator<char>()));
									int b = atoi(content.c_str());
									if (b >= 500)
									{
										bool success = true;
										string text = "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0\n";
										BYTE* data = new BYTE[5 + text.length()];
										BYTE zero = 0;
										int type = 3;
										memcpy(data, &type, 4);
										memcpy(data + 4, text.c_str(), text.length()); // change memcpy here
										memcpy(data + 4 + text.length(), &zero, 1); // change memcpy here, revert to 4
										ENetPacket* packetsou = enet_packet_create(data,
											5 + text.length(),
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetsou);
										int gemcalc10k = b - 500;
										ofstream myfile2;
										myfile2.open("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										myfile2 << std::to_string(gemcalc10k);
										myfile2.close();
										std::ifstream ifszi("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										std::string contentx((std::istreambuf_iterator<char>(ifszi)),
											(std::istreambuf_iterator<char>()));
										int updgem = atoi(contentx.c_str());
										GamePacket pp = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), updgem));
										ENetPacket* packetpp = enet_packet_create(pp.data,
											pp.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetpp);
										delete pp.data;

										vector<int> list{ 156, 818, 594, 150, 212 };
										int clothesid1 = list[rand() % list.size()];
										int clothesid2 = list[rand() % list.size()];
										int clothesid3 = list[rand() % list.size()];

										Player::OnConsoleMessage(peer, "`5Got `o1 `2" + getItemDef(clothesid1).name + " `oand 1 `2" + getItemDef(clothesid2).name + " `oand 1 `2" + getItemDef(clothesid3).name + "`o.");
										OnStorePurchaseResults(peer, "`oReceived: `o1 `2" + getItemDef(clothesid1).name + " `oand 1 `2" + getItemDef(clothesid2).name + " `oand 1 `2" + getItemDef(clothesid3).name + "`o.");

										SaveItemMoreTimes(clothesid1, 1, peer, success);
										SaveItemMoreTimes(clothesid2, 1, peer, success);
										SaveItemMoreTimes(clothesid3, 1, peer, success);

										sendSound(peer, "cash_register.wav");
									}
									else {
										OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Gems To Buy This Item. `5Try again later.");
									}
								}
								if (cch.find("action|buy\nitem|punch_jammer") == 0) {
									std::ifstream ifsz("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									std::string content((std::istreambuf_iterator<char>(ifsz)),
										(std::istreambuf_iterator<char>()));
									int b = atoi(content.c_str());
									if (b >= 15000)
									{
										bool success = true;
										string text = "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0\n";
										BYTE* data = new BYTE[5 + text.length()];
										BYTE zero = 0;
										int type = 3;
										memcpy(data, &type, 4);
										memcpy(data + 4, text.c_str(), text.length()); // change memcpy here
										memcpy(data + 4 + text.length(), &zero, 1); // change memcpy here, revert to 4
										ENetPacket* packetsou = enet_packet_create(data,
											5 + text.length(),
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetsou);
										int gemcalc10k = b - 15000;
										ofstream myfile2;
										myfile2.open("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										myfile2 << std::to_string(gemcalc10k);
										myfile2.close();
										std::ifstream ifszi("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										std::string contentx((std::istreambuf_iterator<char>(ifszi)),
											(std::istreambuf_iterator<char>()));
										int updgem = atoi(contentx.c_str());
										GamePacket pp = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), updgem));
										ENetPacket* packetpp = enet_packet_create(pp.data,
											pp.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetpp);
										delete pp.data;
										Player::OnConsoleMessage(peer, "`5Got `o1 `2Punch Jammer");
										OnStorePurchaseResults(peer, "`oReceived: `o1 Punch Jammer.");

										SaveItemMoreTimes(1276, 1, peer, success);

										sendSound(peer, "cash_register.wav");
									}
									else {
										OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Gems To Buy This Item. `5Try again later.");
									}
								}
								if (cch.find("action|buy\nitem|zombie_jammer") == 0) {
									std::ifstream ifsz("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									std::string content((std::istreambuf_iterator<char>(ifsz)),
										(std::istreambuf_iterator<char>()));
									int b = atoi(content.c_str());
									if (b >= 15000)
									{
										bool success = true;
										string text = "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0\n";
										BYTE* data = new BYTE[5 + text.length()];
										BYTE zero = 0;
										int type = 3;
										memcpy(data, &type, 4);
										memcpy(data + 4, text.c_str(), text.length()); // change memcpy here
										memcpy(data + 4 + text.length(), &zero, 1); // change memcpy here, revert to 4
										ENetPacket* packetsou = enet_packet_create(data,
											5 + text.length(),
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetsou);
										int gemcalc10k = b - 15000;
										ofstream myfile2;
										myfile2.open("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										myfile2 << std::to_string(gemcalc10k);
										myfile2.close();
										std::ifstream ifszi("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										std::string contentx((std::istreambuf_iterator<char>(ifszi)),
											(std::istreambuf_iterator<char>()));
										int updgem = atoi(contentx.c_str());
										GamePacket pp = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), updgem));
										ENetPacket* packetpp = enet_packet_create(pp.data,
											pp.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetpp);
										delete pp.data;
										Player::OnConsoleMessage(peer, "`5Got `o1 `2Zombie Jammer");
										OnStorePurchaseResults(peer, "`oReceived: `o1 Zombie Jammer.");

										SaveItemMoreTimes(1278, 1, peer, success);

										sendSound(peer, "cash_register.wav");
									}
									else {
										OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Gems To Buy This Item. `5Try again later.");
									}
								}
								if (cch.find("action|buy\nitem|atomi_shadow_scythe") == 0) {
									/*Fast Item Setup*/
									auto Price = 10;
									auto ItemID = 1484;
									auto count = 1;
									auto contains = false;
									auto KiekTuri = 0;
									for (auto i = 0; i < static_cast<PlayerInfo*>(peer->data)->inventory.items.size(); i++) {
										if (static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemID == 1486 && static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount >= 1) {
											KiekTuri = static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount;
										}
									}
									SearchInventoryItem(peer, 1486, Price, contains);
									if (contains) {
										if (CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && !CheckItemExists(peer, ItemID)) {
											Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
											GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
											ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(peer, 0, packet);
											delete p.data;
											continue;
										}
										RemoveInventoryItem(1486, Price, peer, true);
										bool success = true;
										SaveItemMoreTimes(ItemID, count, peer, success);
										Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
										GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased " + to_string(count) + " `o" + getItemDef(ItemID).name + " `wfor `$" + to_string(Price) + " `wGrowtokens.\nYou have `$" + to_string(KiekTuri - Price) + " `wGrowtokens left.\n\n`5Received: ``" + to_string(count) + " " + getItemDef(ItemID).name + ""));
										ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);
										delete p.data;
									}
									else {
										Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
										GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + getItemDef(ItemID).name + "``!  You're `$" + to_string(Price - KiekTuri) + "`` Growtokens short."));
										ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);
										delete p.data;
									}
								}

								if (cch.find("action|buy\nitem|evil_space_helmet") == 0) {
									/*Fast Item Setup*/
									auto Price = 5;
									auto ItemID = 1440;
									auto count = 1;
									auto contains = false;
									auto KiekTuri = 0;
									for (auto i = 0; i < static_cast<PlayerInfo*>(peer->data)->inventory.items.size(); i++) {
										if (static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemID == 1486 && static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount >= 1) {
											KiekTuri = static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount;
										}
									}
									SearchInventoryItem(peer, 1486, Price, contains);
									if (contains) {
										if (CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && !CheckItemExists(peer, ItemID)) {
											Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
											GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
											ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(peer, 0, packet);
											delete p.data;
											continue;
										}
										RemoveInventoryItem(1486, Price, peer, true);
										bool success = true;
										SaveItemMoreTimes(ItemID, count, peer, success);
										Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
										GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased " + to_string(count) + " `o" + getItemDef(ItemID).name + " `wfor `$" + to_string(Price) + " `wGrowtokens.\nYou have `$" + to_string(KiekTuri - Price) + " `wGrowtokens left.\n\n`5Received: ``" + to_string(count) + " " + getItemDef(ItemID).name + ""));
										ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);
										delete p.data;
									}
									else {
										Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
										GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + getItemDef(ItemID).name + "``!  You're `$" + to_string(Price - KiekTuri) + "`` Growtokens short."));
										ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);
										delete p.data;
									}
								}

								if (cch.find("action|buy\nitem|frosty_hair") == 0) {
									/*Fast Item Setup*/
									auto Price = 10;
									auto ItemID = 1444;
									auto count = 1;
									auto contains = false;
									auto KiekTuri = 0;
									for (auto i = 0; i < static_cast<PlayerInfo*>(peer->data)->inventory.items.size(); i++) {
										if (static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemID == 1486 && static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount >= 1) {
											KiekTuri = static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount;
										}
									}
									SearchInventoryItem(peer, 1486, Price, contains);
									if (contains) {
										if (CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && !CheckItemExists(peer, ItemID)) {
											Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
											GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
											ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(peer, 0, packet);
											delete p.data;
											continue;
										}
										RemoveInventoryItem(1486, Price, peer, true);
										bool success = true;
										SaveItemMoreTimes(ItemID, count, peer, success);
										Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
										GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased " + to_string(count) + " `o" + getItemDef(ItemID).name + " `wfor `$" + to_string(Price) + " `wGrowtokens.\nYou have `$" + to_string(KiekTuri - Price) + " `wGrowtokens left.\n\n`5Received: ``" + to_string(count) + " " + getItemDef(ItemID).name + ""));
										ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);
										delete p.data;
									}
									else {
										Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
										GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + getItemDef(ItemID).name + "``!  You're `$" + to_string(Price - KiekTuri) + "`` Growtokens short."));
										ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);
										delete p.data;
									}
								}

								if (cch.find("action|buy\nitem|meow_ears") == 0) {
									/*Fast Item Setup*/
									auto Price = 5;
									auto ItemID = 698;
									auto count = 1;
									auto contains = false;
									auto KiekTuri = 0;
									for (auto i = 0; i < static_cast<PlayerInfo*>(peer->data)->inventory.items.size(); i++) {
										if (static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemID == 1486 && static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount >= 1) {
											KiekTuri = static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount;
										}
									}
									SearchInventoryItem(peer, 1486, Price, contains);
									if (contains) {
										if (CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && !CheckItemExists(peer, ItemID)) {
											Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
											GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
											ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(peer, 0, packet);
											delete p.data;
											continue;
										}
										RemoveInventoryItem(1486, Price, peer, true);
										bool success = true;
										SaveItemMoreTimes(ItemID, count, peer, success);
										Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
										GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased " + to_string(count) + " `o" + getItemDef(ItemID).name + " `wfor `$" + to_string(Price) + " `wGrowtokens.\nYou have `$" + to_string(KiekTuri - Price) + " `wGrowtokens left.\n\n`5Received: ``" + to_string(count) + " " + getItemDef(ItemID).name + ""));
										ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);
										delete p.data;
									}
									else {
										Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
										GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + getItemDef(ItemID).name + "``!  You're `$" + to_string(Price - KiekTuri) + "`` Growtokens short."));
										ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);
										delete p.data;
									}
								}

								if (cch.find("action|buy\nitem|puppy_leash") == 0) {
									/*Fast Item Setup*/
									auto Price = 5;
									auto ItemID = 1742;
									auto count = 1;
									auto contains = false;
									auto KiekTuri = 0;
									for (auto i = 0; i < static_cast<PlayerInfo*>(peer->data)->inventory.items.size(); i++) {
										if (static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemID == 1486 && static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount >= 1) {
											KiekTuri = static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount;
										}
									}
									SearchInventoryItem(peer, 1486, Price, contains);
									if (contains) {
										if (CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && !CheckItemExists(peer, ItemID)) {
											Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
											GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
											ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(peer, 0, packet);
											delete p.data;
											continue;
										}
										RemoveInventoryItem(1486, Price, peer, true);
										bool success = true;
										SaveItemMoreTimes(ItemID, count, peer, success);
										Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
										GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased " + to_string(count) + " `o" + getItemDef(ItemID).name + " `wfor `$" + to_string(Price) + " `wGrowtokens.\nYou have `$" + to_string(KiekTuri - Price) + " `wGrowtokens left.\n\n`5Received: ``" + to_string(count) + " " + getItemDef(ItemID).name + ""));
										ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);
										delete p.data;
									}
									else {
										Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
										GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + getItemDef(ItemID).name + "``!  You're `$" + to_string(Price - KiekTuri) + "`` Growtokens short."));
										ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);
										delete p.data;
									}
								}

								if (cch.find("action|buy\nitem|science_pack") == 0) {
									ifstream ifsz("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									string content((std::istreambuf_iterator<char>(ifsz)), (std::istreambuf_iterator<char>()));
									auto gembux = atoi(content.c_str());
									if (gembux >= 5000) {
										if (CheckItemMaxed(peer, 916, 5) || CheckItemMaxed(peer, 914, 10) || CheckItemMaxed(peer, 924, 5) || CheckItemMaxed(peer, 920, 5) || CheckItemMaxed(peer, 918, 5) || CheckItemMaxed(peer, 930, 1) || CheckItemMaxed(peer, 928, 1) || CheckItemMaxed(peer, 912, 1) || CheckItemMaxed(peer, 772, 1) || CheckItemMaxed(peer, 770, 1) || CheckItemMaxed(peer, 904, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 11 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize) {
											Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
											GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
											ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(peer, 0, packet);
											delete p.data;
											continue;
										}
										gembux -= 5000;
										ofstream myfile;
										myfile.open("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										myfile << gembux;
										myfile.close();
										Player::OnSetBux(peer, gembux, 0);
										bool success = true;
										SaveItemMoreTimes(930, 1, peer, success);
										SaveItemMoreTimes(928, 1, peer, success);
										SaveItemMoreTimes(912, 1, peer, success);
										SaveItemMoreTimes(772, 1, peer, success);
										SaveItemMoreTimes(770, 1, peer, success);
										SaveItemMoreTimes(904, 1, peer, success);
										SaveItemMoreTimes(916, 5, peer, success);
										SaveItemMoreTimes(914, 10, peer, success);
										SaveItemMoreTimes(924, 5, peer, success);
										SaveItemMoreTimes(920, 5, peer, success);
										SaveItemMoreTimes(918, 5, peer, success);
										Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
										GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `oMad Science Kit `wfor `$" + to_string(5000) + " `wGems.\nYou have `$" + to_string(gembux) + " `wGems left.\n\n`5Received:`` Death Ray`&,`` Science Station`$,`` Laboratory`$,`` LabCoat`$,`` Combover Hair`$,`` Goggles`$,`` 5 Chemical R`$,`` 10 Chemical G`$,`` 5 Chemical Y`$,`` 5 Chemical B`$,`` 5 Chemical P\n"));
										ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);
										delete p.data;
									}
									else {
										Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
										GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `oMad Science Kit``!  You're `$" + to_string(5000 - gembux) + "`` Gems short."));
										ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);
										delete p.data;
									}
								}
								if (cch.find("action|buy\nitem|golden_axe") == 0) {
									/*Fast Item Setup*/
									auto Price = 200;
									auto ItemID = 1438;
									auto count = 1;
									auto contains = false;
									auto KiekTuri = 0;
									for (auto i = 0; i < static_cast<PlayerInfo*>(peer->data)->inventory.items.size(); i++) {
										if (static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemID == 1486 && static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount >= 1) {
											KiekTuri = static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount;
										}
									}
									SearchInventoryItem(peer, 1486, Price, contains);
									if (contains) {
										if (CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && !CheckItemExists(peer, ItemID)) {
											Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
											GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
											ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(peer, 0, packet);
											delete p.data;
											continue;
										}
										RemoveInventoryItem(1486, Price, peer, true);
										bool success = true;
										SaveItemMoreTimes(ItemID, count, peer, success);
										Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
										GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased " + to_string(count) + " `o" + getItemDef(ItemID).name + " `wfor `$" + to_string(Price) + " `wGrowtokens.\nYou have `$" + to_string(KiekTuri - Price) + " `wGrowtokens left.\n\n`5Received: ``" + to_string(count) + " " + getItemDef(ItemID).name + ""));
										ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);
										delete p.data;
									}
									else {
										Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
										GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + getItemDef(ItemID).name + "``!  You're `$" + to_string(Price - KiekTuri) + "`` Growtokens short."));
										ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);
										delete p.data;
									}
								}

								if (cch.find("action|buy\nitem|cat_eyes") == 0) {
									/*Fast Item Setup*/
									auto Price = 1;
									auto ItemID = 7106;
									auto count = 1;
									auto contains = false;
									auto KiekTuri = 0;
									for (auto i = 0; i < static_cast<PlayerInfo*>(peer->data)->inventory.items.size(); i++) {
										if (static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemID == 1486 && static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount >= 1) {
											KiekTuri = static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount;
										}
									}
									SearchInventoryItem(peer, 1486, Price, contains);
									if (contains) {
										if (CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && !CheckItemExists(peer, ItemID)) {
											Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
											GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
											ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(peer, 0, packet);
											delete p.data;
											continue;
										}
										RemoveInventoryItem(1486, Price, peer, true);
										bool success = true;
										SaveItemMoreTimes(ItemID, count, peer, success);
										Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
										GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased " + to_string(count) + " `o" + getItemDef(ItemID).name + " `wfor `$" + to_string(Price) + " `wGrowtokens.\nYou have `$" + to_string(KiekTuri - Price) + " `wGrowtokens left.\n\n`5Received: ``" + to_string(count) + " " + getItemDef(ItemID).name + ""));
										ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);
										delete p.data;
									}
									else {
										Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
										GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + getItemDef(ItemID).name + "``!  You're `$" + to_string(Price - KiekTuri) + "`` Growtokens short."));
										ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);
										delete p.data;
									}
								}
								if (cch.find("action|buy\nitem|surgery_pack") == 0) {
									ifstream ifsz("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									string content((std::istreambuf_iterator<char>(ifsz)), (std::istreambuf_iterator<char>()));
									auto gembux = atoi(content.c_str());
									if (gembux >= 5000) {
										if (CheckItemMaxed(peer, 916, 5) || CheckItemMaxed(peer, 914, 10) || CheckItemMaxed(peer, 924, 5) || CheckItemMaxed(peer, 920, 5) || CheckItemMaxed(peer, 918, 5) || CheckItemMaxed(peer, 930, 1) || CheckItemMaxed(peer, 928, 1) || CheckItemMaxed(peer, 912, 1) || CheckItemMaxed(peer, 772, 1) || CheckItemMaxed(peer, 770, 1) || CheckItemMaxed(peer, 904, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 11 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize) {
											Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
											GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
											ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(peer, 0, packet);
											delete p.data;
											continue;
										}
										gembux -= 5000;
										ofstream myfile;
										myfile.open("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										myfile << gembux;
										myfile.close();
										Player::OnSetBux(peer, gembux, 0);
										bool success = true;
										SaveItemMoreTimes(1258, 5, peer, success);
										SaveItemMoreTimes(1260, 5, peer, success);
										SaveItemMoreTimes(1262, 5, peer, success);
										SaveItemMoreTimes(1264, 5, peer, success);
										SaveItemMoreTimes(1266, 5, peer, success);
										SaveItemMoreTimes(1268, 5, peer, success);
										SaveItemMoreTimes(1270, 5, peer, success);
										SaveItemMoreTimes(8500, 10, peer, success);
										SaveItemMoreTimes(4308, 5, peer, success);
										SaveItemMoreTimes(4310, 5, peer, success);
										SaveItemMoreTimes(4312, 5, peer, success);
										SaveItemMoreTimes(4314, 5, peer, success);
										SaveItemMoreTimes(4316, 5, peer, success);
										SaveItemMoreTimes(4318, 5, peer, success);
										SaveItemMoreTimes(1296, 5, peer, success);
										Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
										GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `oMad Science Kit `wfor `$" + to_string(5000) + " `wGems.\nYou have `$" + to_string(gembux) + " `wGems left.\n\n`5Received:`` Death Ray`&,`` Science Station`$,`` Laboratory`$,`` LabCoat`$,`` Combover Hair`$,`` Goggles`$,`` 5 Chemical R`$,`` 10 Chemical G`$,`` 5 Chemical Y`$,`` 5 Chemical B`$,`` 5 Chemical P\n"));
										ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);
										delete p.data;
									}
									else {
										Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
										GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `oMad Science Kit``!  You're `$" + to_string(5000 - gembux) + "`` Gems short."));
										ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);
										delete p.data;
									}
								}
								if (cch.find("action|buy\nitem|focused_eyes") == 0) {
									/*Fast Item Setup*/
									auto Price = 100;
									auto ItemID = 1204;
									auto count = 1;
									auto contains = false;
									auto KiekTuri = 0;
									for (auto i = 0; i < static_cast<PlayerInfo*>(peer->data)->inventory.items.size(); i++) {
										if (static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemID == 1486 && static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount >= 1) {
											KiekTuri = static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount;
										}
									}
									SearchInventoryItem(peer, 1486, Price, contains);
									if (contains) {
										if (CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && !CheckItemExists(peer, ItemID)) {
											Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
											GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
											ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(peer, 0, packet);
											delete p.data;
											continue;
										}
										RemoveInventoryItem(1486, Price, peer, true);
										bool success = true;
										SaveItemMoreTimes(ItemID, count, peer, success);
										Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
										GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased " + to_string(count) + " `o" + getItemDef(ItemID).name + " `wfor `$" + to_string(Price) + " `wGrowtokens.\nYou have `$" + to_string(KiekTuri - Price) + " `wGrowtokens left.\n\n`5Received: ``" + to_string(count) + " " + getItemDef(ItemID).name + ""));
										ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);
										delete p.data;
									}
									else {
										Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
										GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + getItemDef(ItemID).name + "``!  You're `$" + to_string(Price - KiekTuri) + "`` Growtokens short."));
										ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);
										delete p.data;
									}
								}

								if (cch.find("action|buy\nitem|focused_eyes") == 0) {
									/*Fast Item Setup*/
									auto Price = 10;
									auto ItemID = 2480;
									auto count = 1;
									auto contains = false;
									auto KiekTuri = 0;
									for (auto i = 0; i < static_cast<PlayerInfo*>(peer->data)->inventory.items.size(); i++) {
										if (static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemID == 1486 && static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount >= 1) {
											KiekTuri = static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount;
										}
									}
									SearchInventoryItem(peer, 1486, Price, contains);
									if (contains) {
										if (CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && !CheckItemExists(peer, ItemID)) {
											Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
											GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
											ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(peer, 0, packet);
											delete p.data;
											continue;
										}
										RemoveInventoryItem(1486, Price, peer, true);
										bool success = true;
										SaveItemMoreTimes(ItemID, count, peer, success);
										Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
										GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased " + to_string(count) + " `o" + getItemDef(ItemID).name + " `wfor `$" + to_string(Price) + " `wGrowtokens.\nYou have `$" + to_string(KiekTuri - Price) + " `wGrowtokens left.\n\n`5Received: ``" + to_string(count) + " " + getItemDef(ItemID).name + ""));
										ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);
										delete p.data;
									}
									else {
										Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
										GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + getItemDef(ItemID).name + "``!  You're `$" + to_string(Price - KiekTuri) + "`` Growtokens short."));
										ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);
										delete p.data;
									}
								}

								if (cch.find("action|buy\nitem|crystal_cape") == 0) {
									/*Fast Item Setup*/
									auto Price = 90;
									auto ItemID = 1738;
									auto count = 1;
									auto contains = false;
									auto KiekTuri = 0;
									for (auto i = 0; i < static_cast<PlayerInfo*>(peer->data)->inventory.items.size(); i++) {
										if (static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemID == 1486 && static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount >= 1) {
											KiekTuri = static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount;
										}
									}
									SearchInventoryItem(peer, 1486, Price, contains);
									if (contains) {
										if (CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && !CheckItemExists(peer, ItemID)) {
											Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
											GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
											ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(peer, 0, packet);
											delete p.data;
											continue;
										}
										RemoveInventoryItem(1486, Price, peer, true);
										bool success = true;
										SaveItemMoreTimes(ItemID, count, peer, success);
										Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
										GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased " + to_string(count) + " `o" + getItemDef(ItemID).name + " `wfor `$" + to_string(Price) + " `wGrowtokens.\nYou have `$" + to_string(KiekTuri - Price) + " `wGrowtokens left.\n\n`5Received: ``" + to_string(count) + " " + getItemDef(ItemID).name + ""));
										ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);
										delete p.data;
									}
									else {
										Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
										GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + getItemDef(ItemID).name + "``!  You're `$" + to_string(Price - KiekTuri) + "`` Growtokens short."));
										ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);
										delete p.data;
									}
								}

								if (cch.find("action|buy\nitem|diggers_spade") == 0) {
									/*Fast Item Setup*/
									auto Price = 200;
									auto ItemID = 2952;
									auto count = 1;
									auto contains = false;
									auto KiekTuri = 0;
									for (auto i = 0; i < static_cast<PlayerInfo*>(peer->data)->inventory.items.size(); i++) {
										if (static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemID == 1486 && static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount >= 1) {
											KiekTuri = static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount;
										}
									}
									SearchInventoryItem(peer, 1486, Price, contains);
									if (contains) {
										if (CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && !CheckItemExists(peer, ItemID)) {
											Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
											GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
											ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(peer, 0, packet);
											delete p.data;
											continue;
										}
										RemoveInventoryItem(1486, Price, peer, true);
										bool success = true;
										SaveItemMoreTimes(ItemID, count, peer, success);
										Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
										GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased " + to_string(count) + " `o" + getItemDef(ItemID).name + " `wfor `$" + to_string(Price) + " `wGrowtokens.\nYou have `$" + to_string(KiekTuri - Price) + " `wGrowtokens left.\n\n`5Received: ``" + to_string(count) + " " + getItemDef(ItemID).name + ""));
										ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);
										delete p.data;
									}
									else {
										Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
										GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + getItemDef(ItemID).name + "``!  You're `$" + to_string(Price - KiekTuri) + "`` Growtokens short."));
										ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);
										delete p.data;
									}
								}

								if (cch.find("action|buy\nitem|dmover") == 0) {
									std::ifstream ifsz("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									std::string content((std::istreambuf_iterator<char>(ifsz)),
										(std::istreambuf_iterator<char>()));
									int b = atoi(content.c_str());
									if (b >= 5000)
									{
										bool success = true;
										string text = "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0\n";
										BYTE* data = new BYTE[5 + text.length()];
										BYTE zero = 0;
										int type = 3;
										memcpy(data, &type, 4);
										memcpy(data + 4, text.c_str(), text.length()); // change memcpy here
										memcpy(data + 4 + text.length(), &zero, 1); // change memcpy here, revert to 4
										ENetPacket* packetsou = enet_packet_create(data,
											5 + text.length(),
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetsou);
										int gemcalc10k = b - 5000;
										ofstream myfile2;
										myfile2.open("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										myfile2 << std::to_string(gemcalc10k);
										myfile2.close();
										std::ifstream ifszi("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										std::string contentx((std::istreambuf_iterator<char>(ifszi)),
											(std::istreambuf_iterator<char>()));
										int updgem = atoi(contentx.c_str());
										GamePacket pp = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), updgem));
										ENetPacket* packetpp = enet_packet_create(pp.data,
											pp.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetpp);
										delete pp.data;
										Player::OnConsoleMessage(peer, "`5Got `o1 `2Door Mover");
										OnStorePurchaseResults(peer, "`oReceived: `o1 `2Door Mover.");
										SaveItemMoreTimes(1404, 1, peer, success);


										sendSound(peer, "cash_register.wav");
									}
									else {
										OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Gems To Buy This Item. `5Try again later.");
									}
								}
								if (cch.find("action|buy\nitem|grow_spray") == 0) {
									std::ifstream ifsz("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									std::string content((std::istreambuf_iterator<char>(ifsz)),
										(std::istreambuf_iterator<char>()));
									int b = atoi(content.c_str());
									if (b >= 200)
									{
										bool success = true;
										string text = "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0\n";
										BYTE* data = new BYTE[5 + text.length()];
										BYTE zero = 0;
										int type = 3;
										memcpy(data, &type, 4);
										memcpy(data + 4, text.c_str(), text.length()); // change memcpy here
										memcpy(data + 4 + text.length(), &zero, 1); // change memcpy here, revert to 4
										ENetPacket* packetsou = enet_packet_create(data,
											5 + text.length(),
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetsou);
										int gemcalc10k = b - 200;
										ofstream myfile2;
										myfile2.open("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										myfile2 << std::to_string(gemcalc10k);
										myfile2.close();
										std::ifstream ifszi("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										std::string contentx((std::istreambuf_iterator<char>(ifszi)),
											(std::istreambuf_iterator<char>()));
										int updgem = atoi(contentx.c_str());
										GamePacket pp = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), updgem));
										ENetPacket* packetpp = enet_packet_create(pp.data,
											pp.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetpp);
										delete pp.data;
										Player::OnConsoleMessage(peer, "`5Got `o1 `2Grow Spray Feltilizer");
										OnStorePurchaseResults(peer, "`oReceived: `o1 `2Grow Spray Feltilizer.");
										SaveItemMoreTimes(228, 1, peer, success);


										sendSound(peer, "cash_register.wav");
									}
									else {
										OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Gems To Buy This Item. `5Try again later.");
									}
								}
								if (cch.find("action|buy\nitem|deluxe_grow_spray") == 0) {
									std::ifstream ifsz("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									std::string content((std::istreambuf_iterator<char>(ifsz)),
										(std::istreambuf_iterator<char>()));
									int b = atoi(content.c_str());
									if (b >= 900)
									{
										bool success = true;
										string text = "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0\n";
										BYTE* data = new BYTE[5 + text.length()];
										BYTE zero = 0;
										int type = 3;
										memcpy(data, &type, 4);
										memcpy(data + 4, text.c_str(), text.length()); // change memcpy here
										memcpy(data + 4 + text.length(), &zero, 1); // change memcpy here, revert to 4
										ENetPacket* packetsou = enet_packet_create(data,
											5 + text.length(),
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetsou);
										int gemcalc10k = b - 900;
										ofstream myfile2;
										myfile2.open("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										myfile2 << std::to_string(gemcalc10k);
										myfile2.close();
										std::ifstream ifszi("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										std::string contentx((std::istreambuf_iterator<char>(ifszi)),
											(std::istreambuf_iterator<char>()));
										int updgem = atoi(contentx.c_str());
										GamePacket pp = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), updgem));
										ENetPacket* packetpp = enet_packet_create(pp.data,
											pp.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetpp);
										delete pp.data;
										Player::OnConsoleMessage(peer, "`5Got `o1 `2Deluxe Grow Spray Feltilizer");
										OnStorePurchaseResults(peer, "`oReceived: `o1 `2Deluxe Grow Spray Feltilizer.");
										SaveItemMoreTimes(1778, 1, peer, success);


										sendSound(peer, "cash_register.wav");
									}
									else {
										OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Gems To Buy This Item. `5Try again later.");
									}
								}
								if (cch.find("action|buy\nitem|small_lock") == 0) {
									std::ifstream ifsz("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									std::string content((std::istreambuf_iterator<char>(ifsz)),
										(std::istreambuf_iterator<char>()));
									int b = atoi(content.c_str());
									if (b >= 50)
									{
										bool success = true;
										string text = "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0\n";
										BYTE* data = new BYTE[5 + text.length()];
										BYTE zero = 0;
										int type = 3;
										memcpy(data, &type, 4);
										memcpy(data + 4, text.c_str(), text.length()); // change memcpy here
										memcpy(data + 4 + text.length(), &zero, 1); // change memcpy here, revert to 4
										ENetPacket* packetsou = enet_packet_create(data,
											5 + text.length(),
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetsou);
										int gemcalc10k = b - 50;
										ofstream myfile2;
										myfile2.open("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										myfile2 << std::to_string(gemcalc10k);
										myfile2.close();
										std::ifstream ifszi("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										std::string contentx((std::istreambuf_iterator<char>(ifszi)),
											(std::istreambuf_iterator<char>()));
										int updgem = atoi(contentx.c_str());
										GamePacket pp = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), updgem));
										ENetPacket* packetpp = enet_packet_create(pp.data,
											pp.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetpp);
										delete pp.data;
										Player::OnConsoleMessage(peer, "`5Got 1 `oSmall lock");
										OnStorePurchaseResults(peer, "`oReceived: `o1 `2Small lock.");

										SaveItemMoreTimes(202, 1, peer, success);

										sendSound(peer, "cash_register.wav");
									}
									else {
										OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Gems To Buy This Item. `5Try again later.");
									}
								}
								if (cch.find("action|buy\nitem|10_wl") == 0) {
									std::ifstream ifsz("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									std::string content((std::istreambuf_iterator<char>(ifsz)),
										(std::istreambuf_iterator<char>()));
									int b = atoi(content.c_str());
									if (b >= 20000)
									{
										bool success = true;
										string text = "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0\n";
										BYTE* data = new BYTE[5 + text.length()];
										BYTE zero = 0;
										int type = 3;
										memcpy(data, &type, 4);
										memcpy(data + 4, text.c_str(), text.length()); // change memcpy here
										memcpy(data + 4 + text.length(), &zero, 1); // change memcpy here, revert to 4
										ENetPacket* packetsou = enet_packet_create(data,
											5 + text.length(),
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetsou);
										int gemcalc10k = b - 20000;
										ofstream myfile2;
										myfile2.open("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										myfile2 << std::to_string(gemcalc10k);
										myfile2.close();
										std::ifstream ifszi("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										std::string contentx((std::istreambuf_iterator<char>(ifszi)),
											(std::istreambuf_iterator<char>()));
										int updgem = atoi(contentx.c_str());
										GamePacket pp = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), updgem));
										ENetPacket* packetpp = enet_packet_create(pp.data,
											pp.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetpp);
										delete pp.data;
										Player::OnConsoleMessage(peer, "`5Got 10 `oWorld lock");
										OnStorePurchaseResults(peer, "`oReceived: `o10 `2World lock.");

										SaveItemMoreTimes(242, 10, peer, success);

										sendSound(peer, "cash_register.wav");
									}
									else {
										OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Gems To Buy This Item. `5Try again later.");
									}
								}
								if (cch.find("action|buy\nitem|world_lock") == 0) {
									std::ifstream ifsz("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									std::string content((std::istreambuf_iterator<char>(ifsz)),
										(std::istreambuf_iterator<char>()));
									int b = atoi(content.c_str());
									if (b >= 2000)
									{
										bool success = true;
										string text = "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0\n";
										BYTE* data = new BYTE[5 + text.length()];
										BYTE zero = 0;
										int type = 3;
										memcpy(data, &type, 4);
										memcpy(data + 4, text.c_str(), text.length()); // change memcpy here
										memcpy(data + 4 + text.length(), &zero, 1); // change memcpy here, revert to 4
										ENetPacket* packetsou = enet_packet_create(data,
											5 + text.length(),
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetsou);
										int gemcalc10k = b - 2000;
										ofstream myfile2;
										myfile2.open("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										myfile2 << std::to_string(gemcalc10k);
										myfile2.close();
										std::ifstream ifszi("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										std::string contentx((std::istreambuf_iterator<char>(ifszi)),
											(std::istreambuf_iterator<char>()));
										int updgem = atoi(contentx.c_str());
										GamePacket pp = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), updgem));
										ENetPacket* packetpp = enet_packet_create(pp.data,
											pp.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetpp);
										delete pp.data;
										Player::OnConsoleMessage(peer, "`5Got 1 `oWorld lock");
										OnStorePurchaseResults(peer, "`oReceived: `o1 `2World lock.");

										SaveItemMoreTimes(242, 1, peer, success);

										sendSound(peer, "cash_register.wav");
									}
									else {
										OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Gems To Buy This Item. `5Try again later.");
									}
								}
								if (cch == "action|buy\nitem|upgrade_backpack\n") {
									/*Fast Item Setup*/
									auto Price = 6500;
									ifstream ifsz("save/gemdb/_" + pData->rawName + ".txt");
									string content((std::istreambuf_iterator<char>(ifsz)), (std::istreambuf_iterator<char>()));
									auto gembux = atoi(content.c_str());
									if (gembux >= Price) {
										if (pData->currentInventorySize >= 200) break;
										gembux -= Price;
										ofstream myfile;
										myfile.open("save/gemdb/_" + pData->rawName + ".txt");
										myfile << gembux;
										myfile.close();
										Player::OnSetBux(peer, gembux, 0);
										Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
										short nextSpace = 0;
										if (pData->currentInventorySize + 10 > 200) {
											nextSpace = 200;
										}
										else {
											nextSpace = pData->currentInventorySize + 10;
										}
										pData->currentInventorySize += 10;
										SendInventory(peer, pData->inventory);
										const auto p3 = packetEnd(appendFloat(appendIntx(appendFloat(appendFloat(appendFloat(appendString(createPacket(), "OnSetClothing"), (static_cast<PlayerInfo*>(peer->data))->cloth_hair, (static_cast<PlayerInfo*>(peer->data))->cloth_shirt, (static_cast<PlayerInfo*>(peer->data))->cloth_pants), (static_cast<PlayerInfo*>(peer->data))->cloth_feet, (static_cast<PlayerInfo*>(peer->data))->cloth_face, (static_cast<PlayerInfo*>(peer->data))->cloth_hand), (static_cast<PlayerInfo*>(peer->data))->cloth_back, (static_cast<PlayerInfo*>(peer->data))->cloth_mask, (static_cast<PlayerInfo*>(peer->data))->cloth_necklace), (static_cast<PlayerInfo*>(peer->data))->skinColor), (static_cast<PlayerInfo*>(peer->data))->cloth_ances, 0.0f, 0.0f));
										memcpy(p3.data + 8, &((static_cast<PlayerInfo*>(peer->data))->netID), 4);
										const auto packet = enet_packet_create(p3.data, p3.len, ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);
										GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `0Upgrade Backpack`` (`w10 Slots``) `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(gembux) + " `wGems left.\n\n`5Received: ``Backpack Upgrade"));
										ENetPacket* packets = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packets);
										delete p.data;
									}
									else {
										Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
										GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `0Upgrade Backpack`` (`w10 Slots``)``!  You're `$" + to_string(Price - gembux) + "`` Gems short."));
										ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);
										delete p.data;
									}
								}
								if (cch.find("action|buy\nitem|riftwing") == 0) {
									std::ifstream ifsz("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									std::string content((std::istreambuf_iterator<char>(ifsz)),
										(std::istreambuf_iterator<char>()));
									int b = atoi(content.c_str());
									if (b >= 350000)
									{
										bool success = true;
										string text = "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0\n";
										BYTE* data = new BYTE[5 + text.length()];
										BYTE zero = 0;
										int type = 3;
										memcpy(data, &type, 4);
										memcpy(data + 4, text.c_str(), text.length()); // change memcpy here
										memcpy(data + 4 + text.length(), &zero, 1); // change memcpy here, revert to 4
										ENetPacket* packetsou = enet_packet_create(data,
											5 + text.length(),
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetsou);
										int gemcalc10k = b - 150000;
										ofstream myfile2;
										myfile2.open("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										myfile2 << std::to_string(gemcalc10k);
										myfile2.close();
										std::ifstream ifszi("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										std::string contentx((std::istreambuf_iterator<char>(ifszi)),
											(std::istreambuf_iterator<char>()));
										int updgem = atoi(contentx.c_str());
										GamePacket pp = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), updgem));
										ENetPacket* packetpp = enet_packet_create(pp.data,
											pp.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetpp);
										delete pp.data;
										Player::OnConsoleMessage(peer, "`5Got `21 `oRift Wings!");
										OnStorePurchaseResults(peer, "`oReceived: `o1 `2Rift Wings!");

										SaveItemMoreTimes(11478, 1, peer, success);

										sendSound(peer, "cash_register.wav");
									}
									else {
										OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Gems To Buy This Item. `5Try again later.");
									}
								}
								if (cch.find("action|buy\nitem|itemomonth") == 0) {
									std::ifstream ifsz("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									std::string content((std::istreambuf_iterator<char>(ifsz)),
										(std::istreambuf_iterator<char>()));
									int b = atoi(content.c_str());
									if (b >= 150000)
									{
										bool success = true;
										string text = "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0\n";
										BYTE* data = new BYTE[5 + text.length()];
										BYTE zero = 0;
										int type = 3;
										memcpy(data, &type, 4);
										memcpy(data + 4, text.c_str(), text.length()); // change memcpy here
										memcpy(data + 4 + text.length(), &zero, 1); // change memcpy here, revert to 4
										ENetPacket* packetsou = enet_packet_create(data,
											5 + text.length(),
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetsou);
										int gemcalc10k = b - 150000;
										ofstream myfile2;
										myfile2.open("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										myfile2 << std::to_string(gemcalc10k);
										myfile2.close();
										std::ifstream ifszi("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										std::string contentx((std::istreambuf_iterator<char>(ifszi)),
											(std::istreambuf_iterator<char>()));
										int updgem = atoi(contentx.c_str());
										GamePacket pp = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), updgem));
										ENetPacket* packetpp = enet_packet_create(pp.data,
											pp.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetpp);
										delete pp.data;
										Player::OnConsoleMessage(peer, "`5Got `21 `oRoyal Guardian Armor");
										OnStorePurchaseResults(peer, "`oReceived: `o1 `2Royal Guardian Armor");

										SaveItemMoreTimes(11552, 1, peer, success);

										sendSound(peer, "cash_register.wav");
									}
									else {
										OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Gems To Buy This Item. `5Try again later.");
									}
								}
								if (cch.find("action|buy\nitem|rare_seed") == 0) {
									ifstream ifsz("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									string content((std::istreambuf_iterator<char>(ifsz)), (std::istreambuf_iterator<char>()));
									auto gembux = atoi(content.c_str());
									if (gembux >= 1500) {
										int Seed1 = 0;
										int Seed2 = 0;
										int Seed3 = 0;
										int Seed4 = 0;
										int Seed5 = 0;
										int AVGRarity = rand() % 10 + 10;
										while (Seed1 == 0 || Seed2 == 0 || Seed3 == 0 || Seed4 == 0 || Seed5 == 0) {
											for (int i = 0; i < maxItems; i++) {
												if (i >= 1000) {
													Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "Something went wrong.", 0, true);
													break;
												}
												if (isSeed(i) && getItemDef(i).rarity == AVGRarity || isSeed(i) && getItemDef(i).rarity == AVGRarity + 1) {
													if (Seed1 == 0) Seed1 = i;
													else if (Seed2 == 0) Seed2 = i;
													else if (Seed3 == 0) Seed3 = i;
													else if (Seed4 == 0) Seed4 = i;
													else if (Seed5 == 0) Seed5 = i;
													else break;
													AVGRarity = rand() % 10 + 10;
												}
												else if (i == maxItems - 1) {
													break;
												}
											}
										}
										if (CheckItemMaxed(peer, Seed1, 1) || CheckItemMaxed(peer, Seed2, 1) || CheckItemMaxed(peer, Seed3, 1) || CheckItemMaxed(peer, Seed4, 75) || CheckItemMaxed(peer, Seed5, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 5 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize) {
											Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
											GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
											ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(peer, 0, packet);
											delete p.data;
											continue;
										}
										gembux -= 1500;
										ofstream myfile;
										myfile.open("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										myfile << gembux;
										myfile.close();
										Player::OnSetBux(peer, gembux, 0);
										bool success = true;
										SaveItemMoreTimes(Seed1, 1, peer, success);
										SaveItemMoreTimes(Seed2, 1, peer, success);
										SaveItemMoreTimes(Seed3, 1, peer, success);
										SaveItemMoreTimes(Seed4, 1, peer, success);
										SaveItemMoreTimes(Seed5, 1, peer, success);
										sendSound(peer, "piano_nice.wav");
										GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `oRare Seed Pack `wfor `$" + to_string(1500) + " `wGems.\nYou have `$" + to_string(gembux) + " `wGems left.\n\n`5Received:`` " + getItemDef(Seed1).name + "`$,`` " + getItemDef(Seed2).name + "`$,`` " + getItemDef(Seed3).name + "`$,`` " + getItemDef(Seed4).name + "`$,`` " + getItemDef(Seed5).name + "\n"));
										ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);
										delete p.data;
									}
									else {
										Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
										GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `oRare Seed Pack``!  You're `$" + to_string(1500 - gembux) + "`` Gems short."));
										ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);
										delete p.data;
									}
								}

								if (cch.find("action|buy\nitem|geiger") == 0) {
									/*Fast Item Setup*/
									auto Price = 7500;
									auto ItemID = 2204;
									auto count = 1;
									ifstream ifsz("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									string content((std::istreambuf_iterator<char>(ifsz)), (std::istreambuf_iterator<char>()));
									auto gembux = atoi(content.c_str());
									if (gembux >= Price) {
										if (CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && !CheckItemExists(peer, ItemID)) {
											Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
											GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
											ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(peer, 0, packet);
											delete p.data;
											continue;
										}
										gembux -= Price;
										ofstream myfile;
										myfile.open("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										myfile << gembux;
										myfile.close();
										Player::OnSetBux(peer, gembux, 0);
										bool success = true;
										SaveItemMoreTimes(ItemID, count, peer, success);
										Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
										GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased " + to_string(count) + " `o" + getItemDef(ItemID).name + " `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(gembux) + " `wGems left.\n\n`5Received: ``" + to_string(count) + " " + getItemDef(ItemID).name + ""));
										ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);
										delete p.data;
									}
									else {
										Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
										GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + getItemDef(ItemID).name + "``!  You're `$" + to_string(Price - gembux) + "`` Gems short."));
										ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);
										delete p.data;
									}
								}

								if (cch.find("action|buy\nitem|grow_scan") == 0) {
									/*Fast Item Setup*/
									auto Price = 3500;
									auto ItemID = 6016;
									auto count = 1;
									ifstream ifsz("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									string content((std::istreambuf_iterator<char>(ifsz)), (std::istreambuf_iterator<char>()));
									auto gembux = atoi(content.c_str());
									if (gembux >= Price) {
										if (CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && !CheckItemExists(peer, ItemID)) {
											Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
											GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
											ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(peer, 0, packet);
											delete p.data;
											continue;
										}
										gembux -= Price;
										ofstream myfile;
										myfile.open("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										myfile << gembux;
										myfile.close();
										Player::OnSetBux(peer, gembux, 0);
										bool success = true;
										SaveItemMoreTimes(ItemID, count, peer, success);
										Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
										GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased " + to_string(count) + " `o" + getItemDef(ItemID).name + " `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(gembux) + " `wGems left.\n\n`5Received: ``" + to_string(count) + " " + getItemDef(ItemID).name + ""));
										ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);
										delete p.data;
									}
									else {
										Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
										GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + getItemDef(ItemID).name + "``!  You're `$" + to_string(Price - gembux) + "`` Gems short."));
										ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);
										delete p.data;
									}
								}
								if (cch.find("action|buy\nitem|sspitems") == 0) {
									/*Fast Item Setup*/
									auto Price = 500;
									auto ItemID = 5706;
									auto count = 1;
									ifstream ifsz("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									string content((std::istreambuf_iterator<char>(ifsz)), (std::istreambuf_iterator<char>()));
									auto gembux = atoi(content.c_str());
									if (gembux >= Price) {
										if (CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && !CheckItemExists(peer, ItemID)) {
											Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
											GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
											ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(peer, 0, packet);
											delete p.data;
											continue;
										}
										gembux -= Price;
										ofstream myfile;
										myfile.open("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										myfile << gembux;
										myfile.close();
										Player::OnSetBux(peer, gembux, 0);
										bool success = true;
										SaveItemMoreTimes(ItemID, count, peer, success);
										Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
										GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased " + to_string(count) + " `o" + getItemDef(ItemID).name + " `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(gembux) + " `wGems left.\n\n`5Received: ``" + to_string(count) + " " + getItemDef(ItemID).name + ""));
										ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);
										delete p.data;
									}
									else {
										Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
										GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + getItemDef(ItemID).name + "``!  You're `$" + to_string(Price - gembux) + "`` Gems short."));
										ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);
										delete p.data;
									}
								}

								if (cch.find("action|buy\nitem|farm_pack") == 0) {
									ifstream ifsz("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									string content((std::istreambuf_iterator<char>(ifsz)), (std::istreambuf_iterator<char>()));
									auto gembux = atoi(content.c_str());
									if (gembux >= 4000) {
										if (CheckItemMaxed(peer, 872, 1) || CheckItemMaxed(peer, 866, 1) || CheckItemMaxed(peer, 102, 100) || CheckItemMaxed(peer, 340, 40) || CheckItemMaxed(peer, 5666, 40) || CheckItemMaxed(peer, 954, 60) || CheckItemMaxed(peer, 4584, 75) || CheckItemMaxed(peer, 898, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 8 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize) {
											Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
											GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
											ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(peer, 0, packet);
											delete p.data;
											continue;
										}
										gembux -= 4000;
										ofstream myfile;
										myfile.open("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										myfile << gembux;
										myfile.close();
										Player::OnSetBux(peer, gembux, 0);
										bool success = true;
										SaveItemMoreTimes(102, 100, peer, success);
										SaveItemMoreTimes(340, 40, peer, success);
										SaveItemMoreTimes(5666, 40, peer, success);
										SaveItemMoreTimes(954, 60, peer, success);
										SaveItemMoreTimes(4584, 75, peer, success);
										SaveItemMoreTimes(898, 1, peer, success);
										SaveItemMoreTimes(872, 1, peer, success);
										SaveItemMoreTimes(866, 1, peer, success);
										Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
										GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `oFarm Pack `wfor `$" + to_string(4000) + " `wGems.\nYou have `$" + to_string(gembux) + " `wGems left.\n\n`5Received:`` 100 Wooden Platforms`$,`` 40 Chandeliers`$,`` 40 Laser Grids`$,`` 60 Sugar Canes`$,`` 75 Pepper Trees`$,`` Dear John Tractor\n"));
										ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);
										delete p.data;
									}
									else {
										Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
										GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `oFarm Pack``!  You're `$" + to_string(4000 - gembux) + "`` Gems short."));
										ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);
										delete p.data;
									}
								}

								if (cch.find("action|buy\nitem|west_pack") == 0) {
									ifstream ifsz("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									string content((std::istreambuf_iterator<char>(ifsz)), (std::istreambuf_iterator<char>()));
									auto gembux = atoi(content.c_str());
									if (gembux >= 8000) {
										if (CheckItemMaxed(peer, 1044, 1) || CheckItemMaxed(peer, 1046, 10) || CheckItemMaxed(peer, 1048, 1) || CheckItemMaxed(peer, 1020, 1) || CheckItemMaxed(peer, 1022, 1) || CheckItemMaxed(peer, 1030, 1) || CheckItemMaxed(peer, 1024, 1) || CheckItemMaxed(peer, 1026, 1) || CheckItemMaxed(peer, 1028, 1) || CheckItemMaxed(peer, 1036, 1) || CheckItemMaxed(peer, 1034, 1) || CheckItemMaxed(peer, 1032, 1) || CheckItemMaxed(peer, 1038, 10) || CheckItemMaxed(peer, 1040, 1) || CheckItemMaxed(peer, 1042, 5) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 15 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize) {
											Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
											GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
											ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(peer, 0, packet);
											delete p.data;
											continue;
										}
										gembux -= 8000;
										ofstream myfile;
										myfile.open("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										myfile << gembux;
										myfile.close();
										Player::OnSetBux(peer, gembux, 0);
										bool success = true;
										//Buffalo`$,`` 10 Rustic Fences`$,`` Campfire`$,`` Parasol
										SaveItemMoreTimes(1022, 1, peer, success);
										SaveItemMoreTimes(1030, 1, peer, success);
										SaveItemMoreTimes(1024, 1, peer, success);
										SaveItemMoreTimes(1026, 1, peer, success);
										SaveItemMoreTimes(1028, 1, peer, success);
										SaveItemMoreTimes(1036, 1, peer, success);
										SaveItemMoreTimes(1034, 1, peer, success);
										SaveItemMoreTimes(1032, 1, peer, success);
										SaveItemMoreTimes(1038, 10, peer, success);
										SaveItemMoreTimes(1040, 1, peer, success);
										SaveItemMoreTimes(1042, 5, peer, success);
										SaveItemMoreTimes(1044, 1, peer, success);
										SaveItemMoreTimes(1046, 10, peer, success);
										SaveItemMoreTimes(1048, 1, peer, success);
										SaveItemMoreTimes(1020, 1, peer, success);
										Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
										GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `oWild West Pack `wfor `$" + to_string(8000) + " `wGems.\nYou have `$" + to_string(gembux) + " `wGems left.\n\n`5Received:`` Cowboy Hat`&,`` Cowboy Boots`$,`` War Paint`$,`` Face Bandana`$,`` Sheriff Vest`$,`` Layer Cake Dress`$,`` Corset`$,`` Kansas Curls`$,`` 10 Western Building`$,`` Saloon Doors`$,`` 5 Western Banners`$,`` Buffalo`$,`` 10 Rustic Fences`$,`` Campfire`$,`` Parasol\n"));
										ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);
										delete p.data;
									}
									else {
										Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
										GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `oWild West Pack``!  You're `$" + to_string(8000 - gembux) + "`` Gems short."));
										ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);
										delete p.data;
									}
								}

								if (cch.find("action|buy\nitem|city_pack") == 0) {
									ifstream ifsz("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									string content((std::istreambuf_iterator<char>(ifsz)), (std::istreambuf_iterator<char>()));
									auto gembux = atoi(content.c_str());
									if (gembux >= 8000) {
										if (CheckItemMaxed(peer, 1008, 1) || CheckItemMaxed(peer, 986, 3) || CheckItemMaxed(peer, 992, 3) || CheckItemMaxed(peer, 990, 10) || CheckItemMaxed(peer, 996, 10) || CheckItemMaxed(peer, 998, 10) || CheckItemMaxed(peer, 988, 3) || CheckItemMaxed(peer, 1004, 10) || CheckItemMaxed(peer, 1006, 1) || CheckItemMaxed(peer, 1002, 1) || CheckItemMaxed(peer, 994, 10) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 11 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize) {
											Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
											GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
											ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(peer, 0, packet);
											delete p.data;
											continue;
										}
										gembux -= 8000;
										ofstream myfile;
										myfile.open("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										myfile << gembux;
										myfile.close();
										Player::OnSetBux(peer, gembux, 0);
										bool success = true;
										//1 Blue Mailbox`$,`` 1 Fire Hydrant`$,`` 10 Sidewalks
										SaveItemMoreTimes(1008, 1, peer, success);
										SaveItemMoreTimes(986, 3, peer, success);
										SaveItemMoreTimes(992, 3, peer, success);
										SaveItemMoreTimes(990, 10, peer, success);
										SaveItemMoreTimes(996, 10, peer, success);

										SaveItemMoreTimes(998, 10, peer, success);

										SaveItemMoreTimes(988, 3, peer, success);

										SaveItemMoreTimes(1004, 10, peer, success);

										SaveItemMoreTimes(1006, 1, peer, success);

										SaveItemMoreTimes(1002, 1, peer, success);
										SaveItemMoreTimes(994, 10, peer, success);
										Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
										GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `oCity Pack `wfor `$" + to_string(8000) + " `wGems.\nYou have `$" + to_string(gembux) + " `wGems left.\n\n`5Received:`` ATM Machine`&,`` 3 Street Signs`$,`` 3 Streetlamps`$,`` 10 Gothic Building tiles`$,`` 10 Tenement Building tiles`$,`` 10 Fire Escapes`$,`` 3 Gargoyles`$,`` 10 Hedges`$,`` 1 Blue Mailbox`$,`` 1 Fire Hydrant`$,`` 10 Sidewalks\n"));
										ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);
										delete p.data;
									}
									else {
										Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
										GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `oCity Pack``!  You're `$" + to_string(8000 - gembux) + "`` Gems short."));
										ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);
										delete p.data;
									}
								}

								if (cch.find("action|buy\nitem|science_pack") == 0) {
									ifstream ifsz("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									string content((std::istreambuf_iterator<char>(ifsz)), (std::istreambuf_iterator<char>()));
									auto gembux = atoi(content.c_str());
									if (gembux >= 5000) {
										if (CheckItemMaxed(peer, 916, 5) || CheckItemMaxed(peer, 914, 10) || CheckItemMaxed(peer, 924, 5) || CheckItemMaxed(peer, 920, 5) || CheckItemMaxed(peer, 918, 5) || CheckItemMaxed(peer, 930, 1) || CheckItemMaxed(peer, 928, 1) || CheckItemMaxed(peer, 912, 1) || CheckItemMaxed(peer, 772, 1) || CheckItemMaxed(peer, 770, 1) || CheckItemMaxed(peer, 904, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 11 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize) {
											Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
											GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
											ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(peer, 0, packet);
											delete p.data;
											continue;
										}
										gembux -= 5000;
										ofstream myfile;
										myfile.open("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										myfile << gembux;
										myfile.close();
										Player::OnSetBux(peer, gembux, 0);
										bool success = true;
										SaveItemMoreTimes(930, 1, peer, success);
										SaveItemMoreTimes(928, 1, peer, success);
										SaveItemMoreTimes(912, 1, peer, success);
										SaveItemMoreTimes(772, 1, peer, success);
										SaveItemMoreTimes(770, 1, peer, success);
										SaveItemMoreTimes(904, 1, peer, success);
										SaveItemMoreTimes(916, 5, peer, success);
										SaveItemMoreTimes(914, 10, peer, success);
										SaveItemMoreTimes(924, 5, peer, success);
										SaveItemMoreTimes(920, 5, peer, success);
										SaveItemMoreTimes(918, 5, peer, success);
										Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
										GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `oMad Science Kit `wfor `$" + to_string(5000) + " `wGems.\nYou have `$" + to_string(gembux) + " `wGems left.\n\n`5Received:`` Death Ray`&,`` Science Station`$,`` Laboratory`$,`` LabCoat`$,`` Combover Hair`$,`` Goggles`$,`` 5 Chemical R`$,`` 10 Chemical G`$,`` 5 Chemical Y`$,`` 5 Chemical B`$,`` 5 Chemical P\n"));
										ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);
										delete p.data;
									}
									else {
										Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
										GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `oMad Science Kit``!  You're `$" + to_string(5000 - gembux) + "`` Gems short."));
										ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);
										delete p.data;
									}
								}

								if (cch.find("action|buy\nitem|fishin_pack") == 0) {
									ifstream ifsz("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									string content((std::istreambuf_iterator<char>(ifsz)), (std::istreambuf_iterator<char>()));
									auto gembux = atoi(content.c_str());
									if (gembux >= 6000) {
										if (CheckItemMaxed(peer, 3044, 1) || CheckItemMaxed(peer, 2914, 5) || CheckItemMaxed(peer, 5522, 1) || CheckItemMaxed(peer, 5524, 1) || CheckItemMaxed(peer, 2912, 1) || CheckItemMaxed(peer, 3004, 10) || CheckItemMaxed(peer, 3002, 1) || CheckItemMaxed(peer, 822, 5) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 8 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize) {
											Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
											GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
											ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(peer, 0, packet);
											delete p.data;
											continue;
										}
										gembux -= 6000;
										ofstream myfile;
										myfile.open("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										myfile << gembux;
										myfile.close();
										Player::OnSetBux(peer, gembux, 0);
										bool success = true;
										SaveItemMoreTimes(3044, 1, peer, success);
										SaveItemMoreTimes(2914, 5, peer, success);
										SaveItemMoreTimes(5522, 1, peer, success);
										SaveItemMoreTimes(5524, 1, peer, success);
										SaveItemMoreTimes(2912, 1, peer, success);
										SaveItemMoreTimes(3004, 10, peer, success);
										SaveItemMoreTimes(3002, 1, peer, success);
										SaveItemMoreTimes(822, 5, peer, success);
										Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
										GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `oFishin' Pack `wfor `$" + to_string(6000) + " `wGems.\nYou have `$" + to_string(gembux) + " `wGems left.\n\n`5Received:`` Tackle Box`$,`` 5 Wiggly Worms`$,`` Hand Drill`$,`` Nuclear Detonator`$,`` Fishing Rod`$,`` 10 Fish Tanks`$,`` Fish Tank Port`$,`` 5 Water Buckets\n"));
										ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);
										delete p.data;
									}
									else {
										Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
										GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `oFishin' Pack``!  You're `$" + to_string(6000 - gembux) + "`` Gems short."));
										ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);
										delete p.data;
									}
								}
								if (cch.find("action|buy\nitem|firefighter") == 0) {
									ifstream ifsz("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									string content((std::istreambuf_iterator<char>(ifsz)), (std::istreambuf_iterator<char>()));
									auto gembux = atoi(content.c_str());
									if (gembux >= 3600) {
										if (CheckItemMaxed(peer, 3048, 1) || CheckItemMaxed(peer, 3056, 1) || CheckItemMaxed(peer, 3060, 1) || CheckItemMaxed(peer, 3052, 1) || CheckItemMaxed(peer, 3066, 1) || CheckItemMaxed(peer, 3072, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 6 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize) {
											Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
											GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
											ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(peer, 0, packet);
											delete p.data;
											continue;
										}
										gembux -= 3600;
										ofstream myfile;
										myfile.open("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										myfile << gembux;
										myfile.close();
										Player::OnSetBux(peer, gembux, 0);
										bool success = true;
										SaveItemMoreTimes(3048, 1, peer, success);
										SaveItemMoreTimes(3056, 1, peer, success);
										SaveItemMoreTimes(3060, 1, peer, success);
										SaveItemMoreTimes(3052, 1, peer, success);
										SaveItemMoreTimes(3066, 1, peer, success);
										SaveItemMoreTimes(3072, 1, peer, success);
										Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
										GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `oFirefighter Pack `wfor `$" + to_string(3600) + " `wGems.\nYou have `$" + to_string(gembux) + " `wGems left.\n\n`5Received:`` Firefighter Helmet - Yellow`$,`` Firefighter Pants - Yellow`$,`` Firefighter Jacket - Yellow`$,`` Firefighter Boots`$,`` Fire Hose`$,`` Firehouse\n"));
										ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);
										delete p.data;
									}
									else {
										Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
										GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `oFirefighter Pack``!  You're `$" + to_string(3600 - gembux) + "`` Gems short."));
										ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);
										delete p.data;
									}
								}
								if (cch.find("action|buy\nitem|paleo_kit") == 0) {
									ifstream ifsz("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									string content((std::istreambuf_iterator<char>(ifsz)), (std::istreambuf_iterator<char>()));
									auto gembux = atoi(content.c_str());
									if (gembux >= 7500) {
										if (CheckItemMaxed(peer, 4132, 5) || CheckItemMaxed(peer, 3932, 1) || CheckItemMaxed(peer, 3934, 1) || CheckItemMaxed(peer, 3938, 1) || CheckItemMaxed(peer, 4128, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 5 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize) {
											Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
											GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
											ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(peer, 0, packet);
											delete p.data;
											continue;
										}
										gembux -= 7500;
										ofstream myfile;
										myfile.open("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										myfile << gembux;
										myfile.close();
										Player::OnSetBux(peer, gembux, 0);
										bool success = true;
										SaveItemMoreTimes(4132, 5, peer, success);
										SaveItemMoreTimes(3932, 1, peer, success);
										SaveItemMoreTimes(3934, 1, peer, success);
										SaveItemMoreTimes(3938, 1, peer, success);
										SaveItemMoreTimes(4128, 1, peer, success);
										Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
										GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `oPaleontologist's Kit `wfor `$" + to_string(7500) + " `wGems.\nYou have `$" + to_string(gembux) + " `wGems left.\n\n`5Received:`` Fossil Prep Station`$,`` 5 Fossil Brushes`$,`` Rock Hammer`$,`` Rock Chisel`$,`` Blue Hardhat\n"));
										ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);
										delete p.data;
									}
									else {
										Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
										GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `oPaleontologist's Kit``!  You're `$" + to_string(7500 - gembux) + "`` Gems short."));
										ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);
										delete p.data;
									}
								}

								if (cch.find("action|buy\nitem|upgradebp") == 0) {
									bool success = true;
									std::ifstream ifsz("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									std::string content((std::istreambuf_iterator<char>(ifsz)),
										(std::istreambuf_iterator<char>()));
									int b = atoi(content.c_str());
									if (b >= 1000)
									{
										string text = "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0\n";
										BYTE* data = new BYTE[5 + text.length()];
										BYTE zero = 0;
										int type = 3;
										memcpy(data, &type, 4);
										memcpy(data + 4, text.c_str(), text.length()); // change memcpy here
										memcpy(data + 4 + text.length(), &zero, 1); // change memcpy here, revert to 4
										ENetPacket* packetsou = enet_packet_create(data,
											5 + text.length(),
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetsou);
										int gemcalc10k = b - 1000;
										ofstream myfile2;
										myfile2.open("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										myfile2 << std::to_string(gemcalc10k);
										myfile2.close();
										std::ifstream ifszi("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										std::string contentx((std::istreambuf_iterator<char>(ifszi)),
											(std::istreambuf_iterator<char>()));
										int updgem = atoi(contentx.c_str());
										GamePacket pp = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), updgem));
										ENetPacket* packetpp = enet_packet_create(pp.data,
											pp.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetpp);
										delete pp.data;


										bool success = true;
										short nextSpace = 0;
										if (static_cast<PlayerInfo*>(peer->data)->currentInventorySize + 30 > 200)
										{
											nextSpace = 200;
										}
										else
										{
											nextSpace = static_cast<PlayerInfo*>(peer->data)->currentInventorySize + 30;
										}

										ifstream fg("save/players/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".json");
										json j;
										fg >> j;
										fg.close();

										j["inventorysize"] = nextSpace;

										ofstream fs("save/players/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".json");
										fs << j;
										fs.close();
										if (success)
										{
											RemoveInventoryItem(242, 30, peer, true);
											OnStorePurchaseResults(peer, "`2You upgraded your inventory to `5" + to_string(nextSpace) + " `2Spaces!");
											static_cast<PlayerInfo*>(peer->data)->currentInventorySize += 30;
											SendInventory(peer, static_cast<PlayerInfo*>(peer->data)->inventory);
											const auto p3 = packetEnd(appendFloat(appendIntx(appendFloat(appendFloat(appendFloat(appendString(createPacket(), "OnSetClothing"), (static_cast<PlayerInfo*>(peer->data))->cloth_hair, (static_cast<PlayerInfo*>(peer->data))->cloth_shirt, (static_cast<PlayerInfo*>(peer->data))->cloth_pants), (static_cast<PlayerInfo*>(peer->data))->cloth_feet, (static_cast<PlayerInfo*>(peer->data))->cloth_face, (static_cast<PlayerInfo*>(peer->data))->cloth_hand), (static_cast<PlayerInfo*>(peer->data))->cloth_back, (static_cast<PlayerInfo*>(peer->data))->cloth_mask, (static_cast<PlayerInfo*>(peer->data))->cloth_necklace), (static_cast<PlayerInfo*>(peer->data))->skinColor), (static_cast<PlayerInfo*>(peer->data))->cloth_ances, 0.0f, 0.0f));
											memcpy(p3.data + 8, &((static_cast<PlayerInfo*>(peer->data))->netID), 4);
											const auto packet = enet_packet_create(p3.data, p3.len, ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(peer, 0, packet);



											sendSound(peer, "cash_register.wav");
										}
										else {
											OnStorePurchaseResults(peer, "`4Purchase Failed: You Don't Have Enough Gems To Buy This Item. `5Try again later.");
										}
									}
								}
								if (cch.find("action|buy\nitem|paintbrush") == 0) {
									ifstream ifsz("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									string content((std::istreambuf_iterator<char>(ifsz)), (std::istreambuf_iterator<char>()));
									auto gembux = atoi(content.c_str());
									if (gembux >= 30000) {
										if (CheckItemMaxed(peer, 3494, 1) || CheckItemMaxed(peer, 3478, 5) || CheckItemMaxed(peer, 3480, 5) || CheckItemMaxed(peer, 3482, 5) || CheckItemMaxed(peer, 3484, 5) || CheckItemMaxed(peer, 3486, 5) || CheckItemMaxed(peer, 3488, 5) || CheckItemMaxed(peer, 3490, 5) || CheckItemMaxed(peer, 3492, 5) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 9 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize) {
											Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
											GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
											ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(peer, 0, packet);
											delete p.data;
											continue;
										}
										gembux -= 30000;
										ofstream myfile;
										myfile.open("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										myfile << gembux;
										myfile.close();
										Player::OnSetBux(peer, gembux, 0);
										bool success = true;
										SaveItemMoreTimes(3494, 1, peer, success);
										SaveItemMoreTimes(3478, 5, peer, success);
										SaveItemMoreTimes(3480, 5, peer, success);
										SaveItemMoreTimes(3482, 5, peer, success);
										SaveItemMoreTimes(3484, 5, peer, success);
										SaveItemMoreTimes(3486, 5, peer, success);
										SaveItemMoreTimes(3488, 5, peer, success);
										SaveItemMoreTimes(3490, 5, peer, success);
										SaveItemMoreTimes(3492, 5, peer, success);
										Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
										GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `oPainter's Pack `wfor `$" + to_string(30000) + " `wGems.\nYou have `$" + to_string(gembux) + " `wGems left.\n\n`5Received: ``Paintbrush`$,`` 5 Paint Bucket - Yellow`$,`` 5 Paint Bucket - Green`$,`` 5 Paint Bucket - Blue`$,`` 5 Paint Bucket - Varnish`$,`` 5 Paint Bucket - Red`$,`` 5 Paint Bucket - Charcoal`$,`` 5 Paint Bucket - Purple`$,`` 5 Paint Bucket - Aqua\n"));
										ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);
										delete p.data;
									}
									else {
										Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
										GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `oPainter's Pack``!  You're `$" + to_string(30000 - gembux) + "`` Gems short."));
										ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);
										delete p.data;
									}
								}
							}
							else if (cch.find("action|info") == 0) {
								try {
									std::stringstream ss(cch);
									std::string to;
									int id = -1;
									int count = -1;
									while (std::getline(ss, to, '\n')) {
										vector<string> infoDat = explode("|", to);
										if (infoDat.size() == 3) {
											if (infoDat.at(1) == "itemID") id = atoi(infoDat.at(2).c_str());
											if (infoDat.at(1) == "count") count = atoi(infoDat.at(2).c_str());
										}
									}
									if (id == -1 || count == -1 || itemDefs.size() < id || id < 0) break;
									string properties = "\nadd_textbox|";
									if (id == 18) {
										properties += "<CR>`oYou've punched `w" + to_string(pData->totalpunch) + " `otimes.``";
									}
									ItemDefinition itemDef = getItemDef(id);
									if (itemDef.properties & Property_Untradable) properties += "<CR>`1This item cannot be dropped or traded.`` ";
									if (itemDef.properties & Property_Wrenchable) properties += "<CR>`1This item has special properties you can adjust with the Wrench.`` ";
									if (itemDef.properties & Property_NoSeed) properties += "<CR>`1This item never drops any seeds.`` ";
									if (itemDef.properties & Property_Permanent) properties += "<CR>`1This item can't be destroyed - smashing it will return it to your backpack if you have room!`` ";
									if (properties != "\nadd_textbox|") properties += "|left|";
									else properties = "";
									Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_ele_icon|big|`wAbout " + itemDef.name + "``|left|" + std::to_string(id) + "|3|\nadd_spacer|small|\nadd_textbox|" + itemDef.description + "|left|" + properties + "|\nadd_spacer|small|\nend_dialog|continue||OK|");
								}
								catch (const std::out_of_range& e) {
									std::cout << e.what() << std::endl;
								}
								break;
							}
							else if (cch.find("action|communitytabs") == 0) {
								if (cch.find("action|communitytabs\ntype|community_featured_worlds") == 0) {
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnCommunityHubRequest"), "set_description_text|These worlds are some of the most interesting, impressive, or downright cool worlds your fellow Growtopians have created! Can you top them?|\n\nadd_cmmnty_ft_wrld_bttn||`1THENATURETOWER`` by `5Cahtster``|noflags|OPENWORLD|THENATURETOWER|0|0|\nadd_cmmnty_ft_wrld_bttn||`1PARKOUR2`` by `5Artemis``|noflags|OPENWORLD|PARKOUR2|0|0|\nadd_cmmnty_ft_wrld_bttn||`1MRBUNNY`` by `5MostLike``|noflags|OPENWORLD|MRBUNNY|0|0|\nadd_cmmnty_ft_wrld_bttn||`1URANIUMKINGDOM`` by `5LFU``|noflags|OPENWORLD|URANIUMKINGDOM|0|0|\nadd_cmmnty_ft_wrld_bttn||`1KDERBY`` by `5Frarie``|noflags|OPENWORLD|KDERBY|0|0|\n\nadd_tab_button|community_featured_worlds|featured worlds|interface/large/btn_community_hub.rttex||0|0|0|0||\nadd_tab_button|community_worldoftheday|world of the day|interface/large/btn_community_hub.rttex||0|1|0|0||\nadd_tab_button|communityworlds_toprated|top rated|interface/large/btn_community_hub.rttex||0|4|0|0||\nadd_tab_button|communityworlds_toptoday|top today|interface/large/btn_community_hub.rttex||0|5|0|0||\nadd_tab_button|communityworlds_topoverall|topoverall|interface/large/btn_community_hub.rttex||0|6|0|0||\nadd_tab_button|community_growtorials|community growtorials|interface/large/btn_community_hub.rttex||0|2|0|0||\nadd_tab_button|community_influencervideos|influencer videos|interface/large/btn_community_hub.rttex||0|3|0|0||\ncommunity_hub_type|community_featured_worlds"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
								}
								else if (cch.find("action|communitytabs\ntype|community_worldoftheday") == 0) {
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnCommunityHubRequest"), "set_description_text|The ten most recent World of the Day can be found here! These are particularly notable worlds that wowed our community team. New ones are added daily (duh), so keep coming back to see the latest!|\nset_default_color|`o\nadd_cmmnty_wotd_bttn|OPENWORLD|`w#2665`` LOSTLUNA by `#Lunarist``|social/wotd/lostluna.rttex||1|2|LOSTLUNA|\nadd_cmmnty_wotd_bttn|OPENWORLD|`w#2664`` SKIINGMOUNTAINS by `#Cards``|interface/large/social_buttons01.rttex||1|2|SKIINGMOUNTAINS|\nadd_cmmnty_wotd_bttn|OPENWORLD|`w#2663`` SHANGHAICHINA by `#vooNY``|interface/large/social_buttons01.rttex||1|2|SHANGHAICHINA|\nadd_cmmnty_wotd_bttn|OPENWORLD|`w#2662`` VORT by `#LEFU``|interface/large/social_buttons01.rttex||1|2|VORT|\nadd_cmmnty_wotd_bttn|OPENWORLD|`w#2661`` THEYEAROFTHEOX by `#Festivan``|interface/large/social_buttons01.rttex||1|2|THEYEAROFTHEOX|\nadd_cmmnty_wotd_bttn|OPENWORLD|`w#2660`` SORCERIUM by `#CREONE``|interface/large/social_buttons01.rttex||1|2|SORCERIUM|\nadd_cmmnty_wotd_bttn|OPENWORLD|`w#2659`` REDPRISON by `#Luxinia``|interface/large/social_buttons01.rttex||1|2|REDPRISON|\nadd_cmmnty_wotd_bttn|OPENWORLD|`w#2658`` EASTERNPIER by `#Dropped``|interface/large/social_buttons01.rttex||1|2|EASTERNPIER|\nadd_cmmnty_wotd_bttn|OPENWORLD|`w#2657`` FUTUREJUMP by `#ELEKTRONI``|interface/large/social_buttons01.rttex||1|2|FUTUREJUMP|\nadd_cmmnty_wotd_bttn|OPENWORLD|`w#2656`` ASIRENSONG by `#ZeoFire``|interface/large/social_buttons01.rttex||1|2|ASIRENSONG|\nembed_data|starting|0\nembed_data|ranktype|3\nadd_community_button|next|`5<Next 10>|noflags|0|0|\nadd_tab_button|community_featured_worlds|featured worlds|interface/large/btn_community_hub.rttex||0|0|0|0||\nadd_tab_button|community_worldoftheday|world of the day|interface/large/btn_community_hub.rttex||0|1|0|0||\nadd_tab_button|communityworlds_toprated|top rated|interface/large/btn_community_hub.rttex||0|4|0|0||\nadd_tab_button|communityworlds_toptoday|top today|interface/large/btn_community_hub.rttex||0|5|0|0||\nadd_tab_button|communityworlds_topoverall|topoverall|interface/large/btn_community_hub.rttex||0|6|0|0||\nadd_tab_button|community_growtorials|community growtorials|interface/large/btn_community_hub.rttex||0|2|0|0||\nadd_tab_button|community_influencervideos|influencer videos|interface/large/btn_community_hub.rttex||0|3|0|0||\ncommunity_hub_type|community_worldoftheday"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
								}
								else if (cch.find("action|communitytabs\ntype|communityworlds_toprated") == 0) {
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnCommunityHubRequest"), "set_description_text|The best worlds to be found, according to YOU! Grouped by category, each of the worlds here got top scores from your fellow Growtopians, and you guys are NOT easy to impress!|\nset_default_color|`o\nembed_data|chosencat|-1\nadd_textbox|Select a category to view.|left|\nadd_community_button|cat1|Adventure|noflags|0|0|\nadd_community_button|cat2|Art|noflags|0|0|\nadd_community_button|cat3|Farm|noflags|0|0|\nadd_community_button|cat4|Game|noflags|0|0|\nadd_community_button|cat5|Information|noflags|0|0|\nadd_community_button|cat6|Parkour|noflags|0|0|\nadd_community_button|cat7|Roleplay|noflags|0|0|\nadd_community_button|cat8|Shop|noflags|0|0|\nadd_community_button|cat9|Social|noflags|0|0|\nadd_community_button|cat10|Storage|noflags|0|0|\nadd_community_button|cat11|Story|noflags|0|0|\nadd_community_button|cat12|Trade|noflags|0|0|\nadd_community_button|cat13|Guild|noflags|0|0|\nadd_community_button|cat14|Puzzle|noflags|0|0|\nadd_community_button|cat15|Music|noflags|0|0|\nadd_tab_button|community_featured_worlds|featured worlds|interface/large/btn_community_hub.rttex||0|0|0|0||\nadd_tab_button|community_worldoftheday|world of the day|interface/large/btn_community_hub.rttex||0|1|0|0||\nadd_tab_button|communityworlds_toprated|top rated|interface/large/btn_community_hub.rttex||0|4|0|0||\nadd_tab_button|communityworlds_toptoday|top today|interface/large/btn_community_hub.rttex||0|5|0|0||\nadd_tab_button|communityworlds_topoverall|topoverall|interface/large/btn_community_hub.rttex||0|6|0|0||\nadd_tab_button|community_growtorials|community growtorials|interface/large/btn_community_hub.rttex||0|2|0|0||\nadd_tab_button|community_influencervideos|influencer videos|interface/large/btn_community_hub.rttex||0|3|0|0||\ncommunity_hub_type|communityworlds_toprated\nend_dialog|community_ranking|||"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
								}
								else if (cch.find("action|communitytabs\ntype|communityworlds_toptoday") == 0) {
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnCommunityHubRequest"), "set_description_text|Top-rated worlds according to your fellow Growtopians, but ONLY for today! Check out this list to see what's popular right now!|\nset_default_color|`o\nadd_cmmnty_toprated_bttn||`w#1`` BUYBFG by `#V3K1``|noflags|OPENWORLD|BUYBFG|0|0|\nadd_cmmnty_toprated_bttn||`w#2`` BUYBLING by `#TDZEUS``|noflags|OPENWORLD|BUYBLING|0|0|\nadd_cmmnty_toprated_bttn||`w#3`` BUYGHCLINK by `#xeliGT``|noflags|OPENWORLD|BUYGHCLINK|0|0|\nadd_cmmnty_toprated_bttn||`w#4`` AFNESIA by `#Afnesia``|noflags|OPENWORLD|AFNESIA|0|0|\nadd_cmmnty_toprated_bttn||`w#5`` BUYZODIAC by `#TinyFishy``|noflags|OPENWORLD|BUYZODIAC|0|0|\nadd_cmmnty_toprated_bttn||`w#6`` OXIDIA by `#Lenvir``|noflags|OPENWORLD|OXIDIA|0|0|\nadd_cmmnty_toprated_bttn||`w#7`` BUYHAND by `#Yro``|noflags|OPENWORLD|BUYHAND|0|0|\nadd_cmmnty_toprated_bttn||`w#8`` LEAVE by `#MeepTheBean``|noflags|OPENWORLD|LEAVE|0|0|\nadd_cmmnty_toprated_bttn||`w#9`` BUYGAIA by `#RichQA``|noflags|OPENWORLD|BUYGAIA|0|0|\nadd_cmmnty_toprated_bttn||`w#10`` HIRC by `#GrowtopiaLOVERS``|noflags|OPENWORLD|HIRC|0|0|\nadd_cmmnty_toprated_bttn||`w#11`` STATUS by `#MeepTheBean``|noflags|OPENWORLD|STATUS|0|0|\nadd_cmmnty_toprated_bttn||`w#12`` SELLAW by `#MiaWoltz``|noflags|OPENWORLD|SELLAW|0|0|\nadd_cmmnty_toprated_bttn||`w#13`` BUYANCES by `#Noob``|noflags|OPENWORLD|BUYANCES|0|0|\nadd_cmmnty_toprated_bttn||`w#14`` BOUTIQUE by `#ExFaKe``|noflags|OPENWORLD|BOUTIQUE|0|0|\nadd_cmmnty_toprated_bttn||`w#15`` BUYLASER by `#JackWoltz``|noflags|OPENWORLD|BUYLASER|0|0|\nadd_cmmnty_toprated_bttn||`w#16`` BUYDRAGON by `#YavuzK``|noflags|OPENWORLD|BUYDRAGON|0|0|\nadd_cmmnty_toprated_bttn||`w#17`` CHANDIELINK by `#StephenStrange``|noflags|OPENWORLD|CHANDIELINK|0|0|\nadd_cmmnty_toprated_bttn||`w#18`` BUYPET by `#Hades0x1``|noflags|OPENWORLD|BUYPET|0|0|\nadd_cmmnty_toprated_bttn||`w#19`` BUYCAPE by `#RAJA``|noflags|OPENWORLD|BUYCAPE|0|0|\nadd_cmmnty_toprated_bttn||`w#20`` BUYCRYSTAL by `#TUND0``|noflags|OPENWORLD|BUYCRYSTAL|0|0|\nembed_data|starting|0\nembed_data|ranktype|2\nadd_community_button|next|`5<Next 20>|noflags|0|0|\nadd_tab_button|community_featured_worlds|featured worlds|interface/large/btn_community_hub.rttex||0|0|0|0||\nadd_tab_button|community_worldoftheday|world of the day|interface/large/btn_community_hub.rttex||0|1|0|0||\nadd_tab_button|communityworlds_toprated|top rated|interface/large/btn_community_hub.rttex||0|4|0|0||\nadd_tab_button|communityworlds_toptoday|top today|interface/large/btn_community_hub.rttex||0|5|0|0||\nadd_tab_button|communityworlds_topoverall|topoverall|interface/large/btn_community_hub.rttex||0|6|0|0||\nadd_tab_button|community_growtorials|community growtorials|interface/large/btn_community_hub.rttex||0|2|0|0||\nadd_tab_button|community_influencervideos|influencer videos|interface/large/btn_community_hub.rttex||0|3|0|0||\ncommunity_hub_type|communityworlds_toptoday\nend_dialog|community_ranking|||"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
								}
								else if (cch.find("action|communitytabs\ntype|communityworlds_topoverall") == 0) {
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnCommunityHubRequest"), "set_description_text|Top-rated worlds according to your fellow Growtopians, across ALL time! Check out this list to see the most popular worlds EVER!|\nset_default_color|`o\nadd_cmmnty_toprated_bttn||`w#1`` BUYWING by `#UTC``|noflags|OPENWORLD|BUYWING|0|0|\nadd_cmmnty_toprated_bttn||`w#2`` TRADE by `#iGO``|noflags|OPENWORLD|TRADE|0|0|\nadd_cmmnty_toprated_bttn||`w#3`` BUYWINGS by `#4PY``|noflags|OPENWORLD|BUYWINGS|0|0|\nadd_cmmnty_toprated_bttn||`w#4`` BUYCAPE by `#RAJA``|noflags|OPENWORLD|BUYCAPE|0|0|\nadd_cmmnty_toprated_bttn||`w#5`` BUYPET0123 by `#KudoBeLLe``|noflags|OPENWORLD|BUYPET0123|0|0|\nadd_cmmnty_toprated_bttn||`w#6`` BUY by `#Faitaro``|noflags|OPENWORLD|BUY|0|0|\nadd_cmmnty_toprated_bttn||`w#7`` BUYHAND by `#Yro``|noflags|OPENWORLD|BUYHAND|0|0|\nadd_cmmnty_toprated_bttn||`w#8`` RAKKAUSS by `#OgModiest``|noflags|OPENWORLD|RAKKAUSS|0|0|\nadd_cmmnty_toprated_bttn||`w#9`` BUYDRAGON by `#YavuzK``|noflags|OPENWORLD|BUYDRAGON|0|0|\nadd_cmmnty_toprated_bttn||`w#10`` TURK by `#Hakanss``|noflags|OPENWORLD|TURK|0|0|\nadd_cmmnty_toprated_bttn||`w#11`` GROCERY by `#LAW``|noflags|OPENWORLD|GROCERY|0|0|\nadd_cmmnty_toprated_bttn||`w#12`` LOVE by `#Coalas``|noflags|OPENWORLD|LOVE|0|0|\nadd_cmmnty_toprated_bttn||`w#13`` NASDAQOLD by `#TriLLiONaiRE``|noflags|OPENWORLD|NASDAQOLD|0|0|\nadd_cmmnty_toprated_bttn||`w#14`` SUOMI by `#Tuoppi``|noflags|OPENWORLD|SUOMI|0|0|\nadd_cmmnty_toprated_bttn||`w#15`` BUYTEENY by `#MiaWoltz``|noflags|OPENWORLD|BUYTEENY|0|0|\nadd_cmmnty_toprated_bttn||`w#16`` WIKI by `#woshipaul74``|noflags|OPENWORLD|WIKI|0|0|\nadd_cmmnty_toprated_bttn||`w#17`` WASTEDBUYWEATHER by `#Zraei``|noflags|OPENWORLD|WASTEDBUYWEATHER|0|0|\nadd_cmmnty_toprated_bttn||`w#18`` BUYWORLD112223 by `#Bretz``|noflags|OPENWORLD|BUYWORLD112223|0|0|\nadd_cmmnty_toprated_bttn||`w#19`` TRADED by `#Zwane``|noflags|OPENWORLD|TRADED|0|0|\nadd_cmmnty_toprated_bttn||`w#20`` BUYFISHTANK by `#Calipao``|noflags|OPENWORLD|BUYFISHTANK|0|0|\nembed_data|starting|0\nembed_data|ranktype|0\nadd_community_button|next|`5<Next 20>|noflags|0|0|\nadd_tab_button|community_featured_worlds|featured worlds|interface/large/btn_community_hub.rttex||0|0|0|0||\nadd_tab_button|community_worldoftheday|world of the day|interface/large/btn_community_hub.rttex||0|1|0|0||\nadd_tab_button|communityworlds_toprated|top rated|interface/large/btn_community_hub.rttex||0|4|0|0||\nadd_tab_button|communityworlds_toptoday|top today|interface/large/btn_community_hub.rttex||0|5|0|0||\nadd_tab_button|communityworlds_topoverall|topoverall|interface/large/btn_community_hub.rttex||0|6|0|0||\nadd_tab_button|community_growtorials|community growtorials|interface/large/btn_community_hub.rttex||0|2|0|0||\nadd_tab_button|community_influencervideos|influencer videos|interface/large/btn_community_hub.rttex||0|3|0|0||\ncommunity_hub_type|communityworlds_topoverall\nend_dialog|community_ranking|||"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
								}
								else if (cch.find("action|communitytabs\ntype|community_growtorials") == 0) {
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnCommunityHubRequest"), "set_description_text|Still learning the ropes? That's okay - Growtopia is HUGE! We've made a few fun videos to help teach you the basics - check them out here!\nadd_commnty_growtorial_bttn|https://www.youtube.com/channel/UCNFTBaDHB4_Y8eFa8YssSMQ?sub_confirmation=1|YT_OFFICIAL|interface/large/social_buttons01.rttex|Check out our official YouTube channel for awesome and helpful videos!<CR><CR><CR><CR>Would you like to open this in YouTube?|1|4|\nadd_commnty_growtorial_bttn|https://www.youtube.com/watch?v=GaCsg9qp5yw|YT_LATEST|interface/large/social_buttons01.rttex|Check out our latest YouTube video packed with awesomeness!<CR><CR><CR><CR>Would you like to watch this video in YouTube?|1|5|\nadd_commnty_growtorial_bttn|https://www.youtube.com/watch?v=T_hkqWu8Q-s|TUTORIAL_BASICS|interface/large/tutorial_vid_buttons.rttex|Growtorials - How to: Basics covers all the basics around the game mechanics, from punching to planting and splicing. Sit back, relax and discover Growtopia!<CR><CR><CR><CR>Would you like to watch this video in Youtube?|0|0|\nadd_commnty_growtorial_bttn|https://www.youtube.com/watch?v=HLLyf_fYBOM|TUTORIAL_DOORS|interface/large/tutorial_vid_buttons.rttex|Growtorials - How to: The Doors continues from where we stopped at Ep.1. Explore how to link your doors and of course how to secure your world!<CR><CR><CR><CR>Would you like to watch this video in Youtube?|1|0|\nadd_commnty_growtorial_bttn|https://www.youtube.com/watch?v=6ZRzVNjff3E|TUTORIAL_FARMING|interface/large/tutorial_vid_buttons.rttex|Growtorials - How to: Farm covers the basics of the farming concept and explains how to easily organize your farming world!<CR><CR><CR><CR>Would you like to watch this video in Youtube?|0|2|\nadd_commnty_growtorial_bttn|https://www.youtube.com/watch?v=mxY-mm04rk8|TUTORIAL_GUILDS|interface/large/tutorial_vid_buttons.rttex|Growtorials - How to: Guilds covers the basics of the newest Guilds feature and explains how to create a guild, invite members, upgrade it and many more!<CR><CR><CR><CR>Would you like to watch this video in Youtube?|1|2|\nadd_commnty_growtorial_bttn|https://www.youtube.com/watch?v=NDAUj1ysik0|TUTORIAL_TRADING|interface/large/tutorial_vid_buttons.rttex|Growtorials - How to: Trade covers the basics of trading, vending machines, how to avoid trading scams and drop games!<CR><CR><CR><CR>Would you like to watch this video in Youtube?|0|3|\nadd_commnty_growtorial_bttn|https://www.youtube.com/watch?v=yNHcSVWdYr0|TUTORIAL_EVENTS|interface/large/tutorial_vid_buttons.rttex|Growtorials - How to: Seasonal Events showcases the basic rules of the Seasonal Events!<CR><CR><CR><CR>Would you like to watch this video in Youtube?|0|4|\nadd_commnty_growtorial_bttn|https://www.youtube.com/watch?v=I0Zm591tzQM|TUTORIAL_STARTOPIA|interface/large/tutorial_vid_buttons.rttex|Growtorials - How to: Startopia showcases the basics of this Feature!<CR><CR><CR><CR>Would you like to watch this video in Youtube?|1|4|\nadd_commnty_growtorial_bttn||TUTORIAL_COMMING_SOON|interface/large/tutorial_vid_buttons.rttex|Comming Soon! Stay tuned - new content coming soon!|0|1|\nadd_tab_button|community_featured_worlds|featured worlds|interface/large/btn_community_hub.rttex||0|0|0|0||\nadd_tab_button|community_worldoftheday|world of the day|interface/large/btn_community_hub.rttex||0|1|0|0||\nadd_tab_button|communityworlds_toprated|top rated|interface/large/btn_community_hub.rttex||0|4|0|0||\nadd_tab_button|communityworlds_toptoday|top today|interface/large/btn_community_hub.rttex||0|5|0|0||\nadd_tab_button|communityworlds_topoverall|topoverall|interface/large/btn_community_hub.rttex||0|6|0|0||\nadd_tab_button|community_growtorials|community growtorials|interface/large/btn_community_hub.rttex||0|2|0|0||\nadd_tab_button|community_influencervideos|influencer videos|interface/large/btn_community_hub.rttex||0|3|0|0||\ncommunity_hub_type|community_growtorials"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
								}
								else if (cch.find("action|communitytabs\ntype|community_influencervideos") == 0) {
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnCommunityHubRequest"), "set_description_text|Check out the amazing content from the official Growtopia Content Creators!|\n\n#vendinQ\nadd_cmmnty_inflncr_bttn|https://www.youtube.com/channel/UCRI3xBgsvaSOoxIU2I8NRlQ|vendinQ|interface/large/social_buttons02.rttex|Check out vendinq's videos about Growtopia!<CR><CR><CR><CR>Would you like to open this link in your browser?|0|7|\n\n#Drick345\nadd_cmmnty_inflncr_bttn|https://www.youtube.com/channel/UCPcKdBmSkeuIwGWvPyEYogw|Drick345|interface/large/social_buttons03.rttex|Check out Drick345's videos about Growtopia!<CR><CR><CR><CR>Would you like to open this link in your browser?|1|2|\n\n#AmniFilms\nadd_cmmnty_inflncr_bttn|https://www.youtube.com/channel/UCXnposnioRfNWZbRtN1p67Q|AmniFilms|interface/large/social_buttons03.rttex|Check out AmniFilms' videos about Growtopia!<CR><CR><CR><CR>Would you like to open this link in your browser?|0|2|\n\n#VinOscar\nadd_cmmnty_inflncr_bttn|https://www.youtube.com/channel/UC0OwFV2jrzzqGDzFjvwUTuw|VinOscar|interface/large/social_buttons02.rttex|Check out VinOscar's videos about Growtopia!<CR><CR><CR><CR>Would you like to open this link in your browser?|1|6|\n\n#MrSongo\nadd_cmmnty_inflncr_bttn|https://www.youtube.com/channel/UCGP2FEt9I95YGiBeCQwlxbA|MrSongo|interface/large/social_buttons01.rttex|Check out MrSongo's videos about Growtopia!<CR><CR><CR><CR>Would you like to open this link in your browser?|0|6|\n\n#PeterW\nadd_cmmnty_inflncr_bttn|https://www.youtube.com/channel/UCp5zpbzBV55HaLdRbavo1kw|PeterW|interface/large/social_buttons03.rttex|Check out PeterW's videos about Growtopia!<CR><CR><CR><CR>Would you like to open this link in your browser?|1|1|\nadd_tab_button|community_featured_worlds|featured worlds|interface/large/btn_community_hub.rttex||0|0|0|0||\nadd_tab_button|community_worldoftheday|world of the day|interface/large/btn_community_hub.rttex||0|1|0|0||\nadd_tab_button|communityworlds_toprated|top rated|interface/large/btn_community_hub.rttex||0|4|0|0||\nadd_tab_button|communityworlds_toptoday|top today|interface/large/btn_community_hub.rttex||0|5|0|0||\nadd_tab_button|communityworlds_topoverall|topoverall|interface/large/btn_community_hub.rttex||0|6|0|0||\nadd_tab_button|community_growtorials|community growtorials|interface/large/btn_community_hub.rttex||0|2|0|0||\nadd_tab_button|community_influencervideos|influencer videos|interface/large/btn_community_hub.rttex||0|3|0|0||\ncommunity_hub_type|community_influencervideos"));
									ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
								}
								break;
							}
							else if (cch.find("action|dialog_return") == 0) {
								if (pData->isIn == false || pData->wrenchsession < 0 || pData->wrenchsession > 6000 || world == nullptr || pData->currentWorld == "EXIT" || serverIsFrozen) break;
								if (pData->wrenchsession == 0) {
									if (pData->lastPunchX < 0 || pData->lastPunchY < 0 || pData->lastPunchX > 6000 || pData->lastPunchY > 10000) {
										if (pData->lastPunchX != -1 && pData->lastPunchY != -1) {
											SendConsole("Invalid structure handler, x was " + to_string(pData->lastPunchX) + " and y was " + to_string(pData->lastPunchY), "INVALID");
											break;
										}
									}
								} else if (pData->wrenchsession < 0 || pData->wrenchsession > 6000) {
									SendConsole("Invalid session handler, wrenchsession was " + to_string(pData->wrenchsession) + "", "INVALID");
									break;
								}
								std::stringstream ss(cch);
								std::string to;
								int b_days = 0, b_hours = 0, b_minutes = 0, givesafeitemItemIDInt = 0, givesafeitemCountInt = 0, safe_withdrawConfirmCountInt = 0, safe_withdrawConfirmAposInt = 0, givedonationboxitemCountInt = 0, givedonationboxitemItemIDInt = 0, setprice = 0, chk_peritem = 0, chk_perlock = 0, stockitem = 0, buyprice = 0;
								string vend_set_price = "0", per_item = "0", vverify = "0", vbuycount = "0", vexpectprice = "0", vexpectitem = "0", stuff_gravity = "", stuff_invert = "", stuff_spin = "", stuffITEM = "";
								bool triggersell = false, confirm_create = false, registerguild = false, isPassDoorDialog = false, isRegisterDialog = false, isSendATPSDialog = false, isDropDialog = false, isAutoBreakDialog = false, isGrowScanDialog = false, isAutoPlaceDialog = false, isMarketDialog = false, isTitleDialog = false, isRiftDialog = false, isMannequinEdit = false, isTrashDialog = false, isMinerDialog = false, trashitem2 = false, isStuffDialog = false, isBackgroundDialog = false, isMagDialog = false, isMagCheckDialog = false, isLockDialog = false, isEntranceDialog = false, MagUpdateDialog = false, isLargeDialog = false, wizardDialog = false;
								bool isThermoDialog = false;
								bool isTinyDialog = false;
								bool isCaveDialog = false;
								bool isBeachDialog = false;
								bool isTeleDialog = false;
								bool isHeatwaveDialog = false;
								bool isEditDoorDialog = false;
								bool isEditPathDialog = false;
								bool isSongDialog = false;
								bool isValentineDialog = false;
								bool worldcategoryDialog = false;
								// GUILD
								bool isEditState = false;
								bool isGuildDialog = false;
								string newstate = "";
								string guildName = "";
								string guildStatement = "";
								string guildFlagBg = "";
								string guildFlagFg = "";
								// END GUILD 
								// SECURITY CAMERA
								bool isSecurityCamera = false;
								// CHANGE NAME
								bool isCnamedialog = false;
								bool FinalCname = false;
								string newname = "";
								// CHANGE NAME WORLD
								bool isAddress = false;
								string newworld = "";
								// CHANGE WORLD END
								bool signEditor = false;
								bool isgivedonationboxitemConfirm = false;
								bool isFindDialog = false;
								bool isWrenchDialog = false;
								bool isRolesDialog = false;
								bool isTradeDialog = false;
								bool isaddItemToDonationBox = false;
								bool isboxlvl1AddItemDialog = false;
								bool isboxlvl2AddItemDialog = false;
								bool isboxlvl3AddItemDialog = false;
								bool changepasswordDialog = false;
								bool isSafeAddItemDialog = false;
								bool issafedepositconfirmDialog = false;
								bool issafewithdrawConfirmDialog = false;
								bool notebook_edit = false;
								bool title_save = false;
								bool Dcharm = false;
								string ef1 = "";
								string ef2 = "";
								string ef3 = "";
								bool vending = false;
								bool vending_buy = false;
								bool digivending_buy = false;
								bool UpVend = false;
								bool digivending = false;
								bool SurgeryDialog = false;
								bool SocialPortalDialog = false;
								bool tradeConfirmDialog = false;
								bool banPanelDialog = false;
								bool cursePanelDialog = false;
								bool mutePanelDialog = false;
								bool blacklistPanelDialog = false;
								//captcha
								bool captcha = false;
								string captchaanswer;
								//adventure real gt
								bool isAdventure = false;
								string adventuresign = "";
								//billboard
								bool isBillBoard = false;
								bool billpicker = false;
								int billitem = 0;
								// World NO-CLIP Setting by GTIR //
								string allowNoClip = "";
								// Music - //
								string tempo = "";
								string disable_music = "";
								string disable_music_render = "";
								// End Music // 
								// Spotlight RGT By GTIR //
								bool shineSpot2 = false;
								bool shineSpot = false;
								bool turnSpotOff = false;
								string spotID = "";
								//megaphone
								bool megaphone = false;
								string sbtext = "";
								// VIP ENTRANCE
								bool isVipDialog = false;
								bool VipAccess = false;
								bool RemoveVipAccess = false;
								string vipPub = "";
								string vipid = "";
								// END VIP ENTRANCE
								// D SHELF
								bool isdself = false;
								string ditem1 = "";
								string ditem2 = "";
								string ditem3 = "";
								string ditem4 = "";
								// END DSHELF
								string showbillboard = "";
								string billboardprice = "";
								string wlperitem = "";
								string itemperwl = "";
								string guild_name;
								string guild_statement;
								string guild_mascot_bg;
								string guild_mascot_fg;
								string addItemToDonationBox = "";
								string stuffitem = "";
								string magplantitem = "";
								string emeraldbfg = "";
								string gravitystr = "";
								string btn = "";
								string register_username = "", register_password = "", register_password_verify = "", register_email = "";
								string dropitemcount = "";
								string trashitemcount = "";
								string door_destination_world = "", door_destination_id = "", door_name = "", door_id = "", locked = "";
								string entranceresult = "";
								string playerNetId = "";
								string muted = "";
								string publicremote = "";
								string telefonas = "";
								string uranusnames = "";
								string tinynames = "";
								string largenames = "";
								string beachnames = "";
								string thermonames = "";
								string message321 = "";
								string givedonationboxitemCount = "";
								string boxlvl1AddItemDialog = "";
								string boxlvl2AddItemDialog = "";
								string boxlvl3AddItemDialog = "";
								string SafeAddItemDialog = "";
								string safedepositcount = "";
								string safedepositcoord = "";
								string safedeposititemID = "";
								string safe_withdrawConfirmCount = "";
								string h_r = "";
								string h_g = "";
								string h_b = "";
								string safe_withdrawConfirmApos = "";
								string worldpublic = "";
								string guild_name_c = "";
								string safe_withdrawConfirmCoord = "";
								string givedonationboxitemCoord = "";
								string givedonationboxitemItemID = "";
								string givedonationboxitem = "";
								string pass_door_password = "";
								string givedonationboxitemNote = "";
								string title_name = "";
								string personal_note = "";
								string current_password = "";
								string new_password = "";
								string new_password_confirm = "";
								try {
									while (std::getline(ss, to, '\n')) {
										vector<string> infoDat = explode("|", to);
										if (infoDat.size() == 2) {
											if (infoDat.at(0) == "buttonClicked") btn = infoDat.at(1);
											if (pData->trade && infoDat.at(0) == "dialog_return" && infoDat.at(1) != "trade_add") {
												end_trade(peer);
												break;
											}
											if (pData->trade && infoDat.at(0) == "dialog_return" && infoDat.at(1) != "trade_confirm") {
												end_trade(peer);
												break;
											}
											if (pData->haveGrowId == false && infoDat.at(0) == "dialog_name" && infoDat.at(1) != "register") break;
											if (pData->haveGrowId == false && btn != "") break;
											if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "updatebillboard") isBillBoard = true;
											if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "worldcategory") worldcategoryDialog = true;
											if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "vending") vending = true;
											if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "vending_buy") vending_buy = true;
											if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "digivending_buy") digivending_buy = true;
											if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "updigi") UpVend = true;
											if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "digivending") digivending = true;
											if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "displayself") isdself = true;
											if (infoDat[0] == "dialog_name" && infoDat[1] == "sendsb") megaphone = true; //real gt megaphone
											if (infoDat[0] == "volcano" && infoDat[1] == "1")
											{
												world->weather = 39;
												SaveData = true;
												ENetPeer* currentPeer;

												for (currentPeer = server->peers;
													currentPeer < &server->peers[server->peerCount];
													++currentPeer)
												{
													if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
														continue;
													if (isHere(peer, currentPeer))
													{
														GamePacket p2 = packetEnd(appendInt(appendString(createPacket(), "OnSetCurrentWeather"), world->weather));
														ENetPacket* packet2 = enet_packet_create(p2.data,
															p2.len,
															ENET_PACKET_FLAG_RELIABLE);

														enet_peer_send(currentPeer, 0, packet2);
														delete p2.data;
														continue;
													}
												}
											}

											if (infoDat[0] == "iceage" && infoDat[1] == "1")
											{
												world->weather = 38;
												SaveData = true;
												ENetPeer* currentPeer;

												for (currentPeer = server->peers;
													currentPeer < &server->peers[server->peerCount];
													++currentPeer)
												{
													if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
														continue;
													if (isHere(peer, currentPeer))
													{
														GamePacket p2 = packetEnd(appendInt(appendString(createPacket(), "OnSetCurrentWeather"), world->weather));
														ENetPacket* packet2 = enet_packet_create(p2.data,
															p2.len,
															ENET_PACKET_FLAG_RELIABLE);

														enet_peer_send(currentPeer, 0, packet2);
														delete p2.data;
														continue;
													}
												}
											}
											if (infoDat[0] == "sky" && infoDat[1] == "1")
											{
												world->weather = 40;
												SaveData = true;
												ENetPeer* currentPeer;

												for (currentPeer = server->peers;
													currentPeer < &server->peers[server->peerCount];
													++currentPeer)
												{
													if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
														continue;
													if (isHere(peer, currentPeer))
													{
														GamePacket p2 = packetEnd(appendInt(appendString(createPacket(), "OnSetCurrentWeather"), world->weather));
														ENetPacket* packet2 = enet_packet_create(p2.data,
															p2.len,
															ENET_PACKET_FLAG_RELIABLE);

														enet_peer_send(currentPeer, 0, packet2);
														delete p2.data;
														continue;
													}
												}
											}
											if (infoDat[0] == "dialog_name" && infoDat[1] == "dragoncharm_edit")
											{
												Dcharm = true;
											}
											if (Dcharm) {
												//Purple Riftcaoe
												if (infoDat[0] == "eff1") ef1 = infoDat[1];
												if (infoDat[0] == "eff2") ef2 = infoDat[1];
												if (infoDat[0] == "eff3") ef3 = infoDat[1];
												if (ef1 == "1") {
													PlayerCharm(peer, 0, 0, 1, 10, 0, 1, 6);
													((PlayerInfo*)(peer->data))->ef1 == true;
													((PlayerInfo*)(peer->data))->ef2 == false;
													((PlayerInfo*)(peer->data))->ef3 == false;
												}
												if (ef2 == "1") {
													PlayerCharm(peer, 1, 0, 1, 10, 0, 1, 6);
													((PlayerInfo*)(peer->data))->ef1 == false;
													((PlayerInfo*)(peer->data))->ef2 == true;
													((PlayerInfo*)(peer->data))->ef3 == false;
												}
												if (ef3 == "1") {
													PlayerCharm(peer, 2, 0, 1, 10, 0, 1, 6);
													((PlayerInfo*)(peer->data))->ef1 == false;
													((PlayerInfo*)(peer->data))->ef2 == false;
													((PlayerInfo*)(peer->data))->ef3 == true;
												}

											}
											if (infoDat[0] == "buttonClicked" && infoDat[1] == "set_status") Set_Status_Online = true;
											if (Set_Status_Online) {
												if (infoDat[0] == "checkbox_status_online") on = infoDat[1];
												if (infoDat[0] == "checkbox_status_busy") busy = infoDat[1];
												if (infoDat[0] == "checkbox_status_away") away = infoDat[1];
												if (atoi(on.c_str()) == 0 && atoi(busy.c_str()) == 0 && atoi(away.c_str()) == 0) ((PlayerInfo*)(peer->data))->Online = true;
												if (atoi(on.c_str()) == 1) ((PlayerInfo*)(peer->data))->Online = true;
												else ((PlayerInfo*)(peer->data))->Online = false;
												if (atoi(busy.c_str()) == 1) ((PlayerInfo*)(peer->data))->Busy = true;
												else ((PlayerInfo*)(peer->data))->Busy = false;
												if (atoi(away.c_str()) == 1) ((PlayerInfo*)(peer->data))->Away = true;
												else ((PlayerInfo*)(peer->data))->Away = false;
											}
											if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "vip_entrance") isVipDialog = true;
											if (infoDat.at(0) == "VipAcc") {
												vipid = infoDat.at(1);
												VipAccess = true;
											}
											if (infoDat.at(0) == "shinespot") {
												spotID = infoDat.at(1);
												shineSpot = true;
											}
											if (infoDat.at(0) == "shinespot2") {
												spotID = infoDat.at(1);
												shineSpot2 = true;
											}
											if (infoDat.at(0) == "buttonClicked" && infoDat.at(1) == "ConfirmState") isEditState = true;
											if (infoDat.at(0) == "buttonClicked" && infoDat.at(1) == "guildconfirm") isGuildDialog = true;
											if (infoDat.at(0) == "buttonClicked" && infoDat.at(1) == "turnspotoff") turnSpotOff = true;
											if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "RemoveMyVipAccess") RemoveVipAccess = true;
											if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "givedonationboxitemConfirm") isgivedonationboxitemConfirm = true;
											if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "notebook_edit") notebook_edit = true;
											if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "cnamedialog") isCnamedialog = true;
											if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "changename") FinalCname = true;
											if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "ChangeNameWorld") isAddress = true;
											if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "title_save") title_save = true;
											if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "gateway_edit") isEntranceDialog = true;
											if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "editsign") signEditor = true;
											if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "lock_edit") isLockDialog = true;
											if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "magplantcheck") isMagCheckDialog = true;
											if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "magplantupdate") MagUpdateDialog = true;
											if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "safe_withdrawConfirm") issafewithdrawConfirmDialog = true;
											if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "safedepositconfirm") issafedepositconfirmDialog = true;
											if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "surge") SurgeryDialog = true;
											if (infoDat.at(0).substr(0, 16) == "addDonationItem_") isaddItemToDonationBox = true;
											if (infoDat.at(0).substr(0, 12) == "safedeposit_") isSafeAddItemDialog = true;
											if (infoDat.at(0).substr(0, 15) == "boxlvl1deposit_") isboxlvl1AddItemDialog = true;
											if (infoDat.at(0).substr(0, 15) == "boxlvl2deposit_") isboxlvl2AddItemDialog = true;
											if (infoDat.at(0).substr(0, 15) == "boxlvl3deposit_") isboxlvl3AddItemDialog = true;
											if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "weatherspcl9") isHeatwaveDialog = true;
											if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "weatherspcl") isStuffDialog = true; 
											if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "weatherspcl3") isBackgroundDialog = true;
											if (infoDat.at(0) == "magplantitem") isMagDialog = true;
											if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "mainwrenchpage") isWrenchDialog = true;
											if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "roleRewardsPage") isRolesDialog = true;
											if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "dropdialog") isDropDialog = true;
											if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "autobreak") isAutoBreakDialog = true;
											if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "autoplace") isAutoPlaceDialog = true;
											if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "trashdialog") isTrashDialog = true;
											if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "findid") isFindDialog = true;
											if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "door_edit") isEditDoorDialog = true;
											if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "path_edit") isEditPathDialog = true;
											if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "register") isRegisterDialog = true;
											if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "growid_apply") isSendATPSDialog = true;
											if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "song_edit") isSongDialog = true;
											if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "mannequin_edit") isMannequinEdit = true;
											if (infoDat.at(0) == "buttonClicked" && infoDat.at(1) == "cctvupdate") isSecurityCamera = true;
											if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "uselargeblast") isLargeDialog = true;
											if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "usethermoblast") isThermoDialog = true;
											if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "usetinyblast") isTinyDialog = true;
											if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "usecaveblast") isCaveDialog = true;
											if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "usebeachblast") isBeachDialog = true;
											if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "usetelephone") isTeleDialog = true;
											if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "password_reply") isPassDoorDialog = true;
											if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "statsblock") isGrowScanDialog = true;
											if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "valentines_quest") isValentineDialog = true;
											if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "trash_item2") trashitem2 = true;
											if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "phonecall") isMinerDialog = true;
											if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "purchase_item") isMarketDialog = true;
											if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "password_change") changepasswordDialog = true;
											if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "dialog_rift_cape") isRiftDialog = true;
											if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "title_edit") isTitleDialog = true;
											if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "legendary_wizard") wizardDialog = true;
											if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "trade_confirm") tradeConfirmDialog = true;
											if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "ban_panel") banPanelDialog = true;
											if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "curse_panel") cursePanelDialog = true;
											if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "mute_panel") mutePanelDialog = true;
											if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "blacklist_panel") blacklistPanelDialog = true;
											if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "captcha_submit") captcha = true;
											if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "adventure_update") isAdventure = true; //The Adventure Begins
											if (infoDat.at(0) == "billitem") billpicker = true; //billboard item picker
											if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "updatebillboard") isBillBoard = true; //billboard update
											if (billpicker) if (infoDat.at(0) == "billitem") billitem = atoi(infoDat.at(1).c_str()); //billboard item checker
											if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "zodiacpets_quest") {
												if (pData->haveGrowId) {
													GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStoreRequest"), "set_description_text|Welcome to the `2iRexus Store``! Select the item you'd like more info on.`o `wWant to get `5Supporter`` status? Any Gem purchase (or `57,000`` Gems earned with free `5Tapjoy`` offers) will make you one. You'll get new skin colors, the `5Recycle`` tool to convert unwanted items into Gems, and more bonuses!\nenable_tabs|1\nadd_tab_button|main_menu|Home|interface/large/btn_shop2.rttex||1|0|0|0||||-1|-1|||0|\nadd_tab_button|locks_menu|Locks And Stuff|interface/large/btn_shop2.rttex||0|1|0|0||||-1|-1|||0|\nadd_tab_button|itempack_menu|Item Packs|interface/large/btn_shop2.rttex||0|3|0|0||||-1|-1|||0|\nadd_tab_button|bigitems_menu|Awesome Items|interface/large/btn_shop2.rttex||0|4|0|0||||-1|-1|||0|\nadd_tab_button|weather_menu|Weather Machines|interface/large/btn_shop2.rttex|Tired of the same sunny sky?  We offer alternatives within...|0|5|0|0||||-1|-1|||0|\nadd_tab_button|token_menu|Growtoken Items|interface/large/btn_shop2.rttex||0|2|0|0||||-1|-1|||0|\nadd_banner|interface/large/gui_shop_featured_header.rttex|0|1|\nadd_button|cny_spray|`oOriental Spice Spray``|interface/large/store_buttons/store_buttons19.rttex|`2You Get:`` 3-pack of Oriental Spice Spray.<CR><CR>`5Description:`` 3-pack of Oriental Spice Spray, packed with rich spices and wholesome powers. Each spray will speed up the growth of one tree from the Lunar New Year event by 24 hours! `2Guaranteed to make any Fortune Cookie Tree extra lucky!``|0|0|5000|0|||-1|-1||-1|-1||1||||||0|\nadd_button|zodiac_dummy|`oZodiac Pets``|interface/large/store_buttons/store_buttons34.rttex|OPENDIALOG&showzodiacpets|0|7|0|0||interface/large/gui_store_button_overlays1.rttex|0|0||-1|-1||1|||||    45% unlocked    ||0|\nadd_button|itemomonth|`oItem Of The Month``|interface/large/store_buttons/store_buttons16.rttex|February 2021:`` `9Perilous Pirate Ship``!<CR><CR>`2You Get:`` 1 `9Perilous Pirate Ship``.<CR><CR>`5Description:`` Set forth on your buccaneering adventures on this, most magnificent of vessels, The Flying Growtopian! Your personal pirate ship will accompany you everywhere. Some kind of unknown marauding magic allows it to transform in size and shape as you command! Pretty nifty if you ask me!|0|3|350000|0||interface/large/gui_store_button_overlays1.rttex|0|0||-1|-1||1||||||0|\nadd_banner|interface/large/gui_shop_featured_header.rttex|0|2|\nadd_button|gems_glory|Road To Glory|interface/large/store_buttons/store_buttons30.rttex|https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=C6SJJ5DGNJZCL&custom=40890790|0|0|0|||interface/large/gui_store_button_overlays1.rttex|0|0|/interface/large/gui_shop_buybanner.rttex|1|0|`2You Get:`` Road To Glory and 100k Gems Instantly.<CR>`5Description:`` Earn Gem rewards when you level up. Every 10 levels you will get additional Gem rewards up to Level 50! Claim all rewards instantly if you are over level 50!! 1.6M Gems in total!! |1||||||0|\nadd_button|gems_bundle05|Gem Bounty|interface/large/store_buttons/store_buttons34.rttex|https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=9UGSFAQBW25JN&custom=40890790|0|6|0||||-1|-1||-1|-1|`2You Get:`` 900,000 Gems, 6 Growtokens, 3 Megaphones.<CR><CR>`5Description:`` Get a plethora of gems to add to your wealth.|1||||||0|\nadd_button|gems_rain|It's Rainin' Gems|interface/large/store_buttons/store_buttons.rttex|https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=4LKDNBCBJ6VU2&custom=40890790|1|5|0||||-1|-1||-1|-1|`2You Get:`` 290,000 Gems, 2 Growtoken, and 1 Megaphone.<CR><CR>`5Description:`` All the gems you could ever want and more plus 2 Growtokens and a Megaphone to tell the whole world about it.|1||||||0|\nadd_button|gems_fountain|Gem Fountain|interface/large/store_buttons/store_buttons2.rttex|https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=K4TTXUZCXNTEL&custom=40890790|0|2|0||||-1|-1||-1|-1|`2You Get:`` 130,000 Gems and 1 Growtoken.<CR><CR>`5Description:`` Get a pile of gems to shop to your hearts desire and 1 Growtoken.|1||||||0|\nadd_button|gems_chest|Chest o' Gems|interface/large/store_buttons/store_buttons.rttex|https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=RV5RH3PVCPUR8&custom=40890790|0|5|0||||-1|-1||-1|-1|`2You Get:`` 45,000 Gems.<CR><CR>`5Description:`` Get a chest containing gems.|1||||||0|\nadd_button|gems_bag|Bag o' Gems|interface/large/store_buttons/store_buttons.rttex|https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=E9GPTE453VRJU&custom=40890790|1|0|0||||-1|-1||-1|-1|`2You Get:`` 20,000 Gems.<CR><CR>`5Description:`` Get a small bag of gems.|1||||||0|\nadd_banner|interface/large/gui_shop_featured_header.rttex|0|3|\nadd_button|365d|`o1-Year Subscription Token``|interface/large/store_buttons/store_buttons28.rttex|https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=D97REZNZPDHQE&custom=40890790|0|0|0||||-1|-1||-1|-1|`2You Get:`` 1x 1-Year Subscription Token and 25 Growtokens.<CR><CR>`5Description:`` One full year of special treatment AND 25 Growtokens upfront! You'll get 70 season tokens (as long as there's a seasonal clash running), and 2500 gems every day and a chance of doubling any XP earned, growtime reduction on all seeds planted and Exclusive Skins!|1||||||0|\nadd_button|30d|`o30-Day Subscription Token``|interface/large/store_buttons/store_buttons28.rttex|https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=4Q4C2LPWSPQCC&custom=40890790|0|1|0||||-1|-1||-1|-1|`2You Get:`` 1x 30-Day Free Subscription Token and 2 Growtokens.<CR><CR>`5Description:`` 30 full days of special treatment AND 2 Growtokens upfront! You'll get 70 season tokens (as long as there's a seasonal clash running), and 2500 gems every day and a chance of doubling any XP earned, growtime reduction on all seeds planted and Exclusive Skins!|1||||||0|"));
													ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
													enet_peer_send(peer, 0, packet);
													delete p.data;
												}
												break;
											}
											if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "friends_guilds") SocialPortalDialog = true;
											if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "guildsignup") registerguild = true;
											if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "store_sell_confirm") {
												if (pData->laststoreselldiamondlocks == 0 && pData->laststoresellworldlocks == 0 || pData->laststoresellid == 0 || pData->laststoresellcount == 0) break;
												int diamondlocks = pData->laststoreselldiamondlocks;
												int worldlocks = pData->laststoresellworldlocks;
												int sell_id = pData->laststoresellid;
												int sell_count = pData->laststoresellcount;
												auto contains = false;
												SearchInventoryItem(peer, sell_id, sell_count, contains);
												if (!contains) {
													Player::OnTalkBubble(peer, pData->netID, "You Don't have " + to_string(sell_count) + " of " + getItemDef(sell_id).name + " to sell!", 0, true);
													break;
												}
												RemoveInventoryItem(sell_id, sell_count, peer, true);
												updateplayerset(peer, sell_id);
												if (diamondlocks != 0) {
													auto success = true;
													SaveItemMoreTimes(1796, diamondlocks, peer, success);
												} if (worldlocks != 0) {
													auto success = true;
													SaveItemMoreTimes(242, worldlocks, peer, success);
												}
												int kaina_wls = diamondlocks * 100 + worldlocks;
												Player::OnConsoleMessage(peer, "`oSold " + to_string(sell_count) + " `o" + getItemDef(sell_id).name + " `ofor `o" + to_string(kaina_wls) + " `oWorld locks");
												Player::OnTalkBubble(peer, pData->netID, "Sold " + to_string(sell_count) + " " + getItemDef(sell_id).name + " for " + to_string(kaina_wls) + " World locks", 0, true);
												if (diamondlocks != 0) SendTradeEffect(peer, 1796, pData->netID, pData->netID, 150);
												if (worldlocks != 0) SendTradeEffect(peer, 242, pData->netID, pData->netID, 150);
												Player::PlayAudio(peer, "audio/cash_register.wav", 0);
												break;
											}
											if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "store_buy_confirm") {
												if (pData->laststorebuyprice == 0 || pData->laststorebuyid == 0 || pData->laststorebuycount == 0) break;
												int kaina_wls = pData->laststorebuyprice;
												int item_id = pData->laststorebuyid;
												int kiek_turi_kainoti = pData->laststorebuycount;
												if (item_id == 9498 || item_id == 5154 || item_id == 5140 || item_id == 5138 || item_id == 5136 || item_id == 7382 || item_id == 4762) {
													kiek_turi_kainoti = rand() % 51 + 150;
												}
												int diamond_lock = 0, world_lock = 0, blue_gem_lock = 0, grazinti_wl = 0;
												int is_viso_worldlock = kaina_wls;
												while (is_viso_worldlock >= 100) {
													is_viso_worldlock -= 100;
													diamond_lock++;
												}
												world_lock = is_viso_worldlock;
												int turi_world_lock = atoi(GetItemCount(peer, 242).c_str());
												int turi_diamond_lock = atoi(GetItemCount(peer, 1796).c_str());
												while (diamond_lock > turi_diamond_lock && turi_world_lock >= 100) {
													turi_diamond_lock++;
													turi_world_lock -= 100;
												} if (diamond_lock > turi_diamond_lock) {
													Player::OnTalkBubble(peer, pData->netID, "You can't afford that many!", 0, true);
													break;
												} while (world_lock > turi_world_lock && turi_diamond_lock >= 1) {
													turi_diamond_lock--;
													turi_world_lock += 100;
												} if (world_lock > turi_world_lock) {
													Player::OnTalkBubble(peer, pData->netID, "You can't afford that many!", 0, true);
													break;
												}
												turi_world_lock -= world_lock;
												turi_diamond_lock -= diamond_lock;
												RemoveInventoryItem(242, atoi(GetItemCount(peer, 242).c_str()), peer, true);
												RemoveInventoryItem(1796, atoi(GetItemCount(peer, 1796).c_str()), peer, true);
												auto success = true;
												SaveItemMoreTimes(242, turi_world_lock, peer, success);
												SaveItemMoreTimes(1796, turi_diamond_lock, peer, success);
												Player::OnConsoleMessage(peer, "`oPurchased " + to_string(kiek_turi_kainoti) + " `o" + getItemDef(item_id).name + " `ofor `o" + to_string(kaina_wls) + " `oWorld locks");
												Player::OnTalkBubble(peer, pData->netID, "Purchased " + to_string(kiek_turi_kainoti) + " " + getItemDef(item_id).name + " for " + to_string(kaina_wls) + " World locks", 0, true);
												SendTradeEffect(peer, item_id, pData->netID, pData->netID, 150);
												Player::PlayAudio(peer, "audio/cash_register.wav", 0);
												SaveItemMoreTimes(item_id, kiek_turi_kainoti, peer, success);
												try {
													int kiek_pirko = 0;
													ifstream infile("price_data.txt");
													for (string line; getline(infile, line);) {
														if (line.length() > 3 && line.at(0) != '/' && line.at(1) != '/') {
															auto ex = explode("|", line);
															if (ex.at(0) == to_string(item_id)) {
																kiek_pirko = atoi(ex.at(2).c_str());
																break;
															}
														}
													}
													infile.close();
													string strReplace = to_string(item_id) + "|" + to_string(kiek_turi_kainoti) + "|" + to_string(kiek_pirko);
													kiek_pirko += kiek_turi_kainoti;
													string strNew = to_string(item_id) + "|" + to_string(kiek_turi_kainoti) + "|" + to_string(kiek_pirko);
													ifstream filein("price_data.txt"); 
													ofstream fileout("price_data_backup.txt"); 
													if (!filein || !fileout) {
														SendConsole("Filesystem Exception #39 Failed to update file", "ERROR");
														return 1;
													}
													string strTemp;
													while (filein >> strTemp) {
														if (strTemp == strReplace) {
															strTemp = strNew;
														}
														strTemp += "\n";
														fileout << strTemp;
													}
													filein.close();
													fileout.close();
													char oldname[] = "price_data_backup.txt";
													char newname[] = "price_data.txt";
													remove("price_data.txt");
													if (rename(oldname, newname) != 0) {
														SendConsole("Filesystem Exception #39 Failed to rename file", "ERROR");
													}
													remove("price_data_backup.txt");
												}
												catch(const std::out_of_range& e) {
													std::cout << e.what() << std::endl;
												}
												break;
											}
											if (infoDat.at(0) == "dialog_name" && infoDat.at(1) == "trade_add") isTradeDialog = true;
											if (blacklistPanelDialog) {
												if (!isMod(peer)) break;

												bool blacklistip = true;
												bool blacklistdevice = false;

												if (infoDat.at(0) == "blacklist_ip") {
													if (infoDat.at(1) == "0") {
														blacklistip = true;
													}
													else
													{
														blacklistip = false;
													}
												}

												if (infoDat.at(0) == "blacklist_device") {
													if (infoDat.at(1) == "0") {
														blacklistdevice = true;
													}
													else
													{
														blacklistdevice = false;
													}
												}

												if (infoDat.at(0) == "reason") {
													string reason = infoDat.at(1);
													pData->last_ban_reason = reason;
													if (reason.size() == 0) {
														send_blacklist_panel(peer, "`4Error occured: You must enter the reason!");
														break;
													}
													else if (reason.size() >= 90) {
														send_blacklist_panel(peer, "`4Error occured: Reason is too long!");
														break;
													}
													try {
														ifstream read_player("save/players/_" + pData->lastInfo + ".json");
														if (!read_player.is_open()) {
															continue;
														}
														json j;
														read_player >> j;
														read_player.close();
														
														string signedip = j["ip"];
														string signedrid = j["rid"];
														string signedsid = j["sid"];

														if (blacklistip == true) {
															for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
																if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == pData->lastInfo) {
																	Player::OnAddNotification(currentPeer, "`wYour Account IP has been blacklisted by " + static_cast<PlayerInfo*>(peer->data)->rawName + "!", "audio/hub_open.wav", "interface/cash_icon_overlay.rttex");
																	enet_peer_disconnect_later(currentPeer, 0);
																	blacklistedip.push_back(signedip);
																	Player::OnConsoleMessage(peer, "`oSuccessfully blacklisted " + pData->lastInfo + " IP");
																	//successfully blacklistedd ip//
																}
															}
														}

														if (blacklistdevice == true) {
															for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
																if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == pData->lastInfo) {
																	Player::OnAddNotification(currentPeer, "`wYour Device has been blacklisted by " + static_cast<PlayerInfo*>(peer->data)->rawName + "!", "audio/hub_open.wav", "interface/cash_icon_overlay.rttex");
																	enet_peer_disconnect_later(currentPeer, 0);
																	blacklisteddevice.push_back(signedrid);
																	blacklisteddevice.push_back(signedsid);
																	Player::OnConsoleMessage(peer, "`oSuccessfully blacklisted " + pData->lastInfo + " Device");
																	//successfully blacklistedd ip//
																}
															}
														}
														
														if (blacklistip == true && blacklistdevice == true) {
															for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
																if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == pData->lastInfo) {
																	Player::OnAddNotification(currentPeer, "`wYour Device has been blacklisted by " + static_cast<PlayerInfo*>(peer->data)->rawName + "!", "audio/hub_open.wav", "interface/cash_icon_overlay.rttex");
																	enet_peer_disconnect_later(currentPeer, 0);
																	blacklisteddevice.push_back(signedrid);
																	blacklistedip.push_back(signedip);
																	blacklisteddevice.push_back(signedsid);
																	Player::OnConsoleMessage(peer, "`oSuccessfully blacklisted " + pData->lastInfo + " Device");
																	//successfully blacklistedd ip//
																}
															}
														}
													}
													catch (std::exception& e) {
														std::cout << e.what() << std::endl;
														continue;
													}
													string userdisplay = "";
													for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
														if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
														if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == pData->lastInfo) {
															userdisplay = static_cast<PlayerInfo*>(currentPeer->data)->displayName;
														}
													} if (userdisplay == "") userdisplay = pData->lastInfo;
													for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
														if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
														Player::OnConsoleMessage(currentPeer, "`#** `$The Ancients `ohave used `#Blacklist `oon `w" + userdisplay + "`o! `#**");
													}
												}
											}
											if (mutePanelDialog) {
												if (!isMod(peer)) break;
												if (infoDat.at(0) == "days") {
													b_days = atoi(infoDat.at(1).c_str());
													pData->last_ban_days = atoi(infoDat.at(1).c_str());
													if (b_days < 0) {
														send_mute_panel(peer, "`4Error occured: Days cannot be negative!");
														break;
													}
												}
												if (infoDat.at(0) == "hours") {
													b_hours = atoi(infoDat.at(1).c_str());
													pData->last_ban_hours = atoi(infoDat.at(1).c_str());
													if (b_hours < 0) {
														send_mute_panel(peer, "`4Error occured: Hours cannot be negative!");
														break;
													}
												}
												if (infoDat.at(0) == "minutes") {
													b_minutes = atoi(infoDat.at(1).c_str());
													pData->last_ban_minutes = atoi(infoDat.at(1).c_str());
													if (b_minutes < 0) {
														send_mute_panel(peer, "`4Error occured: Minutes cannot be negative!");
														break;
													}
												}
												if (infoDat.at(0) == "reason") {
													string reason = infoDat.at(1);
													pData->last_ban_reason = reason;
													if (b_days == 0 && b_hours == 0 && b_minutes == 0) {
														send_mute_panel(peer, "`4Error occured: Ban length is 0!");
														break;
													}
													else if (reason.size() == 0) {
														send_mute_panel(peer, "`4Error occured: You must enter the reason!");
														break;
													}
													else if (reason.size() >= 90) {
														send_mute_panel(peer, "`4Error occured: Reason is too long!");
														break;
													}
													/*success*/
													int konvertuotasInt = (b_minutes * 60) + (b_hours * 60 * 60) + (b_days * 24 * 60 * 60);
													try {
														ifstream read_player("save/players/_" + pData->lastInfo + ".json");
														if (!read_player.is_open()) {
															continue;
														}
														json j;
														read_player >> j;
														read_player.close();
														j["timemuted"] = (GetCurrentTimeInternalSeconds() + (static_cast<long long>(konvertuotasInt)));
														Player::OnTextOverlay(peer, OutputBanTime(konvertuotasInt) + "Mute mod applied to " + pData->lastInfo + "!");
														ofstream write_player("save/players/_" + pData->lastInfo + ".json");
														write_player << j << std::endl;
														write_player.close();
														ofstream spawnLog("save/logs/mute.txt", ios::app);
														spawnLog << "Administrator " << static_cast<PlayerInfo*>(peer->data)->rawName << " used /mute on " << pData->lastInfo << " " << to_string(konvertuotasInt) << " " << reason << endl;
														spawnLog.close();
													}
													catch (std::exception& e) {
														std::cout << e.what() << std::endl;
														continue;
													}
													string userdisplay = "";
													for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
														if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
														if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == pData->lastInfo) {
															userdisplay = static_cast<PlayerInfo*>(currentPeer->data)->displayName;
														}
													} if (userdisplay == "") userdisplay = pData->lastInfo;
													for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
														if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
														Player::OnConsoleMessage(currentPeer, "`#** `$The Ancients `ohave used `#Mute `oon `w" + userdisplay + "`o! `#**");
														if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == pData->lastInfo) {
															Player::OnAddNotification(currentPeer, "`wWarning from `4System`w: You've been `4MUTED `wfor " + OutputBanTime(konvertuotasInt) + "", "audio/hub_open.wav", "interface/atomic_button.rttex");
															Player::OnConsoleMessage(currentPeer, "`wWarning from `4System`w: You've been `4MUTED `wfor " + OutputBanTime(konvertuotasInt) + "");
															static_cast<PlayerInfo*>(currentPeer->data)->taped = true;
															static_cast<PlayerInfo*>(currentPeer->data)->isDuctaped = true;
															static_cast<PlayerInfo*>(currentPeer->data)->cantsay = true;
															static_cast<PlayerInfo*>(currentPeer->data)->lastMuted = (GetCurrentTimeInternalSeconds()) + (static_cast<long long>(konvertuotasInt) * 60);
															send_state(currentPeer);
															sendClothes(currentPeer);
														}
													}
													LogAccountActivity(pData->rawName, pData->lastInfo, "Mute for " + OutputBanTime(konvertuotasInt) + "(" + reason + ")");
													//SendPunishView(peer, pData->lastInfo);
												}
											}
											if (cursePanelDialog) {
												if (!isMod(peer)) break;
												if (infoDat.at(0) == "days") {
													b_days = atoi(infoDat.at(1).c_str());
													pData->last_ban_days = atoi(infoDat.at(1).c_str());
													if (b_days < 0) {
														send_curse_panel(peer, "`4Error occured: Days cannot be negative!");
														break;
													}
												}
												if (infoDat.at(0) == "hours") {
													b_hours = atoi(infoDat.at(1).c_str());
													pData->last_ban_hours = atoi(infoDat.at(1).c_str());
													if (b_hours < 0) {
														send_curse_panel(peer, "`4Error occured: Hours cannot be negative!");
														break;
													}
												}
												if (infoDat.at(0) == "minutes") {
													b_minutes = atoi(infoDat.at(1).c_str());
													pData->last_ban_minutes = atoi(infoDat.at(1).c_str());
													if (b_minutes < 0) {
														send_curse_panel(peer, "`4Error occured: Minutes cannot be negative!");
														break;
													}
												}
												if (infoDat.at(0) == "reason") {
													string reason = infoDat.at(1);
													pData->last_ban_reason = reason;
													if (b_days == 0 && b_hours == 0 && b_minutes == 0) {
														send_curse_panel(peer, "`4Error occured: Ban length is 0!");
														break;
													}
													else if (reason.size() == 0) {
														send_curse_panel(peer, "`4Error occured: You must enter the reason!");
														break;
													}
													else if (reason.size() >= 90) {
														send_curse_panel(peer, "`4Error occured: Reason is too long!");
														break;
													}
													/*success*/
													int konvertuotasInt = (b_minutes * 60) + (b_hours * 60 * 60) + (b_days * 24 * 60 * 60);
													try {
														ifstream read_player("save/players/_" + pData->lastInfo + ".json");
														if (!read_player.is_open()) {
															continue;
														}
														json j;
														read_player >> j;
														read_player.close();
														j["timecursed"] = (GetCurrentTimeInternalSeconds() + (static_cast<long long>(konvertuotasInt)));
														Player::OnTextOverlay(peer, OutputBanTime(konvertuotasInt) + "Curse mod applied to " + pData->lastInfo + "!");
														ofstream write_player("save/players/_" + pData->lastInfo + ".json");
														write_player << j << std::endl;
														write_player.close();
														ofstream curselog("save/logs/curse.txt", ios::app);
														curselog << "Administrator " << static_cast<PlayerInfo*>(peer->data)->rawName << " used /curse on " << pData->lastInfo << " " << to_string(konvertuotasInt) << " " << reason << endl;
														curselog.close();
													}
													catch (std::exception& e) {
														std::cout << e.what() << std::endl;
														continue;
													}
													string userdisplay = "";
													for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
														if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
														if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == pData->lastInfo) {
															userdisplay = static_cast<PlayerInfo*>(currentPeer->data)->displayName;
														}
													} if (userdisplay == "") userdisplay = pData->lastInfo;
													for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
														if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
														Player::OnConsoleMessage(currentPeer, "`#** `$The Ancients `ohave used `#Curse `oon `w" + userdisplay + "`o! `#**");
														if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == pData->lastInfo) {
															Player::OnAddNotification(currentPeer, "`wWarning from `4System`w: You've been `4CURSED `wfor " + OutputBanTime(konvertuotasInt) + "", "audio/hub_open.wav", "interface/atomic_button.rttex");
															Player::OnConsoleMessage(currentPeer, "`wWarning from `4System`w: You've been `4CURSED `wfor " + OutputBanTime(konvertuotasInt) + "");
															static_cast<PlayerInfo*>(currentPeer->data)->isCursed = true;
															static_cast<PlayerInfo*>(currentPeer->data)->lastCursed = (GetCurrentTimeInternalSeconds() + (static_cast<long long>(konvertuotasInt) * 60));
															handle_world(currentPeer, "HELL");
														}
													}
													LogAccountActivity(pData->rawName, pData->lastInfo, "Curse for " + OutputBanTime(konvertuotasInt) + "(" + reason + ")");
													//SendPunishView(peer, pData->lastInfo);
												}
											}
											if (megaphone) {
												if (infoDat[0] == "sbtext")
												{
													sbtext = infoDat[1];
													GamePacket p;
													string worldname = static_cast<PlayerInfo*>(peer->data)->currentWorld;
													if (jammers) {
														for (auto i = 0; i < world->width * world->height; i++) {
															if (world->items.at(i).foreground == 226 && world->items.at(i).activated) {
																worldname = "`4JAMMED!";
																break;
															}
														}
													}
													p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "CP:0_PL:4_OID:CT:[SB] "));

													RemoveInventoryItem(2480, 1, peer, true);
													string text = "action|play_sfx\nfile|audio/beep.wav\ndelayMS|0\n";
													BYTE* data = new BYTE[5 + text.length()];
													BYTE zero = 0;
													int type = 3;
													memcpy(data, &type, 4);
													memcpy(data + 4, text.c_str(), text.length());
													memcpy(data + 4 + text.length(), &zero, 1);
													ENetPeer* currentPeer;
													for (currentPeer = server->peers;
														currentPeer < &server->peers[server->peerCount];
														++currentPeer)
													{
														if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
															continue;
														if (!((PlayerInfo*)(currentPeer->data))->radio)
															continue;
														ENetPacket* packet = enet_packet_create(p.data,
															p.len,
															ENET_PACKET_FLAG_RELIABLE);
														enet_peer_send(currentPeer, 0, packet);
														ENetPacket* packet2 = enet_packet_create(data,
															5 + text.length(),
															ENET_PACKET_FLAG_RELIABLE);
														enet_peer_send(currentPeer, 0, packet2);
													}
													delete data;
													delete p.data;
													Player::OnConsoleMessage(peer, "`o >>`5 Super-Broadcast `osent. `oUsed `$1 Megaphone.");
												}
											}
											if (banPanelDialog) {
												if (!isMod(peer)) break;
												if (infoDat.at(0) == "days") {
													b_days = atoi(infoDat.at(1).c_str());
													pData->last_ban_days = atoi(infoDat.at(1).c_str());
													if (b_days < 0) {
														send_ban_panel(peer, "`4Error occured: Days cannot be negative!");
														break;
													}
												}
												if (infoDat.at(0) == "hours") {
													b_hours = atoi(infoDat.at(1).c_str());
													pData->last_ban_hours = atoi(infoDat.at(1).c_str());
													if (b_hours < 0) {
														send_ban_panel(peer, "`4Error occured: Hours cannot be negative!");
														break;
													}
												}
												if (infoDat.at(0) == "minutes") {
													b_minutes = atoi(infoDat.at(1).c_str());
													pData->last_ban_minutes = atoi(infoDat.at(1).c_str());
													if (b_minutes < 0) {
														send_ban_panel(peer, "`4Error occured: Minutes cannot be negative!");
														break;
													}
												}
												if (infoDat.at(0) == "reason") {
													string reason = infoDat.at(1);
													pData->last_ban_reason = reason;
													if (b_days == 0 && b_hours == 0 && b_minutes == 0) {
														send_ban_panel(peer, "`4Error occured: Ban length is 0!");
														break;
													} else if (reason.size() == 0) {
														send_ban_panel(peer, "`4Error occured: You must enter the reason!");
														break;
													} else if (reason.size() >= 90) {
														send_ban_panel(peer, "`4Error occured: Reason is too long!");
														break;
													}
													/*success*/
													int konvertuotasInt = (b_minutes * 60)+(b_hours*60*60)+(b_days*24*60*60); 
													try {
														ifstream read_player("save/players/_" + pData->lastInfo + ".json");
														if (!read_player.is_open()) {
															continue;
														}
														json j;
														read_player >> j;
														read_player.close();
														if (konvertuotasInt >= 63072000) {
															j["isBanned"] = true;
															Player::OnTextOverlay(peer, "Permanent Ban mod applied to " + pData->lastInfo + "!");
															ofstream tolog("save/logs/wrench/panelban.txt", ios::app);
															tolog << "Administrator " << static_cast<PlayerInfo*>(peer->data)->rawName << " used ban panel wrench on " << pData->lastInfo << " with ban day : " << b_days << " and ban hours : " << b_hours << " and ban minutes : " << b_minutes << endl;
															tolog.close();
														} else {
															j["timebanned"] = (GetCurrentTimeInternalSeconds() + (static_cast<long long>(konvertuotasInt)));
															Player::OnTextOverlay(peer, OutputBanTime(konvertuotasInt) + "Ban mod applied to " + pData->lastInfo + "!");
															ofstream tolog("save/logs/wrench/panelban.txt", ios::app);
															tolog << "Administrator " << static_cast<PlayerInfo*>(peer->data)->rawName << " used ban panel wrench on " << pData->lastInfo << " with ban day : " << b_days << " and ban hours : " << b_hours << " and ban minutes : " << b_minutes << endl;
															tolog.close();
														}
														ofstream write_player("save/players/_" + pData->lastInfo + ".json");
														write_player << j << std::endl;
														write_player.close();
													} catch (std::exception& e) {
														std::cout << e.what() << std::endl;
														continue;
													}
													string userdisplay = "";
													for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
														if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
														if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == pData->lastInfo) {
															userdisplay = static_cast<PlayerInfo*>(currentPeer->data)->displayName;
														}
													} if (userdisplay == "") userdisplay = pData->lastInfo;
													for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
														if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
														Player::OnConsoleMessage(currentPeer, "`#** `$The Ancients `ohave used `#Ban `oon `w" + userdisplay + "`o! `#**");
														if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == pData->lastInfo) {
															Player::OnAddNotification(currentPeer, "`wWarning from `4System`w: You've been `4BANNED `wfor " + OutputBanTime(konvertuotasInt) + "", "audio/hub_open.wav", "interface/atomic_button.rttex");
															Player::OnConsoleMessage(currentPeer, "`wWarning from `4System`w: You've been `4BANNED `wfor " + OutputBanTime(konvertuotasInt) + "");
															enet_peer_disconnect_later(currentPeer, 0);
														}
													}
													LogAccountActivity(pData->rawName, pData->lastInfo, "Ban for " + OutputBanTime(konvertuotasInt) + "(" + reason + ")");
													//SendPunishView(peer, pData->lastInfo);
												}
											}
											if (isTradeDialog) {
												if (infoDat.at(0).substr(0, 6) == "count_") {
													int trade_count = atoi(infoDat.at(1).c_str());
													int trade_item = atoi(infoDat.at(0).substr(infoDat.at(0).find("_") + 1).c_str());
													if (trade_item <= 0 || trade_count <= 0) break;
													//if (!pData->trade) continue;
													if (pData->tradeItems.size() >= 4) continue;
													auto contains = false;
													SearchInventoryItem(peer, trade_item, trade_count, contains);
													if (!contains) break;
													int i = 0;
													for (i = 0; i < pData->tradeItems.size(); i++) {
														if (pData->tradeItems.at(i).id == trade_item) {
															pData->tradeItems.erase(pData->tradeItems.begin() + i);
															break;
														}
													}
													TradeItem trdItem = { trade_item, trade_count };
													pData->tradeItems.push_back(trdItem);
													update_trade(peer, pData->trade_netid);
													break;
												}
											}											
											if (tradeConfirmDialog) {
												if (infoDat.at(1) == "back") {
													if (pData->trade) end_trade(peer, true);
													break;
												}
												if (infoDat.at(1) == "accept") {
													if (!pData->trade) {
														Player::OnTextOverlay(peer, "The other person left the trade!");
														break;
													}
													pData->trade_confirmed = true;
													for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
														if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
														if (isHere(peer, currentPeer)) {
															if (static_cast<PlayerInfo*>(currentPeer->data)->netID == pData->trade_netid) {
																if (static_cast<PlayerInfo*>(currentPeer->data)->trade_confirmed && pData->trade_confirmed) {
																	bool full_inv = false;
																	int which_item = 0;
																	if (static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + static_cast<PlayerInfo*>(currentPeer->data)->tradeItems.size() >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize) {
																		Player::OnTextOverlay(peer, "`w" + static_cast<PlayerInfo*>(peer->data)->displayName + "`w needs more backpack room first!");
																		Player::OnTextOverlay(currentPeer, "`w" + static_cast<PlayerInfo*>(peer->data)->displayName + "`w needs more backpack room first!");
																		pData->trade_accept = false;
																		static_cast<PlayerInfo*>(currentPeer->data)->trade_accept = false;
																		UpdateTradeAcceptedStatus(peer);
																		UpdateTradeAcceptedStatus(currentPeer);
																		break;
																	}
																	for (auto& f : static_cast<PlayerInfo*>(currentPeer->data)->tradeItems) {
																		if (CheckItemMaxed(peer, f.id, f.count) || pData->inventory.items.size() + 1 >= pData->currentInventorySize && CheckItemExists(peer, f.id) && CheckItemMaxed(peer, f.id, f.count) || pData->inventory.items.size() + 1 >= pData->currentInventorySize && !CheckItemExists(peer, f.id)) {
																			full_inv = true;
																			which_item = f.id;
																			break;
																		}
																	}
																	if (full_inv) {
																		Player::OnTextOverlay(currentPeer, "`4Oops - " + pData->displayName + " `4is carrying too many " + getItemDef(which_item).name + " and can't fit that many in their backpack.");
																		Player::OnTextOverlay(peer, "`4Oops - " + pData->displayName + " `4is carrying too many " + getItemDef(which_item).name + " and can't fit that many in their backpack.");
																		break;
																	}
																	full_inv = false;
																	if (static_cast<PlayerInfo*>(currentPeer->data)->inventory.items.size() + static_cast<PlayerInfo*>(peer->data)->tradeItems.size() >= static_cast<PlayerInfo*>(currentPeer->data)->currentInventorySize) {
																		Player::OnTextOverlay(peer, "`w" + static_cast<PlayerInfo*>(currentPeer->data)->displayName + "`w needs more backpack room first!");
																		Player::OnTextOverlay(currentPeer, "`w" + static_cast<PlayerInfo*>(currentPeer->data)->displayName + "`w needs more backpack room first!");
																		pData->trade_accept = false;
																		static_cast<PlayerInfo*>(currentPeer->data)->trade_accept = false;
																		UpdateTradeAcceptedStatus(peer);
																		UpdateTradeAcceptedStatus(currentPeer);
																		break;
																	}
																	for (auto& f : static_cast<PlayerInfo*>(peer->data)->tradeItems) {
																		if (CheckItemMaxed(currentPeer, f.id, f.count) || static_cast<PlayerInfo*>(currentPeer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(currentPeer->data)->currentInventorySize && CheckItemExists(currentPeer, f.id) && CheckItemMaxed(currentPeer, f.id, f.count) || static_cast<PlayerInfo*>(currentPeer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(currentPeer->data)->currentInventorySize && !CheckItemExists(currentPeer, f.id)) {
																			full_inv = true;
																			which_item = f.id;
																			break;
																		}
																	}
																	if (full_inv) {
																		Player::OnTextOverlay(peer, "`4Oops - " + static_cast<PlayerInfo*>(currentPeer->data)->displayName + " `4is carrying too many " + getItemDef(which_item).name + " and can't fit that many in their backpack.");
																		Player::OnTextOverlay(currentPeer, "`4Oops - " + static_cast<PlayerInfo*>(currentPeer->data)->displayName + " `4is carrying too many " + getItemDef(which_item).name + " and can't fit that many in their backpack.");
																		break;
																	}
																	if (isMod(peer)) LogAccountActivity(static_cast<PlayerInfo*>(currentPeer->data)->rawName, pData->rawName, "Traded " + FormatTradeItemsForMessage(static_cast<PlayerInfo*>(peer->data)->tradeItems) + " (" + world->name + ")");
																	if (isMod(currentPeer)) LogAccountActivity(static_cast<PlayerInfo*>(peer->data)->rawName, static_cast<PlayerInfo*>(currentPeer->data)->rawName, "Traded " + FormatTradeItemsForMessage(static_cast<PlayerInfo*>(currentPeer->data)->tradeItems) + " (" + world->name + ")");
																	//trade logs
																	ofstream baniplog("save/tradelogs/_" + static_cast<PlayerInfo*>(currentPeer->data)->rawName + ".txt", ios::app);
																	baniplog << static_cast<PlayerInfo*>(currentPeer->data)->rawName << " Traded " << FormatTradeItemsForMessage(static_cast<PlayerInfo*>(peer->data)->tradeItems) << "to" << static_cast<PlayerInfo*>(peer->data)->rawName << " " << endl;
																	baniplog.close();
																	//logs player 2
																	ofstream baniplogs("save/tradelogs/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt", ios::app);
																	baniplogs << static_cast<PlayerInfo*>(peer->data)->rawName << " Traded " << FormatTradeItemsForMessage(pData->tradeItems) << "to" << static_cast<PlayerInfo*>(currentPeer->data)->rawName << " " << endl;
																	baniplogs.close();
																	//trade logs
																	for (ENetPeer* currentPeer2 = server->peers; currentPeer2 < &server->peers[server->peerCount]; ++currentPeer2) {
																		if (currentPeer2->state != ENET_PEER_STATE_CONNECTED) continue;
																		if (isHere(peer, currentPeer2)) {
																			Player::OnConsoleMessage(currentPeer2, "`1" + static_cast<PlayerInfo*>(currentPeer->data)->displayName + " `1traded " + FormatTradeItemsForMessage(static_cast<PlayerInfo*>(currentPeer->data)->tradeItems) + " to " + pData->displayName + ".``");
																			//Player::OnConsoleMessage(currentPeer2, "`1" + pData->displayName + " `1traded " + FormatTradeItemsForMessage(pData->tradeItems) + " to " + static_cast<PlayerInfo*>(currentPeer->data)->displayName + ".``");
																			//Player::OnConsoleMessage(currentPeer2, "`1" + static_cast<PlayerInfo*>(currentPeer->data)->displayName + " `1traded " + FormatTradeItemsForMessage(static_cast<PlayerInfo*>(currentPeer->data)->tradeItems) + " to " + pData->displayName + ".``");
																			Player::OnConsoleMessage(currentPeer2, "`1" + pData->displayName + " `1traded " + FormatTradeItemsForMessage(pData->tradeItems) + " to " + static_cast<PlayerInfo*>(currentPeer->data)->displayName + ".``");
																			Player::PlayAudio(currentPeer2, "audio/keypad_hit.wav", 0);
																			//Player::PlayAudio(currentPeer2, "audio/keypad_hit.wav", 0);
																		}
																	}
																	int duration = 500;
																	bool illegal_trade = false;
																	for (auto& f : static_cast<PlayerInfo*>(currentPeer->data)->tradeItems) {
																		auto contains = false;
																		SearchInventoryItem(currentPeer, f.id, f.count, contains);
																		if (!contains) {
																			illegal_trade = true;
																			break;
																		}
																		RemoveInventoryItem(f.id, f.count, currentPeer, true);
																		if (f.id == 1424) { /*worldtrade*/
																			for (ENetPeer* currentPeer2 = server->peers; currentPeer2 < &server->peers[server->peerCount]; ++currentPeer2) {
																				if (currentPeer2->state != ENET_PEER_STATE_CONNECTED) continue;
																				if (isHere(peer, currentPeer2)) {
																					Player::OnTalkBubble(currentPeer2, pData->netID, "`5[```w" + world->name + "`` has been `$World Locked`` by " + static_cast<PlayerInfo*>(peer->data)->displayName + "`5]``", 0, false);
																					Player::OnConsoleMessage(currentPeer2, "`5[```w" + world->name + "`` has been `$World Locked`` by " + static_cast<PlayerInfo*>(peer->data)->displayName + "`5]``");
																					Player::PlayAudio(currentPeer2, "audio/use_lock.wav", 0);
																				}
																			}
																			static_cast<PlayerInfo*>(currentPeer->data)->worldsowned.erase(std::remove(static_cast<PlayerInfo*>(currentPeer->data)->worldsowned.begin(), static_cast<PlayerInfo*>(currentPeer->data)->worldsowned.end(), static_cast<PlayerInfo*>(currentPeer->data)->currentWorld), static_cast<PlayerInfo*>(currentPeer->data)->worldsowned.end());
																			world->owner = pData->rawName;
																			pData->worldsowned.push_back(pData->currentWorld);
																			if (static_cast<PlayerInfo*>(currentPeer->data)->NickPrefix == "") updateworldremove(currentPeer);
																			if (pData->displayName.find("`") == string::npos) {
																				pData->displayName = "`2" + pData->displayName;
																				Player::OnNameChanged(peer, pData->netID, pData->displayName);
																			}
																			/*if (world->category == "Guild") {
																				if (static_cast<PlayerInfo*>(currentPeer->data)->guild == world->worldGuild) {
																					try {
																						std::ifstream ifff("save/guilds/_" + PlayerDB::getProperName(world->worldGuild) + ".json");
																						if (ifff.fail()) {
																							ifff.close();
																							Player::OnConsoleMessage(peer, "`4Error: `oGuild does not exist! If you are seeing this message, please take a screenshot and send it to a developer!");
																							continue;
																						}
																						json j;
																						ifff >> j; //load
																						ifff.close();
																						vector <string> Leader;
																						vector <string> gmlist;
																						for (int i = 0; i < j["Leader"].size(); i++) {
																							Leader.push_back(j["Leader"][i]);
																						}
																						for (int i = 0; i < j["Member"].size(); i++) {
																							gmlist.push_back(j["Member"][i]);
																						}
																						if (find(Leader.begin(), Leader.end(), static_cast<PlayerInfo*>(currentPeer->data)->rawName) != Leader.end()) {
																							Leader.erase(std::remove(Leader.begin(), Leader.end(), static_cast<PlayerInfo*>(currentPeer->data)->rawName), Leader.end());
																						}
																						if (find(gmlist.begin(), gmlist.end(), static_cast<PlayerInfo*>(currentPeer->data)->rawName) != gmlist.end()) {
																							gmlist.erase(std::remove(gmlist.begin(), gmlist.end(), static_cast<PlayerInfo*>(currentPeer->data)->rawName), gmlist.end());
																						}
																						gmlist.push_back(static_cast<PlayerInfo*>(peer->data)->rawName);
																						Leader.push_back(static_cast<PlayerInfo*>(peer->data)->rawName);
																						j["Leader"] = Leader; //edit
																						j["Member"] = gmlist; //edit
																						ofstream write_guilds("save/guilds/_" + PlayerDB::getProperName(static_cast<PlayerInfo*>(peer->data)->guild) + ".json");
																						write_guilds << j << std::endl;
																						write_guilds.close();
																						((PlayerInfo*)(currentPeer->data))->guildBg = 0;
																						((PlayerInfo*)(currentPeer->data))->guildFg = 0;
																						((PlayerInfo*)(currentPeer->data))->guildLeader = "";
																						((PlayerInfo*)(currentPeer->data))->guild = "";
																						((PlayerInfo*)(currentPeer->data))->guildStatement = "";
																						((PlayerInfo*)(currentPeer->data))->guildlast = "";
																						((PlayerInfo*)(currentPeer->data))->lastgm = "";
																						((PlayerInfo*)(currentPeer->data))->lastgmname = "";
																						((PlayerInfo*)(currentPeer->data))->joinguild = false;
																						((PlayerInfo*)(currentPeer->data))->lastgmworld = "";
																						((PlayerInfo*)(currentPeer->data))->guildMembers.clear();
																						static_cast<PlayerInfo*>(peer->data)->guild = world->worldGuild;
																						static_cast<PlayerInfo*>(peer->data)->joinguild = true;
																						string oldLeader = static_cast<PlayerInfo*>(currentPeer->data)->rawName;
																						string newLeader = static_cast<PlayerInfo*>(peer->data)->rawName;
																						string name2;
																						string namemsg = static_cast<PlayerInfo*>(peer->data)->rawName;
																						if (static_cast<PlayerInfo*>(peer->data)->adminLevel != 0) {
																							name2 = role_prefix.at(static_cast<PlayerInfo*>(peer->data)->adminLevel) + static_cast<PlayerInfo*>(peer->data)->tankIDName + " `e(GL)``";
																						}
																						else
																						{
																							name2 = "`w" + static_cast<PlayerInfo*>(peer->data)->tankIDName + " `e(GL)";
																						}
																						restore_player_name(world, currentPeer);
																						static_cast<PlayerInfo*>(peer->data)->displayName = name2;
																						static_cast<PlayerInfo*>(peer->data)->msgName = namemsg;
																						static_cast<PlayerInfo*>(peer->data)->guildFg = atoi(static_cast<PlayerInfo*>(currentPeer->data)->createGuildFlagFg.c_str());
																						static_cast<PlayerInfo*>(peer->data)->guildBg = atoi(static_cast<PlayerInfo*>(currentPeer->data)->createGuildFlagBg.c_str());
																						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																							if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
																							if (((PlayerInfo*)(currentPeer->data))->guild == world->worldGuild) {
																								Player::OnConsoleMessage(currentPeer, "`5[GUILD ALERT] `2" + oldLeader + "`o has sold the guild to " + newLeader + "!");
																							}

																							if (isHere(peer, currentPeer)) {
																								Player::OnNameChanged(currentPeer, static_cast<PlayerInfo*>(peer->data)->netID, name2);
																							}
																						}
																						updateInvis(peer);
																						updateInvis(currentPeer);
																					}
																					catch (std::exception& e) {
																						std::cout << e.what() << std::endl;
																					}
																					catch (const std::out_of_range& e) {
																						std::cout << e.what() << std::endl;
																					}
																				}
																			}*/
																			for (int i = 0; i < world->width * world->height; i++) {
																				if (getItemDef(world->items.at(i).foreground).blockType == BlockTypes::LOCK) {
																					if (world->items.at(i).foreground == 202 || world->items.at(i).foreground == 204 || world->items.at(i).foreground == 206 || world->items.at(i).foreground == 4994) continue;
																					PlayerMoving moving{};
																					moving.packetType = 0x3;
																					moving.characterState = 0x0;
																					moving.x = i % world->width;
																					moving.y = i / world->width;
																					moving.punchX = i % world->width;
																					moving.punchY = i / world->width;
																					moving.XSpeed = 0;
																					moving.YSpeed = 0;
																					moving.netID = -1;
																					moving.plantingTree = world->items.at(i).foreground;
																					SendPacketRaw(4, packPlayerMoving(&moving), 56, nullptr, currentPeer, ENET_PACKET_FLAG_RELIABLE);
																					send_tile_data(peer, i % world->width, i / world->width, 0x10, world->items.at(i).foreground, world->items.at(i).background, lock_tile_datas(0x20, pData->netID, 0, 0, true, 100));
																					if (world->items.at(i).foreground == 4802) {
																						for (ENetPeer* currentPeer2 = server->peers; currentPeer2 < &server->peers[server->peerCount]; ++currentPeer2) {
																							if (currentPeer2->state != ENET_PEER_STATE_CONNECTED) continue;
																							if (isHere(peer, currentPeer2)) {
																								send_rainbow_shit_data(currentPeer2, world->items.at(i).foreground, world->items.at(i).background, i % world->width, i / world->width, false, -1);
																							}
																						}
																						for (ENetPeer* currentPeer2 = server->peers; currentPeer2 < &server->peers[server->peerCount]; ++currentPeer2) {
																							if (currentPeer2->state != ENET_PEER_STATE_CONNECTED) continue;
																							if (isHere(peer, currentPeer2)) {
																								send_rainbow_shit_data(currentPeer2, world->items.at(i).foreground, world->items.at(i).background, i % world->width, i / world->width, true, pData->netID);
																							}
																						}
																					}
																					break;
																				}
																			}
																		}
																		else {
																			updateplayerset(currentPeer, f.id);
																			auto success = true;
																			SaveItemMoreTimes(f.id, f.count, peer, success);
																		}
																		for (ENetPeer* currentPeer2 = server->peers; currentPeer2 < &server->peers[server->peerCount]; ++currentPeer2) {
																			if (currentPeer2->state != ENET_PEER_STATE_CONNECTED) continue;
																			if (isHere(peer, currentPeer2)) {
																				Player::PlayAudio(currentPeer2, "audio/change_clothes.wav", duration);
																				SendTradeEffect(currentPeer2, f.id, static_cast<PlayerInfo*>(currentPeer->data)->netID, static_cast<PlayerInfo*>(peer->data)->netID, duration);

																			}
																		}
																		duration += 500;
																	} if (illegal_trade) {
																		end_trade(currentPeer);
																		break;
																	}
																	for (auto& f : static_cast<PlayerInfo*>(peer->data)->tradeItems) {
																		auto contains = false;
																		SearchInventoryItem(peer, f.id, f.count, contains);
																		if (!contains) {
																			illegal_trade = true;
																			break;
																		}
																		RemoveInventoryItem(f.id, f.count, peer, true);
																		if (f.id == 1424) { /*worldtrade*/
																			for (ENetPeer* currentPeer2 = server->peers; currentPeer2 < &server->peers[server->peerCount]; ++currentPeer2) {
																				if (currentPeer2->state != ENET_PEER_STATE_CONNECTED) continue;
																				if (isHere(peer, currentPeer2)) {
																					Player::OnTalkBubble(currentPeer2, pData->netID, "`5[```w" + world->name + "`` has been `$World Locked`` by " + static_cast<PlayerInfo*>(currentPeer->data)->displayName + "`5]``", 0, false);
																					Player::OnConsoleMessage(currentPeer2, "`5[```w" + world->name + "`` has been `$World Locked`` by " + static_cast<PlayerInfo*>(currentPeer->data)->displayName + "`5]``");
																					Player::PlayAudio(currentPeer2, "audio/use_lock.wav", 0);
																				}
																			}
																			pData->worldsowned.erase(std::remove(pData->worldsowned.begin(), pData->worldsowned.end(), pData->currentWorld), pData->worldsowned.end());
																			world->owner = static_cast<PlayerInfo*>(currentPeer->data)->rawName;
																			static_cast<PlayerInfo*>(currentPeer->data)->worldsowned.push_back(static_cast<PlayerInfo*>(currentPeer->data)->currentWorld);
																			if (pData->NickPrefix == "") updateworldremove(peer);
																			if (static_cast<PlayerInfo*>(currentPeer->data)->displayName.find("`") != string::npos) {}
																			else {
																				static_cast<PlayerInfo*>(currentPeer->data)->displayName = "`2" + static_cast<PlayerInfo*>(currentPeer->data)->displayName;
																				Player::OnNameChanged(currentPeer, static_cast<PlayerInfo*>(currentPeer->data)->netID, static_cast<PlayerInfo*>(currentPeer->data)->displayName);
																			}
																			for (int i = 0; i < world->width * world->height; i++) {
																				if (getItemDef(world->items.at(i).foreground).blockType == BlockTypes::LOCK) {
																					if (world->items.at(i).foreground == 202 || world->items.at(i).foreground == 204 || world->items.at(i).foreground == 206 || world->items.at(i).foreground == 4994) continue;
																					PlayerMoving moving{};
																					moving.packetType = 0x3;
																					moving.characterState = 0x0;
																					moving.x = i % world->width;
																					moving.y = i / world->width;
																					moving.punchX = i % world->width;
																					moving.punchY = i / world->width;
																					moving.XSpeed = 0;
																					moving.YSpeed = 0;
																					moving.netID = -1;
																					moving.plantingTree = world->items.at(i).foreground;
																					SendPacketRaw(4, packPlayerMoving(&moving), 56, nullptr, peer, ENET_PACKET_FLAG_RELIABLE);
																					send_tile_data(currentPeer, i % world->width, i / world->width, 0x10, world->items.at(i).foreground, world->items.at(i).background, lock_tile_datas(0x20, static_cast<PlayerInfo*>(currentPeer->data)->netID, 0, 0, true, 100));
																					if (world->items.at(i).foreground == 4802) {
																						for (ENetPeer* currentPeer2 = server->peers; currentPeer2 < &server->peers[server->peerCount]; ++currentPeer2) {
																							if (currentPeer2->state != ENET_PEER_STATE_CONNECTED) continue;
																							if (isHere(peer, currentPeer2)) {
																								send_rainbow_shit_data(currentPeer2, world->items.at(i).foreground, world->items.at(i).background, i % world->width, i / world->width, false, -1);
																							}
																						}
																						for (ENetPeer* currentPeer2 = server->peers; currentPeer2 < &server->peers[server->peerCount]; ++currentPeer2) {
																							if (currentPeer2->state != ENET_PEER_STATE_CONNECTED) continue;
																							if (isHere(peer, currentPeer2)) {
																								send_rainbow_shit_data(currentPeer2, world->items.at(i).foreground, world->items.at(i).background, i % world->width, i / world->width, true, static_cast<PlayerInfo*>(currentPeer->data)->netID);
																							}
																						}
																					}
																					break;
																				}
																			}
																		} else {
																			updateplayerset(peer, f.id);
																			auto success = true;
																			SaveItemMoreTimes(f.id, f.count, currentPeer, success);
																		}
																		for (ENetPeer* currentPeer2 = server->peers; currentPeer2 < &server->peers[server->peerCount]; ++currentPeer2) {
																			if (currentPeer2->state != ENET_PEER_STATE_CONNECTED) continue;
																			if (isHere(peer, currentPeer2)) {
																				Player::PlayAudio(currentPeer2, "audio/change_clothes.wav", duration);
																				SendTradeEffect(currentPeer2, f.id, static_cast<PlayerInfo*>(peer->data)->netID, static_cast<PlayerInfo*>(currentPeer->data)->netID, duration);

																			}
																		}
																		duration += 500;
																	} if (illegal_trade) {
																		end_trade(peer);
																		break;
																	}
																	static_cast<PlayerInfo*>(peer->data)->trade_netid = -1;
																	static_cast<PlayerInfo*>(peer->data)->trade = false;
																	static_cast<PlayerInfo*>(peer->data)->tradeItems.clear();
																	static_cast<PlayerInfo*>(peer->data)->trade_accept = false;
																	static_cast<PlayerInfo*>(peer->data)->trade_confirmed = false;
																	static_cast<PlayerInfo*>(currentPeer->data)->trade_netid = -1;
																	static_cast<PlayerInfo*>(currentPeer->data)->trade = false;
																	static_cast<PlayerInfo*>(currentPeer->data)->tradeItems.clear();
																	static_cast<PlayerInfo*>(currentPeer->data)->trade_accept = false;
																	static_cast<PlayerInfo*>(currentPeer->data)->trade_confirmed = false;
																}
																else if (!static_cast<PlayerInfo*>(currentPeer->data)->trade_confirmed) {
																	bool aha = false;
																	for (auto& f : static_cast<PlayerInfo*>(currentPeer->data)->tradeItems) {
																		if (f.id == 1424) {
																			pData->trade_confirmed = false;
																			Player::OnTextOverlay(peer, "`6[``you must wait for the other player to accept first`6]``");
																			Player::OnTalkBubble(currentPeer, static_cast<PlayerInfo*>(currentPeer->data)->netID, "`6[``You must accept first because you're selling a World Key`6]``", 0, false);
																			Player::OnConsoleMessage(currentPeer, "`6[``You must accept first because you're selling a World Key`6]``");
																			
																			string warning1 = "", warning2 = "", warningkeycurrent = "", warningkeypeer = "", lockedwith = "";
																			if (static_cast<PlayerInfo*>(currentPeer->data)->tradeItems.size() == 0) {
																				warning1 = "\nadd_spacer|small|\nadd_textbox|`4SCAM WARNING: ``You are about to do a trade without receiving anything in return. Once you do the trade you cannot get the items back.|left|\nadd_textbox|`4Do you really want to do this?``|left|\nadd_spacer|small|";
																			}
																			if (pData->tradeItems.size() == 0) {
																				warning2 = "\nadd_spacer|small|\nadd_textbox|`4SCAM WARNING: ``You are about to do a trade without receiving anything in return. Once you do the trade you cannot get the items back.|left|\nadd_textbox|`4Do you really want to do this?``|left|\nadd_spacer|small|";
																			}
																			for (auto& f : static_cast<PlayerInfo*>(peer->data)->tradeItems) {
																				if (f.id == 1424) {
																					for (int i = 0; i < world->width * world->height; i++) {
																						if (getItemDef(world->items.at(i).foreground).blockType == BlockTypes::LOCK) {
																							if (world->items.at(i).foreground == 202 || world->items.at(i).foreground == 204 || world->items.at(i).foreground == 206 || world->items.at(i).foreground == 4994) continue;
																							lockedwith = getItemDef(world->items.at(i).foreground).name;
																							break;
																						}
																					}
																					warningkeycurrent = "\nadd_textbox|`4SCAM WARNING: ``You are buying this world, `#" + world->name + "``. Don't buy a world just to get its rare items, because scammers can easily place secret doors allowing someone to jump in and `4steal the items back`` after a trade!|left|\nadd_spacer|small|\nadd_textbox|Also, all ratings will be removed from a world when it is traded. Don't buy a world for its ranking!|left|\nadd_spacer|small|\nadd_textbox|To be safe, only buy a world for its name and placed blocks, not loose items or high ratings. Consider yourself warned!|left|\nadd_spacer|small|\nadd_textbox|This world is locked by " + lockedwith + ".|left|\nadd_spacer|small|";
																					warningkeypeer = "\nadd_textbox|`4WARNING: ``You are about to sell your world `#" + world->name + "`` - the world lock ownership will be transferred over to `w" + static_cast<PlayerInfo*>(currentPeer->data)->displayName + "`o.|left|\nadd_spacer|small|";
																					break;
																				}
																			}
																			for (auto& f : static_cast<PlayerInfo*>(currentPeer->data)->tradeItems) {
																				if (f.id == 1424) {
																					for (int i = 0; i < world->width * world->height; i++) {
																						if (getItemDef(world->items.at(i).foreground).blockType == BlockTypes::LOCK) {
																							if (world->items.at(i).foreground == 202 || world->items.at(i).foreground == 204 || world->items.at(i).foreground == 206 || world->items.at(i).foreground == 4994) continue;
																							lockedwith = getItemDef(world->items.at(i).foreground).name;
																							break;
																						}
																					}
																					warningkeypeer = "\nadd_textbox|`4SCAM WARNING: ``You are buying this world, `#" + world->name + "``. Don't buy a world just to get its rare items, because scammers can easily place secret doors allowing someone to jump in and `4steal the items back`` after a trade!|left|\nadd_spacer|small|\nadd_textbox|Also, all ratings will be removed from a world when it is traded. Don't buy a world for its ranking!|left|\nadd_spacer|small|\nadd_textbox|To be safe, only buy a world for its name and placed blocks, not loose items or high ratings. Consider yourself warned!|left|\nadd_spacer|small|\nadd_textbox|This world is locked by " + lockedwith + ".|left|\nadd_spacer|small|";
																					warningkeycurrent = "\nadd_textbox|`4WARNING: ``You are about to sell your world `#" + world->name + "`` - the world lock ownership will be transferred over to `w" + pData->displayName + "`o.|left|\nadd_spacer|small|";
																					break;
																				}
																			}

																			Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wTrade Confirmation``|left|1366|\nadd_spacer|small|\nadd_textbox|`4You'll give:``|left|\nadd_spacer|small|" + FormatTradeItemsForDialog(pData->tradeItems, 0) + "\nadd_spacer|small|\nadd_textbox|`2You'll get:``|left|\nadd_spacer|small|" + FormatTradeItemsForDialog(static_cast<PlayerInfo*>(currentPeer->data)->tradeItems, 1) + "\nadd_spacer|small|" + warningkeypeer + warning1 + "\nadd_button|accept|Do The Trade!|noflags|0|0|\nadd_button|back|Cancel|noflags|0|0|\nend_dialog|trade_confirm|||");

																			aha = true;
																			break;
																		}
																	} if (!aha) {
																		Player::OnTalkBubble(peer, pData->netID, "`6[``Trade accepted, waiting for other player to accept`6]``", 0, false);
																		Player::OnConsoleMessage(peer, "`6[``Trade accepted, waiting for other player to accept`6]``");
																		Player::OnTalkBubble(currentPeer, static_cast<PlayerInfo*>(currentPeer->data)->netID, "`6[``Trade accepted by other player, waiting for you`6]``", 0, false);
																		Player::OnConsoleMessage(currentPeer, "`6[``Trade accepted by other player, waiting for you`6]``");
																	}
																}
																break;
															}
														}
													}
													break;
												}
											}
											if (wizardDialog) {
												int x = pData->lastPunchX;
												int y = pData->lastPunchY;
												if (isWorldOwner(peer, world) || isWorldAdmin(peer, world) || isDev(peer) || world->owner == "" || !restricted_area(peer, world, x, y) || world->items.at(x + (y * world->width)).foreground == 1790) {
													if (infoDat.at(1) == "honor") { /*legend title*/
														pData->choosing_quest = "honor";
														Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`9Quest For Honor``|left|1790|\nadd_textbox|`oThis quest will challenge every fiber of your Growtopian being. It will cost you thousands of gems, weeks or months of time, and possibly your friends and family.<CR>Every quest has 20 steps to complete, and each step alone is probably more than most Growtopians could manage.<CR>But the rewards are also vast. If you complete this quest, you will earn the `9Legendary Title`o!<CR>These quest rewards are `5Untradeable`o, and you will truly be a Legendary Growtopian if you complete a quest.<CR>You may turn in your quests at any Legendary Wizard you have access to (we're in a union), but i will vanish permanently if somebody turns in their final quest step to me, so don't let other people access to me!<CR>There's one last thing you should know before you begin. You can quit your quest at any time, but be aware that if you do, you'll lose all progress on this quest. So choose your quest wisely and see it through to the end!|\nadd_spacer|small|\nadd_label|big|`oSo... now that you've received the official disclaimer, are you truly prepared to embark on the Quest For Honor?``|\nend_dialog|legendary_wizard|No!|Yes!|");
														break;
													}
													else if (infoDat.at(1) == "steel") { /*legend bot*/
														pData->choosing_quest = "steel";
														Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`9Quest For Steel``|left|1790|\nadd_textbox|`oThis quest will challenge every fiber of your Growtopian being. It will cost you thousands of gems, weeks or months of time, and possibly your friends and family.<CR>Every quest has 20 steps to complete, and each step alone is probably more than most Growtopians could manage.<CR>But the rewards are also vast. If you complete this quest, you will earn the `9Legend Bot-009`o!<CR>These quest rewards are `5Untradeable`o, and you will truly be a Legendary Growtopian if you complete a quest.<CR>You may turn in your quests at any Legendary Wizard you have access to (we're in a union), but i will vanish permanently if somebody turns in their final quest step to me, so don't let other people access to me!<CR>There's one last thing you should know before you begin. You can quit your quest at any time, but be aware that if you do, you'll lose all progress on this quest. So choose your quest wisely and see it through to the end!|\nadd_spacer|small|\nadd_label|big|`oSo... now that you've received the official disclaimer, are you truly prepared to embark on the Quest For Steel?``|\nend_dialog|legendary_wizard|No!|Yes!|");
														break;
													}
													else if (infoDat.at(1) == "fire") { /*legend dragon*/
														pData->choosing_quest = "fire";
														Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`9Quest For Fire``|left|1790|\nadd_textbox|`oThis quest will challenge every fiber of your Growtopian being. It will cost you thousands of gems, weeks or months of time, and possibly your friends and family.<CR>Every quest has 20 steps to complete, and each step alone is probably more than most Growtopians could manage.<CR>But the rewards are also vast. If you complete this quest, you will earn the `9Dragon of Legend`o!<CR>These quest rewards are `5Untradeable`o, and you will truly be a Legendary Growtopian if you complete a quest.<CR>You may turn in your quests at any Legendary Wizard you have access to (we're in a union), but i will vanish permanently if somebody turns in their final quest step to me, so don't let other people access to me!<CR>There's one last thing you should know before you begin. You can quit your quest at any time, but be aware that if you do, you'll lose all progress on this quest. So choose your quest wisely and see it through to the end!|\nadd_spacer|small|\nadd_label|big|`oSo... now that you've received the official disclaimer, are you truly prepared to embark on the Quest For Fire?``|\nend_dialog|legendary_wizard|No!|Yes!|");
														break;
													}
													else if (infoDat.at(1) == "heavens") { /*legend wing*/
														pData->choosing_quest = "heavens";
														Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`9Quest For Heavens``|left|1790|\nadd_textbox|`oThis quest will challenge every fiber of your Growtopian being. It will cost you thousands of gems, weeks or months of time, and possibly your friends and family.<CR>Every quest has 20 steps to complete, and each step alone is probably more than most Growtopians could manage.<CR>But the rewards are also vast. If you complete this quest, you will earn the `9Legendary Wings`o!<CR>These quest rewards are `5Untradeable`o, and you will truly be a Legendary Growtopian if you complete a quest.<CR>You may turn in your quests at any Legendary Wizard you have access to (we're in a union), but i will vanish permanently if somebody turns in their final quest step to me, so don't let other people access to me!<CR>There's one last thing you should know before you begin. You can quit your quest at any time, but be aware that if you do, you'll lose all progress on this quest. So choose your quest wisely and see it through to the end!|\nadd_spacer|small|\nadd_label|big|`oSo... now that you've received the official disclaimer, are you truly prepared to embark on the Quest For Heavens?``|\nend_dialog|legendary_wizard|No!|Yes!|");
														break;
													}
													else if (infoDat.at(1) == "blade") { /*legend katana*/
														pData->choosing_quest = "blade";
														Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`9Quest For Blade``|left|1790|\nadd_textbox|`oThis quest will challenge every fiber of your Growtopian being. It will cost you thousands of gems, weeks or months of time, and possibly your friends and family.<CR>Every quest has 20 steps to complete, and each step alone is probably more than most Growtopians could manage.<CR>But the rewards are also vast. If you complete this quest, you will earn the `9Legendary Katana`o!<CR>These quest rewards are `5Untradeable`o, and you will truly be a Legendary Growtopian if you complete a quest.<CR>You may turn in your quests at any Legendary Wizard you have access to (we're in a union), but i will vanish permanently if somebody turns in their final quest step to me, so don't let other people access to me!<CR>There's one last thing you should know before you begin. You can quit your quest at any time, but be aware that if you do, you'll lose all progress on this quest. So choose your quest wisely and see it through to the end!|\nadd_spacer|small|\nadd_label|big|`oSo... now that you've received the official disclaimer, are you truly prepared to embark on the Quest For Blade?``|\nend_dialog|legendary_wizard|No!|Yes!|");
														break;
													}
													else if (infoDat.at(1) == "candour") { /*legend whip*/
														pData->choosing_quest = "candour";
														Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`9Quest For Candour``|left|1790|\nadd_textbox|`oThis quest will challenge every fiber of your Growtopian being. It will cost you thousands of gems, weeks or months of time, and possibly your friends and family.<CR>Every quest has 20 steps to complete, and each step alone is probably more than most Growtopians could manage.<CR>But the rewards are also vast. If you complete this quest, you will earn the `9Whip of Truth`o!<CR>These quest rewards are `5Untradeable`o, and you will truly be a Legendary Growtopian if you complete a quest.<CR>You may turn in your quests at any Legendary Wizard you have access to (we're in a union), but i will vanish permanently if somebody turns in their final quest step to me, so don't let other people access to me!<CR>There's one last thing you should know before you begin. You can quit your quest at any time, but be aware that if you do, you'll lose all progress on this quest. So choose your quest wisely and see it through to the end!|\nadd_spacer|small|\nadd_label|big|`oSo... now that you've received the official disclaimer, are you truly prepared to embark on the Quest For Candour?``|\nend_dialog|legendary_wizard|No!|Yes!|");
														break;
													}
													else if (infoDat.at(1) == "thesky") { /*legend knight wing*/
														pData->choosing_quest = "thesky";
														Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`9Quest For The Sky``|left|1790|\nadd_textbox|`oThis quest will challenge every fiber of your Growtopian being. It will cost you thousands of gems, weeks or months of time, and possibly your friends and family.<CR>Every quest has 20 steps to complete, and each step alone is probably more than most Growtopians could manage.<CR>But the rewards are also vast. If you complete this quest, you will earn the `9Legendary Dragon Knight's Wings`o!<CR>These quest rewards are `5Untradeable`o, and you will truly be a Legendary Growtopian if you complete a quest.<CR>You may turn in your quests at any Legendary Wizard you have access to (we're in a union), but i will vanish permanently if somebody turns in their final quest step to me, so don't let other people access to me!<CR>There's one last thing you should know before you begin. You can quit your quest at any time, but be aware that if you do, you'll lose all progress on this quest. So choose your quest wisely and see it through to the end!|\nadd_spacer|small|\nadd_label|big|`oSo... now that you've received the official disclaimer, are you truly prepared to embark on the Quest For The Sky?``|\nend_dialog|legendary_wizard|No!|Yes!|");
														break;
													}
													else if (infoDat.at(1) == "deliver") {
														if (pData->lastquest == "honor" && pData->quest_step == 1) { /*sand*/
															auto KiekTuri = 0;
															for (auto i = 0; i < pData->inventory.items.size(); i++) {
																if (pData->inventory.items.at(i).itemID == 442 && pData->inventory.items.at(i).itemCount > 0) {
																	KiekTuri = pData->inventory.items.at(i).itemCount;
																	break;
																}
															}
															if (KiekTuri != 0) {
																if (pData->quest_progress + KiekTuri > 2000) KiekTuri = 2000 - pData->quest_progress;
																RemoveInventoryItem(442, KiekTuri, peer, true);
																pData->quest_progress += KiekTuri;
																if (pData->quest_progress >= 2000) {
																	pData->quest_progress = 0;
																	pData->quest_step++;
																	Player::OnTextOverlay(peer, "`9Quest step complete!!");
																	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																		if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
																		if (isHere(peer, currentPeer)) {
																			Player::OnParticleEffect(peer, 48, pData->x, pData->y, 0);
																		}
																	}
																	send_quest_view(peer, pData, world);
																}
																else {
																	Player::OnTextOverlay(peer, "`9Thanks! Keep it coming!");
																}
															}
															else {
																goto goodluck;
															}
														}
														else if (pData->lastquest == "steel" && pData->quest_step == 1) { /*greenchemical*/
															auto KiekTuri = 0;
															for (auto i = 0; i < pData->inventory.items.size(); i++) {
																if (pData->inventory.items.at(i).itemID == 914 && pData->inventory.items.at(i).itemCount > 0) {
																	KiekTuri = pData->inventory.items.at(i).itemCount;
																	break;
																}
															}
															if (KiekTuri != 0) {
																if (pData->quest_progress + KiekTuri > 2000) KiekTuri = 2000 - pData->quest_progress;
																RemoveInventoryItem(914, KiekTuri, peer, true);
																pData->quest_progress += KiekTuri;
																if (pData->quest_progress >= 2000) {
																	pData->quest_progress = 0;
																	pData->quest_step++;
																	Player::OnTextOverlay(peer, "`9Quest step complete!!");
																	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																		if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
																		if (isHere(peer, currentPeer)) {
																			Player::OnParticleEffect(peer, 48, pData->x, pData->y, 0);
																		}
																	}
																	send_quest_view_bot(peer, pData, world);
																}
																else {
																	Player::OnTextOverlay(peer, "`9Thanks! Keep it coming!");
																}
															}
															else {
																goto goodluck;
															}
														}
														else if (pData->lastquest == "fire" && pData->quest_step == 1) { /*lava*/
															auto KiekTuri = 0;
															for (auto i = 0; i < pData->inventory.items.size(); i++) {
																if (pData->inventory.items.at(i).itemID == 4 && pData->inventory.items.at(i).itemCount > 0) {
																	KiekTuri = pData->inventory.items.at(i).itemCount;
																	break;
																}
															}
															if (KiekTuri != 0) {
																if (pData->quest_progress + KiekTuri > 2000) KiekTuri = 2000 - pData->quest_progress;
																RemoveInventoryItem(4, KiekTuri, peer, true);
																pData->quest_progress += KiekTuri;
																if (pData->quest_progress >= 2000) {
																	pData->quest_progress = 0;
																	pData->quest_step++;
																	Player::OnTextOverlay(peer, "`9Quest step complete!!");
																	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																		if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
																		if (isHere(peer, currentPeer)) {
																			Player::OnParticleEffect(peer, 48, pData->x, pData->y, 0);
																		}
																	}
																	send_quest_view_dragon(peer, pData, world);
																}
																else {
																	Player::OnTextOverlay(peer, "`9Thanks! Keep it coming!");
																}
															}
															else {
																goto goodluck;
															}
														}
														else if (pData->lastquest == "heavens" && pData->quest_step == 1) { /*cloud*/
															auto KiekTuri = 0;
															for (auto i = 0; i < pData->inventory.items.size(); i++) {
																if (pData->inventory.items.at(i).itemID == 728 && pData->inventory.items.at(i).itemCount > 0) {
																	KiekTuri = pData->inventory.items.at(i).itemCount;
																	break;
																}
															}
															if (KiekTuri != 0) {
																if (pData->quest_progress + KiekTuri > 1000) KiekTuri = 1000 - pData->quest_progress;
																RemoveInventoryItem(728, KiekTuri, peer, true);
																pData->quest_progress += KiekTuri;
																if (pData->quest_progress >= 1000) {
																	pData->quest_progress = 0;
																	pData->quest_step++;
																	Player::OnTextOverlay(peer, "`9Quest step complete!!");
																	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																		if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
																		if (isHere(peer, currentPeer)) {
																			Player::OnParticleEffect(peer, 48, pData->x, pData->y, 0);
																		}
																	}
																	send_quest_view_lwing(peer, pData, world);
																}
																else {
																	Player::OnTextOverlay(peer, "`9Thanks! Keep it coming!");
																}
															}
															else {
																goto goodluck;
															}
														}
														else if (pData->lastquest == "blade" && pData->quest_step == 1) { /*ironbar*/
															auto KiekTuri = 0;
															for (auto i = 0; i < pData->inventory.items.size(); i++) {
																if (pData->inventory.items.at(i).itemID == 684 && pData->inventory.items.at(i).itemCount > 0) {
																	KiekTuri = pData->inventory.items.at(i).itemCount;
																	break;
																}
															}
															if (KiekTuri != 0) {
																if (pData->quest_progress + KiekTuri > 1000) KiekTuri = 1000 - pData->quest_progress;
																RemoveInventoryItem(684, KiekTuri, peer, true);
																pData->quest_progress += KiekTuri;
																if (pData->quest_progress >= 1000) {
																	pData->quest_progress = 0;
																	pData->quest_step++;
																	Player::OnTextOverlay(peer, "`9Quest step complete!!");
																	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																		if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
																		if (isHere(peer, currentPeer)) {
																			Player::OnParticleEffect(peer, 48, pData->x, pData->y, 0);
																		}
																	}
																	send_quest_view_katana(peer, pData, world);
																}
																else {
																	Player::OnTextOverlay(peer, "`9Thanks! Keep it coming!");
																}
															}
															else {
																goto goodluck;
															}
														}
														else if (pData->lastquest == "candour" && pData->quest_step == 1) { /*secretofgrowtopia*/
															auto KiekTuri = 0;
															for (auto i = 0; i < pData->inventory.items.size(); i++) {
																if (pData->inventory.items.at(i).itemID == 1050 && pData->inventory.items.at(i).itemCount > 0) {
																	KiekTuri = pData->inventory.items.at(i).itemCount;
																	break;
																}
															}
															if (KiekTuri != 0) {
																if (pData->quest_progress + KiekTuri > 2000) KiekTuri = 2000 - pData->quest_progress;
																RemoveInventoryItem(1050, KiekTuri, peer, true);
																pData->quest_progress += KiekTuri;
																if (pData->quest_progress >= 2000) {
																	pData->quest_progress = 0;
																	pData->quest_step++;
																	Player::OnTextOverlay(peer, "`9Quest step complete!!");
																	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																		if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
																		if (isHere(peer, currentPeer)) {
																			Player::OnParticleEffect(peer, 48, pData->x, pData->y, 0);
																		}
																	}
																	send_quest_view_whip(peer, pData, world);
																}
																else {
																	Player::OnTextOverlay(peer, "`9Thanks! Keep it coming!");
																}
															}
															else {
																goto goodluck;
															}
														}
														else if (pData->lastquest == "thesky" && pData->quest_step == 1) { /*obsidian*/
															auto KiekTuri = 0;
															for (auto i = 0; i < pData->inventory.items.size(); i++) {
																if (pData->inventory.items.at(i).itemID == 5042 && pData->inventory.items.at(i).itemCount > 0) {
																	KiekTuri = pData->inventory.items.at(i).itemCount;
																	break;
																}
															}
															if (KiekTuri != 0) {
																if (pData->quest_progress + KiekTuri > 2000) KiekTuri = 2000 - pData->quest_progress;
																RemoveInventoryItem(5042, KiekTuri, peer, true);
																pData->quest_progress += KiekTuri;
																if (pData->quest_progress >= 2000) {
																	pData->quest_progress = 0;
																	pData->quest_step++;
																	Player::OnTextOverlay(peer, "`9Quest step complete!!");
																	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																		if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
																		if (isHere(peer, currentPeer)) {
																			Player::OnParticleEffect(peer, 48, pData->x, pData->y, 0);
																		}
																	}
																	send_quest_view_lkwing(peer, pData, world);
																}
																else {
																	Player::OnTextOverlay(peer, "`9Thanks! Keep it coming!");
																}
															}
															else {
																goto goodluck;
															}
														}
														else if (pData->lastquest == "honor" && pData->quest_step == 2 || pData->lastquest == "steel" && pData->quest_step == 2 || pData->lastquest == "fire" && pData->quest_step == 2 || pData->lastquest == "heavens" && pData->quest_step == 2 || pData->lastquest == "blade" && pData->quest_step == 2 || pData->lastquest == "candour" && pData->quest_step == 2 || pData->lastquest == "thesky" && pData->quest_step == 2) { /*pvp*/
															if (pData->quest_progress >= 100) {
																pData->quest_progress = 0;
																pData->quest_step++;
																Player::OnTextOverlay(peer, "`9Quest step complete!!");
																for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																	if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
																	if (isHere(peer, currentPeer)) {
																		Player::OnParticleEffect(peer, 48, pData->x, pData->y, 0);
																	}
																}
																if (pData->lastquest == "honor") {
																	send_quest_view(peer, pData, world);
																}
																else if (pData->lastquest == "steel") {
																	send_quest_view_bot(peer, pData, world);
																}
																else if (pData->lastquest == "fire") {
																	send_quest_view_dragon(peer, pData, world);
																}
																else if (pData->lastquest == "heavens") {
																	send_quest_view_lwing(peer, pData, world);
																}
																else if (pData->lastquest == "blade") {
																	send_quest_view_katana(peer, pData, world);
																}
																else if (pData->lastquest == "candour") {
																	send_quest_view_whip(peer, pData, world);
																}
																else if (pData->lastquest == "thesky") {
																	send_quest_view_lkwing(peer, pData, world);
																}
															}
															else {
																goto goodluck;
															}
														}
														else if (pData->lastquest == "honor" && pData->quest_step == 3 || pData->lastquest == "steel" && pData->quest_step == 3 || pData->lastquest == "fire" && pData->quest_step == 3 || pData->lastquest == "heavens" && pData->quest_step == 3 || pData->lastquest == "blade" && pData->quest_step == 3 || pData->lastquest == "candour" && pData->quest_step == 3 || pData->lastquest == "thesky" && pData->quest_step == 3) { /*break*/
															if (pData->quest_progress >= 5000) {
																pData->quest_progress = 0;
																pData->quest_step++;
																Player::OnTextOverlay(peer, "`9Quest step complete!!");
																for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																	if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
																	if (isHere(peer, currentPeer)) {
																		Player::OnParticleEffect(peer, 48, pData->x, pData->y, 0);
																	}
																}
																if (pData->lastquest == "honor") {
																	send_quest_view(peer, pData, world);
																}
																else if (pData->lastquest == "steel") {
																	send_quest_view_bot(peer, pData, world);
																}
																else if (pData->lastquest == "fire") {
																	send_quest_view_dragon(peer, pData, world);
																}
																else if (pData->lastquest == "heavens") {
																	send_quest_view_lwing(peer, pData, world);
																}
																else if (pData->lastquest == "blade") {
																	send_quest_view_katana(peer, pData, world);
																}
																else if (pData->lastquest == "candour") {
																	send_quest_view_whip(peer, pData, world);
																}
																else if (pData->lastquest == "thesky") {
																	send_quest_view_lkwing(peer, pData, world);
																}
															}
															else {
																goto goodluck;
															}
														}
														else if (pData->lastquest == "honor" && pData->quest_step == 4) { /*displaybox*/
															auto KiekTuri = 0;
															for (auto i = 0; i < pData->inventory.items.size(); i++) {
																if (pData->inventory.items.at(i).itemID == 1422 && pData->inventory.items.at(i).itemCount > 0) {
																	KiekTuri = pData->inventory.items.at(i).itemCount;
																	break;
																}
															}
															if (KiekTuri != 0) {
																if (pData->quest_progress + KiekTuri > 600) KiekTuri = 600 - pData->quest_progress;
																RemoveInventoryItem(1422, KiekTuri, peer, true);
																pData->quest_progress += KiekTuri;
																if (pData->quest_progress >= 600) {
																	pData->quest_progress = 0;
																	pData->quest_step++;
																	Player::OnTextOverlay(peer, "`9Quest step complete!!");
																	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																		if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
																		if (isHere(peer, currentPeer)) {
																			Player::OnParticleEffect(peer, 48, pData->x, pData->y, 0);
																		}
																	}
																	send_quest_view(peer, pData, world);
																}
																else {
																	Player::OnTextOverlay(peer, "`9Thanks! Keep it coming!");
																}
															}
															else {
																goto goodluck;
															}
														}
														else if (pData->lastquest == "steel" && pData->quest_step == 4) { /*robotwantsdubstep*/
															auto KiekTuri = 0;
															for (auto i = 0; i < pData->inventory.items.size(); i++) {
																if (pData->inventory.items.at(i).itemID == 254 && pData->inventory.items.at(i).itemCount > 0) {
																	KiekTuri = pData->inventory.items.at(i).itemCount;
																	break;
																}
															}
															if (KiekTuri != 0) {
																if (pData->quest_progress + KiekTuri > 600) KiekTuri = 600 - pData->quest_progress;
																RemoveInventoryItem(254, KiekTuri, peer, true);
																pData->quest_progress += KiekTuri;
																if (pData->quest_progress >= 600) {
																	pData->quest_progress = 0;
																	pData->quest_step++;
																	Player::OnTextOverlay(peer, "`9Quest step complete!!");
																	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																		if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
																		if (isHere(peer, currentPeer)) {
																			Player::OnParticleEffect(peer, 48, pData->x, pData->y, 0);
																		}
																	}
																	send_quest_view_bot(peer, pData, world);
																}
																else {
																	Player::OnTextOverlay(peer, "`9Thanks! Keep it coming!");
																}
															}
															else {
																goto goodluck;
															}
														}
														else if (pData->lastquest == "fire" && pData->quest_step == 4) { /*dragongate*/
															auto KiekTuri = 0;
															for (auto i = 0; i < pData->inventory.items.size(); i++) {
																if (pData->inventory.items.at(i).itemID == 598 && pData->inventory.items.at(i).itemCount > 0) {
																	KiekTuri = pData->inventory.items.at(i).itemCount;
																	break;
																}
															}
															if (KiekTuri != 0) {
																if (pData->quest_progress + KiekTuri > 600) KiekTuri = 600 - pData->quest_progress;
																RemoveInventoryItem(598, KiekTuri, peer, true);
																pData->quest_progress += KiekTuri;
																if (pData->quest_progress >= 600) {
																	pData->quest_progress = 0;
																	pData->quest_step++;
																	Player::OnTextOverlay(peer, "`9Quest step complete!!");
																	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																		if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
																		if (isHere(peer, currentPeer)) {
																			Player::OnParticleEffect(peer, 48, pData->x, pData->y, 0);
																		}
																	}
																	send_quest_view_dragon(peer, pData, world);
																}
																else {
																	Player::OnTextOverlay(peer, "`9Thanks! Keep it coming!");
																}
															}
															else {
																goto goodluck;
															}
														}
														else if (pData->lastquest == "heavens" && pData->quest_step == 4) { /*fairywing*/
															auto KiekTuri = 0;
															for (auto i = 0; i < pData->inventory.items.size(); i++) {
																if (pData->inventory.items.at(i).itemID == 156 && pData->inventory.items.at(i).itemCount > 0) {
																	KiekTuri = pData->inventory.items.at(i).itemCount;
																	break;
																}
															}
															if (KiekTuri != 0) {
																if (pData->quest_progress + KiekTuri > 600) KiekTuri = 600 - pData->quest_progress;
																RemoveInventoryItem(156, KiekTuri, peer, true);
																pData->quest_progress += KiekTuri;
																if (pData->quest_progress >= 600) {
																	pData->quest_progress = 0;
																	pData->quest_step++;
																	Player::OnTextOverlay(peer, "`9Quest step complete!!");
																	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																		if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
																		if (isHere(peer, currentPeer)) {
																			Player::OnParticleEffect(peer, 48, pData->x, pData->y, 0);
																		}
																	}
																	send_quest_view_lwing(peer, pData, world);
																}
																else {
																	Player::OnTextOverlay(peer, "`9Thanks! Keep it coming!");
																}
															}
															else {
																goto goodluck;
															}
														}
														else if (pData->lastquest == "blade" && pData->quest_step == 4) { /*goldensword*/
															auto KiekTuri = 0;
															for (auto i = 0; i < pData->inventory.items.size(); i++) {
																if (pData->inventory.items.at(i).itemID == 604 && pData->inventory.items.at(i).itemCount > 0) {
																	KiekTuri = pData->inventory.items.at(i).itemCount;
																	break;
																}
															}
															if (KiekTuri != 0) {
																if (pData->quest_progress + KiekTuri > 600) KiekTuri = 600 - pData->quest_progress;
																RemoveInventoryItem(604, KiekTuri, peer, true);
																pData->quest_progress += KiekTuri;
																if (pData->quest_progress >= 600) {
																	pData->quest_progress = 0;
																	pData->quest_step++;
																	Player::OnTextOverlay(peer, "`9Quest step complete!!");
																	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																		if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
																		if (isHere(peer, currentPeer)) {
																			Player::OnParticleEffect(peer, 48, pData->x, pData->y, 0);
																		}
																	}
																	send_quest_view_katana(peer, pData, world);
																}
																else {
																	Player::OnTextOverlay(peer, "`9Thanks! Keep it coming!");
																}
															}
															else {
																goto goodluck;
															}
														}
														else if (pData->lastquest == "candour" && pData->quest_step == 4) { /*Mind-Ghost-In-A-Jar*/
															auto KiekTuri = 0;
															for (auto i = 0; i < pData->inventory.items.size(); i++) {
																if (pData->inventory.items.at(i).itemID == 6080 && pData->inventory.items.at(i).itemCount > 0) {
																	KiekTuri = pData->inventory.items.at(i).itemCount;
																	break;
																}
															}
															if (KiekTuri != 0) {
																if (pData->quest_progress + KiekTuri > 1000) KiekTuri = 1000 - pData->quest_progress;
																RemoveInventoryItem(6080, KiekTuri, peer, true);
																pData->quest_progress += KiekTuri;
																if (pData->quest_progress >= 1000) {
																	pData->quest_progress = 0;
																	pData->quest_step++;
																	Player::OnTextOverlay(peer, "`9Quest step complete!!");
																	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																		if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
																		if (isHere(peer, currentPeer)) {
																			Player::OnParticleEffect(peer, 48, pData->x, pData->y, 0);
																		}
																	}
																	send_quest_view_whip(peer, pData, world);
																}
																else {
																	Player::OnTextOverlay(peer, "`9Thanks! Keep it coming!");
																}
															}
															else {
																goto goodluck;
															}
														}
														else if (pData->lastquest == "thesky" && pData->quest_step == 4) { /*Knight helmet*/
															auto KiekTuri = 0;
															for (auto i = 0; i < pData->inventory.items.size(); i++) {
																if (pData->inventory.items.at(i).itemID == 1736 && pData->inventory.items.at(i).itemCount > 0) {
																	KiekTuri = pData->inventory.items.at(i).itemCount;
																	break;
																}
															}
															if (KiekTuri != 0) {
																if (pData->quest_progress + KiekTuri > 1000) KiekTuri = 1000 - pData->quest_progress;
																RemoveInventoryItem(1736, KiekTuri, peer, true);
																pData->quest_progress += KiekTuri;
																if (pData->quest_progress >= 1000) {
																	pData->quest_progress = 0;
																	pData->quest_step++;
																	Player::OnTextOverlay(peer, "`9Quest step complete!!");
																	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																		if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
																		if (isHere(peer, currentPeer)) {
																			Player::OnParticleEffect(peer, 48, pData->x, pData->y, 0);
																		}
																	}
																	send_quest_view_lkwing(peer, pData, world);
																}
																else {
																	Player::OnTextOverlay(peer, "`9Thanks! Keep it coming!");
																}
															}
															else {
																goto goodluck;
															}
														}
														else if (pData->lastquest == "honor" && pData->quest_step == 5 || pData->lastquest == "steel" && pData->quest_step == 5 || pData->lastquest == "fire" && pData->quest_step == 5 || pData->lastquest == "heavens" && pData->quest_step == 5 || pData->lastquest == "blade" && pData->quest_step == 5 || pData->lastquest == "candour" && pData->quest_step == 5 || pData->lastquest == "thesky" && pData->quest_step == 5) { /*plant*/
															if (pData->quest_progress >= 50000) {
																pData->quest_progress = 0;
																pData->quest_step++;
																Player::OnTextOverlay(peer, "`9Quest step complete!!");
																for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																	if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
																	if (isHere(peer, currentPeer)) {
																		Player::OnParticleEffect(peer, 48, pData->x, pData->y, 0);
																	}
																}
																if (pData->lastquest == "honor") {
																	send_quest_view(peer, pData, world);
																}
																else if (pData->lastquest == "steel") {
																	send_quest_view_bot(peer, pData, world);
																}
																else if (pData->lastquest == "fire") {
																	send_quest_view_dragon(peer, pData, world);
																}
																else if (pData->lastquest == "heavens") {
																	send_quest_view_lwing(peer, pData, world);
																}
																else if (pData->lastquest == "blade") {
																	send_quest_view_katana(peer, pData, world);
																}
																else if (pData->lastquest == "candour") {
																	send_quest_view_whip(peer, pData, world);
																}
																else if (pData->lastquest == "thesky") {
																	send_quest_view_lkwing(peer, pData, world);
																}
															}
															else {
																goto goodluck;
															}
														}
														else if (pData->lastquest == "honor" && pData->quest_step == 6 || pData->lastquest == "steel" && pData->quest_step == 6 || pData->lastquest == "fire" && pData->quest_step == 6 || pData->lastquest == "heavens" && pData->quest_step == 6 || pData->lastquest == "blade" && pData->quest_step == 6 || pData->lastquest == "candour" && pData->quest_step == 6 || pData->lastquest == "thesky" && pData->quest_step == 6) { /*growtoken*/
															if (pData->quest_progress >= 50) {
																pData->quest_progress = 0;
																pData->quest_step++;
																Player::OnTextOverlay(peer, "`9Quest step complete!!");
																for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																	if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
																	if (isHere(peer, currentPeer)) {
																		Player::OnParticleEffect(peer, 48, pData->x, pData->y, 0);
																	}
																}
																if (pData->lastquest == "honor") {
																	send_quest_view(peer, pData, world);
																}
																else if (pData->lastquest == "steel") {
																	send_quest_view_bot(peer, pData, world);
																}
																else if (pData->lastquest == "fire") {
																	send_quest_view_dragon(peer, pData, world);
																}
																else if (pData->lastquest == "heavens") {
																	send_quest_view_lwing(peer, pData, world);
																}
																else if (pData->lastquest == "blade") {
																	send_quest_view_katana(peer, pData, world);
																}
																else if (pData->lastquest == "candour") {
																	send_quest_view_whip(peer, pData, world);
																}
																else if (pData->lastquest == "thesky") {
																	send_quest_view_lkwing(peer, pData, world);
																}
															}
															else {
																goto goodluck;
															}
														}
														else if (pData->lastquest == "honor" && pData->quest_step == 7) { /*Goldendiaper*/
															auto KiekTuri = 0;
															for (auto i = 0; i < pData->inventory.items.size(); i++) {
																if (pData->inventory.items.at(i).itemID == 1462 && pData->inventory.items.at(i).itemCount > 0) {
																	KiekTuri = pData->inventory.items.at(i).itemCount;
																	break;
																}
															}
															if (KiekTuri != 0) {
																if (pData->quest_progress + KiekTuri > 3) KiekTuri = 3 - pData->quest_progress;
																RemoveInventoryItem(1462, KiekTuri, peer, true);
																pData->quest_progress += KiekTuri;
																if (pData->quest_progress >= 3) {
																	pData->quest_progress = 0;
																	pData->quest_step++;
																	Player::OnTextOverlay(peer, "`9Quest step complete!!");
																	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																		if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
																		if (isHere(peer, currentPeer)) {
																			Player::OnParticleEffect(peer, 48, pData->x, pData->y, 0);
																		}
																	}
																	send_quest_view(peer, pData, world);
																}
																else {
																	Player::OnTextOverlay(peer, "`9Thanks! Keep it coming!");
																}
															}
															else {
																goto goodluck;
															}
														}
														else if (pData->lastquest == "steel" && pData->quest_step == 7) { /*EdisonZoomer*/
															auto KiekTuri = 0;
															for (auto i = 0; i < pData->inventory.items.size(); i++) {
																if (pData->inventory.items.at(i).itemID == 1274 && pData->inventory.items.at(i).itemCount > 0) {
																	KiekTuri = pData->inventory.items.at(i).itemCount;
																	break;
																}
															}
															if (KiekTuri != 0) {
																if (pData->quest_progress + KiekTuri > 3) KiekTuri = 3 - pData->quest_progress;
																RemoveInventoryItem(1274, KiekTuri, peer, true);
																pData->quest_progress += KiekTuri;
																if (pData->quest_progress >= 3) {
																	pData->quest_progress = 0;
																	pData->quest_step++;
																	Player::OnTextOverlay(peer, "`9Quest step complete!!");
																	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																		if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
																		if (isHere(peer, currentPeer)) {
																			Player::OnParticleEffect(peer, 48, pData->x, pData->y, 0);
																		}
																	}
																	send_quest_view_bot(peer, pData, world);
																}
																else {
																	Player::OnTextOverlay(peer, "`9Thanks! Keep it coming!");
																}
															}
															else {
																goto goodluck;
															}
														}
														else if (pData->lastquest == "fire" && pData->quest_step == 7) { /*DragonHand*/
															auto KiekTuri = 0;
															for (auto i = 0; i < pData->inventory.items.size(); i++) {
																if (pData->inventory.items.at(i).itemID == 900 && pData->inventory.items.at(i).itemCount > 0) {
																	KiekTuri = pData->inventory.items.at(i).itemCount;
																	break;
																}
															}
															if (KiekTuri != 0) {
																if (pData->quest_progress + KiekTuri > 10) KiekTuri = 10 - pData->quest_progress;
																RemoveInventoryItem(900, KiekTuri, peer, true);
																pData->quest_progress += KiekTuri;
																if (pData->quest_progress >= 10) {
																	pData->quest_progress = 0;
																	pData->quest_step++;
																	Player::OnTextOverlay(peer, "`9Quest step complete!!");
																	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																		if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
																		if (isHere(peer, currentPeer)) {
																			Player::OnParticleEffect(peer, 48, pData->x, pData->y, 0);
																		}
																	}
																	send_quest_view_dragon(peer, pData, world);
																}
																else {
																	Player::OnTextOverlay(peer, "`9Thanks! Keep it coming!");
																}
															}
															else {
																goto goodluck;
															}
														}
														else if (pData->lastquest == "heavens" && pData->quest_step == 7) { /*BubbleWing*/
															auto KiekTuri = 0;
															for (auto i = 0; i < pData->inventory.items.size(); i++) {
																if (pData->inventory.items.at(i).itemID == 1550 && pData->inventory.items.at(i).itemCount > 0) {
																	KiekTuri = pData->inventory.items.at(i).itemCount;
																	break;
																}
															}
															if (KiekTuri != 0) {
																if (pData->quest_progress + KiekTuri > 3) KiekTuri = 3 - pData->quest_progress;
																RemoveInventoryItem(1550, KiekTuri, peer, true);
																pData->quest_progress += KiekTuri;
																if (pData->quest_progress >= 3) {
																	pData->quest_progress = 0;
																	pData->quest_step++;
																	Player::OnTextOverlay(peer, "`9Quest step complete!!");
																	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																		if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
																		if (isHere(peer, currentPeer)) {
																			Player::OnParticleEffect(peer, 48, pData->x, pData->y, 0);
																		}
																	}
																	send_quest_view_lwing(peer, pData, world);
																}
																else {
																	Player::OnTextOverlay(peer, "`9Thanks! Keep it coming!");
																}
															}
															else {
																goto goodluck;
															}
														}
														else if (pData->lastquest == "blade" && pData->quest_step == 7) { /*HeavenlyScythe*/
															auto KiekTuri = 0;
															for (auto i = 0; i < pData->inventory.items.size(); i++) {
																if (pData->inventory.items.at(i).itemID == 2386 && pData->inventory.items.at(i).itemCount > 0) {
																	KiekTuri = pData->inventory.items.at(i).itemCount;
																	break;
																}
															}
															if (KiekTuri != 0) {
																if (pData->quest_progress + KiekTuri > 3) KiekTuri = 3 - pData->quest_progress;
																RemoveInventoryItem(2386, KiekTuri, peer, true);
																pData->quest_progress += KiekTuri;
																if (pData->quest_progress >= 3) {
																	pData->quest_progress = 0;
																	pData->quest_step++;
																	Player::OnTextOverlay(peer, "`9Quest step complete!!");
																	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																		if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
																		if (isHere(peer, currentPeer)) {
																			Player::OnParticleEffect(peer, 48, pData->x, pData->y, 0);
																		}
																	}
																	send_quest_view_katana(peer, pData, world);
																}
																else {
																	Player::OnTextOverlay(peer, "`9Thanks! Keep it coming!");
																}
															}
															else {
																goto goodluck;
															}
														}
														else if (pData->lastquest == "candour" && pData->quest_step == 7) { /*SuperSquirtGunJetpack*/
															auto KiekTuri = 0;
															for (auto i = 0; i < pData->inventory.items.size(); i++) {
																if (pData->inventory.items.at(i).itemID == 4880 && pData->inventory.items.at(i).itemCount > 0) {
																	KiekTuri = pData->inventory.items.at(i).itemCount;
																	break;
																}
															}
															if (KiekTuri != 0) {
																if (pData->quest_progress + KiekTuri > 3) KiekTuri = 3 - pData->quest_progress;
																RemoveInventoryItem(4880, KiekTuri, peer, true);
																pData->quest_progress += KiekTuri;
																if (pData->quest_progress >= 3) {
																	pData->quest_progress = 0;
																	pData->quest_step++;
																	Player::OnTextOverlay(peer, "`9Quest step complete!!");
																	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																		if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
																		if (isHere(peer, currentPeer)) {
																			Player::OnParticleEffect(peer, 48, pData->x, pData->y, 0);
																		}
																	}
																	send_quest_view_whip(peer, pData, world);
																}
																else {
																	Player::OnTextOverlay(peer, "`9Thanks! Keep it coming!");
																}
															}
															else {
																goto goodluck;
															}
														}
														else if (pData->lastquest == "thesky" && pData->quest_step == 7) { /*BlanketCape*/
															auto KiekTuri = 0;
															for (auto i = 0; i < pData->inventory.items.size(); i++) {
																if (pData->inventory.items.at(i).itemID == 2982 && pData->inventory.items.at(i).itemCount > 0) {
																	KiekTuri = pData->inventory.items.at(i).itemCount;
																	break;
																}
															}
															if (KiekTuri != 0) {
																if (pData->quest_progress + KiekTuri > 10) KiekTuri = 10 - pData->quest_progress;
																RemoveInventoryItem(2982, KiekTuri, peer, true);
																pData->quest_progress += KiekTuri;
																if (pData->quest_progress >= 10) {
																	pData->quest_progress = 0;
																	pData->quest_step++;
																	Player::OnTextOverlay(peer, "`9Quest step complete!!");
																	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																		if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
																		if (isHere(peer, currentPeer)) {
																			Player::OnParticleEffect(peer, 48, pData->x, pData->y, 0);
																		}
																	}
																	send_quest_view_lkwing(peer, pData, world);
																}
																else {
																	Player::OnTextOverlay(peer, "`9Thanks! Keep it coming!");
																}
															}
															else {
																goto goodluck;
															}
														}
														else if (pData->lastquest == "honor" && pData->quest_step == 8 || pData->lastquest == "steel" && pData->quest_step == 8 || pData->lastquest == "fire" && pData->quest_step == 8 || pData->lastquest == "heavens" && pData->quest_step == 8 || pData->lastquest == "blade" && pData->quest_step == 8 || pData->lastquest == "candour" && pData->quest_step == 8 || pData->lastquest == "thesky" && pData->quest_step == 8) { /*xp*/
															if (pData->quest_progress >= 10000) {
																pData->quest_progress = 0;
																pData->quest_step++;
																Player::OnTextOverlay(peer, "`9Quest step complete!!");
																for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																	if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
																	if (isHere(peer, currentPeer)) {
																		Player::OnParticleEffect(peer, 48, pData->x, pData->y, 0);
																	}
																}
																if (pData->lastquest == "honor") {
																	send_quest_view(peer, pData, world);
																}
																else if (pData->lastquest == "steel") {
																	send_quest_view_bot(peer, pData, world);
																}
																else if (pData->lastquest == "fire") {
																	send_quest_view_dragon(peer, pData, world);
																}
																else if (pData->lastquest == "heavens") {
																	send_quest_view_lwing(peer, pData, world);
																}
																else if (pData->lastquest == "blade") {
																	send_quest_view_katana(peer, pData, world);
																}
																else if (pData->lastquest == "candour") {
																	send_quest_view_whip(peer, pData, world);
																}
																else if (pData->lastquest == "thesky") {
																	send_quest_view_lkwing(peer, pData, world);
																}
															}
															else {
																goto goodluck;
															}
														}
														else if (pData->lastquest == "honor" && pData->quest_step == 9) { /*Tombstone*/
															auto KiekTuri = 0;
															for (auto i = 0; i < pData->inventory.items.size(); i++) {
																if (pData->inventory.items.at(i).itemID == 784 && pData->inventory.items.at(i).itemCount > 0) {
																	KiekTuri = pData->inventory.items.at(i).itemCount;
																	break;
																}
															}
															if (KiekTuri != 0) {
																if (pData->quest_progress + KiekTuri > 800) KiekTuri = 800 - pData->quest_progress;
																RemoveInventoryItem(784, KiekTuri, peer, true);
																pData->quest_progress += KiekTuri;
																if (pData->quest_progress >= 800) {
																	pData->quest_progress = 0;
																	pData->quest_step++;
																	Player::OnTextOverlay(peer, "`9Quest step complete!!");
																	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																		if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
																		if (isHere(peer, currentPeer)) {
																			Player::OnParticleEffect(peer, 48, pData->x, pData->y, 0);
																		}
																	}
																	send_quest_view(peer, pData, world);
																}
																else {
																	Player::OnTextOverlay(peer, "`9Thanks! Keep it coming!");
																}
															}
															else {
																goto goodluck;
															}
														}
														else if (pData->lastquest == "steel" && pData->quest_step == 9) { /*HighTechBlock*/
															auto KiekTuri = 0;
															for (auto i = 0; i < pData->inventory.items.size(); i++) {
																if (pData->inventory.items.at(i).itemID == 324 && pData->inventory.items.at(i).itemCount > 0) {
																	KiekTuri = pData->inventory.items.at(i).itemCount;
																	break;
																}
															}
															if (KiekTuri != 0) {
																if (pData->quest_progress + KiekTuri > 1000) KiekTuri = 1000 - pData->quest_progress;
																RemoveInventoryItem(324, KiekTuri, peer, true);
																pData->quest_progress += KiekTuri;
																if (pData->quest_progress >= 1000) {
																	pData->quest_progress = 0;
																	pData->quest_step++;
																	Player::OnTextOverlay(peer, "`9Quest step complete!!");
																	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																		if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
																		if (isHere(peer, currentPeer)) {
																			Player::OnParticleEffect(peer, 48, pData->x, pData->y, 0);
																		}
																	}
																	send_quest_view_bot(peer, pData, world);
																}
																else {
																	Player::OnTextOverlay(peer, "`9Thanks! Keep it coming!");
																}
															}
															else {
																goto goodluck;
															}
														}
														else if (pData->lastquest == "fire" && pData->quest_step == 9) { /*DragonTail*/
															auto KiekTuri = 0;
															for (auto i = 0; i < pData->inventory.items.size(); i++) {
																if (pData->inventory.items.at(i).itemID == 1114 && pData->inventory.items.at(i).itemCount > 0) {
																	KiekTuri = pData->inventory.items.at(i).itemCount;
																	break;
																}
															}
															if (KiekTuri != 0) {
																if (pData->quest_progress + KiekTuri > 1000) KiekTuri = 1000 - pData->quest_progress;
																RemoveInventoryItem(1114, KiekTuri, peer, true);
																pData->quest_progress += KiekTuri;
																if (pData->quest_progress >= 1000) {
																	pData->quest_progress = 0;
																	pData->quest_step++;
																	Player::OnTextOverlay(peer, "`9Quest step complete!!");
																	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																		if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
																		if (isHere(peer, currentPeer)) {
																			Player::OnParticleEffect(peer, 48, pData->x, pData->y, 0);
																		}
																	}
																	send_quest_view_dragon(peer, pData, world);
																}
																else {
																	Player::OnTextOverlay(peer, "`9Thanks! Keep it coming!");
																}
															}
															else {
																goto goodluck;
															}
														}
														else if (pData->lastquest == "heavens" && pData->quest_step == 9) { /*CrimsonEagleWing*/
															auto KiekTuri = 0;
															for (auto i = 0; i < pData->inventory.items.size(); i++) {
																if (pData->inventory.items.at(i).itemID == 678 && pData->inventory.items.at(i).itemCount > 0) {
																	KiekTuri = pData->inventory.items.at(i).itemCount;
																	break;
																}
															}
															if (KiekTuri != 0) {
																if (pData->quest_progress + KiekTuri > 800) KiekTuri = 800 - pData->quest_progress;
																RemoveInventoryItem(678, KiekTuri, peer, true);
																pData->quest_progress += KiekTuri;
																if (pData->quest_progress >= 800) {
																	pData->quest_progress = 0;
																	pData->quest_step++;
																	Player::OnTextOverlay(peer, "`9Quest step complete!!");
																	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																		if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
																		if (isHere(peer, currentPeer)) {
																			Player::OnParticleEffect(peer, 48, pData->x, pData->y, 0);
																		}
																	}
																	send_quest_view_lwing(peer, pData, world);
																}
																else {
																	Player::OnTextOverlay(peer, "`9Thanks! Keep it coming!");
																}
															}
															else {
																goto goodluck;
															}
														}
														else if (pData->lastquest == "blade" && pData->quest_step == 9) { /*HeadsmanAxe*/
															auto KiekTuri = 0;
															for (auto i = 0; i < pData->inventory.items.size(); i++) {
																if (pData->inventory.items.at(i).itemID == 690 && pData->inventory.items.at(i).itemCount > 0) {
																	KiekTuri = pData->inventory.items.at(i).itemCount;
																	break;
																}
															}
															if (KiekTuri != 0) {
																if (pData->quest_progress + KiekTuri > 800) KiekTuri = 800 - pData->quest_progress;
																RemoveInventoryItem(690, KiekTuri, peer, true);
																pData->quest_progress += KiekTuri;
																if (pData->quest_progress >= 800) {
																	pData->quest_progress = 0;
																	pData->quest_step++;
																	Player::OnTextOverlay(peer, "`9Quest step complete!!");
																	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																		if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
																		if (isHere(peer, currentPeer)) {
																			Player::OnParticleEffect(peer, 48, pData->x, pData->y, 0);
																		}
																	}
																	send_quest_view_katana(peer, pData, world);
																}
																else {
																	Player::OnTextOverlay(peer, "`9Thanks! Keep it coming!");
																}
															}
															else {
																goto goodluck;
															}
														}
														else if (pData->lastquest == "candour" && pData->quest_step == 9) { /*SoulStone*/
															auto KiekTuri = 0;
															for (auto i = 0; i < pData->inventory.items.size(); i++) {
																if (pData->inventory.items.at(i).itemID == 5202 && pData->inventory.items.at(i).itemCount > 0) {
																	KiekTuri = pData->inventory.items.at(i).itemCount;
																	break;
																}
															}
															if (KiekTuri != 0) {
																if (pData->quest_progress + KiekTuri > 5) KiekTuri = 5 - pData->quest_progress;
																RemoveInventoryItem(5202, KiekTuri, peer, true);
																pData->quest_progress += KiekTuri;
																if (pData->quest_progress >= 5) {
																	pData->quest_progress = 0;
																	pData->quest_step++;
																	Player::OnTextOverlay(peer, "`9Quest step complete!!");
																	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																		if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
																		if (isHere(peer, currentPeer)) {
																			Player::OnParticleEffect(peer, 48, pData->x, pData->y, 0);
																		}
																	}
																	send_quest_view_whip(peer, pData, world);
																}
																else {
																	Player::OnTextOverlay(peer, "`9Thanks! Keep it coming!");
																}
															}
															else {
																goto goodluck;
															}
														}
														else if (pData->lastquest == "thesky" && pData->quest_step == 9) { /*BlazingElectroWing*/
															auto KiekTuri = 0;
															for (auto i = 0; i < pData->inventory.items.size(); i++) {
																if (pData->inventory.items.at(i).itemID == 1936 && pData->inventory.items.at(i).itemCount > 0) {
																	KiekTuri = pData->inventory.items.at(i).itemCount;
																	break;
																}
															}
															if (KiekTuri != 0) {
																if (pData->quest_progress + KiekTuri > 800) KiekTuri = 800 - pData->quest_progress;
																RemoveInventoryItem(1936, KiekTuri, peer, true);
																pData->quest_progress += KiekTuri;
																if (pData->quest_progress >= 800) {
																	pData->quest_progress = 0;
																	pData->quest_step++;
																	Player::OnTextOverlay(peer, "`9Quest step complete!!");
																	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																		if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
																		if (isHere(peer, currentPeer)) {
																			Player::OnParticleEffect(peer, 48, pData->x, pData->y, 0);
																		}
																	}
																	send_quest_view_lkwing(peer, pData, world);
																}
																else {
																	Player::OnTextOverlay(peer, "`9Thanks! Keep it coming!");
																}
															}
															else {
																goto goodluck;
															}
														}
														else if (pData->lastquest == "honor" && pData->quest_step == 10 || pData->lastquest == "steel" && pData->quest_step == 10 || pData->lastquest == "fire" && pData->quest_step == 10 || pData->lastquest == "heavens" && pData->quest_step == 10 || pData->lastquest == "blade" && pData->quest_step == 10 || pData->lastquest == "candour" && pData->quest_step == 10 || pData->lastquest == "thesky" && pData->quest_step == 10) { /*Gems*/
															auto KiekTuri = 0;
															auto KiekTuri2 = 0;
															std::ifstream ifsz("save/gemdb/_" + pData->rawName + ".txt");
															std::string content((std::istreambuf_iterator<char>(ifsz)), (std::istreambuf_iterator<char>()));
															KiekTuri = atoi(content.c_str());
															KiekTuri2 = atoi(content.c_str());
															if (KiekTuri != 0) {
																if (pData->quest_progress + KiekTuri > 100000) KiekTuri = 100000 - pData->quest_progress;
																auto fingembux = KiekTuri2 - KiekTuri;
																ofstream myfile;
																myfile.open("save/gemdb/_" + pData->rawName + ".txt");
																myfile << fingembux;
																myfile.close();
																int gemcalc = KiekTuri2 - KiekTuri;
																Player::OnSetBux(peer, gemcalc, 0);
																pData->quest_progress += KiekTuri;
																if (pData->quest_progress >= 100000) {
																	pData->quest_progress = 0;
																	pData->quest_step++;
																	Player::OnTextOverlay(peer, "`9Quest step complete!!");
																	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																		if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
																		if (isHere(peer, currentPeer)) {
																			Player::OnParticleEffect(peer, 48, pData->x, pData->y, 0);
																		}
																	}
																	if (pData->lastquest == "honor") {
																		send_quest_view(peer, pData, world);
																	}
																	else if (pData->lastquest == "steel") {
																		send_quest_view_bot(peer, pData, world);
																	}
																	else if (pData->lastquest == "fire") {
																		send_quest_view_dragon(peer, pData, world);
																	}
																	else if (pData->lastquest == "heavens") {
																		send_quest_view_lwing(peer, pData, world);
																	}
																	else if (pData->lastquest == "blade") {
																		send_quest_view_katana(peer, pData, world);
																	}
																	else if (pData->lastquest == "candour") {
																		send_quest_view_whip(peer, pData, world);
																	}
																	else if (pData->lastquest == "thesky") {
																		send_quest_view_lkwing(peer, pData, world);
																	}
																}
																else {
																	Player::OnTextOverlay(peer, "`9Thanks! Keep it coming!");
																}
															}
															else {
																goto goodluck;
															}
														}
														else if (pData->lastquest == "honor" && pData->quest_step == 12 || pData->lastquest == "steel" && pData->quest_step == 12 || pData->lastquest == "fire" && pData->quest_step == 12 || pData->lastquest == "heavens" && pData->quest_step == 12 || pData->lastquest == "blade" && pData->quest_step == 12 || pData->lastquest == "candour" && pData->quest_step == 12 || pData->lastquest == "thesky" && pData->quest_step == 12) { /*surgery*/
															if (pData->quest_progress >= 0) {
																pData->quest_progress = 0;
																pData->quest_step++;
																Player::OnTextOverlay(peer, "`9Quest step complete!!");
																for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																	if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
																	if (isHere(peer, currentPeer)) {
																		Player::OnParticleEffect(peer, 48, pData->x, pData->y, 0);
																	}
																}
																if (pData->lastquest == "honor") {
																	send_quest_view(peer, pData, world);
																}
																else if (pData->lastquest == "steel") {
																	send_quest_view_bot(peer, pData, world);
																}
																else if (pData->lastquest == "fire") {
																	send_quest_view_dragon(peer, pData, world);
																}
																else if (pData->lastquest == "heavens") {
																	send_quest_view_lwing(peer, pData, world);
																}
																else if (pData->lastquest == "blade") {
																	send_quest_view_katana(peer, pData, world);
																}
																else if (pData->lastquest == "candour") {
																	send_quest_view_whip(peer, pData, world);
																}
																else if (pData->lastquest == "thesky") {
																	send_quest_view_lkwing(peer, pData, world);
																}
															}
															else {
																goto goodluck;
															}
														}
														else if (pData->lastquest == "honor" && pData->quest_step == 13 || pData->lastquest == "steel" && pData->quest_step == 13 || pData->lastquest == "fire" && pData->quest_step == 13 || pData->lastquest == "heavens" && pData->quest_step == 13 || pData->lastquest == "blade" && pData->quest_step == 13 || pData->lastquest == "candour" && pData->quest_step == 13 || pData->lastquest == "thesky" && pData->quest_step == 13) { /*provider*/
															if (pData->quest_progress >= 1000) {
																pData->quest_progress = 0;
																pData->quest_step++;
																Player::OnTextOverlay(peer, "`9Quest step complete!!");
																if (pData->lastquest == "honor") {
																	send_quest_view(peer, pData, world);
																}
																else if (pData->lastquest == "steel") {
																	send_quest_view_bot(peer, pData, world);
																}
																else if (pData->lastquest == "fire") {
																	send_quest_view_dragon(peer, pData, world);
																}
																else if (pData->lastquest == "heavens") {
																	send_quest_view_lwing(peer, pData, world);
																}
																else if (pData->lastquest == "blade") {
																	send_quest_view_katana(peer, pData, world);
																}
																else if (pData->lastquest == "candour") {
																	send_quest_view_whip(peer, pData, world);
																}
																else if (pData->lastquest == "thesky") {
																	send_quest_view_lkwing(peer, pData, world);
																}
															}
															else {
																goto goodluck;
															}
														}
														else if (pData->lastquest == "honor" && pData->quest_step == 14) { /*GoldenHeartCrystal*/
															auto KiekTuri = 0;
															for (auto i = 0; i < pData->inventory.items.size(); i++) {
																if (pData->inventory.items.at(i).itemID == 1458 && pData->inventory.items.at(i).itemCount > 0) {
																	KiekTuri = pData->inventory.items.at(i).itemCount;
																	break;
																}
															}
															if (KiekTuri != 0) {
																if (pData->quest_progress + KiekTuri > 3) KiekTuri = 3 - pData->quest_progress;
																RemoveInventoryItem(1458, KiekTuri, peer, true);
																pData->quest_progress += KiekTuri;
																if (pData->quest_progress >= 3) {
																	pData->quest_progress = 0;
																	pData->quest_step++;
																	Player::OnTextOverlay(peer, "`9Quest step complete!!");
																	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																		if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
																		if (isHere(peer, currentPeer)) {
																			Player::OnParticleEffect(peer, 48, pData->x, pData->y, 0);
																		}
																	}
																	send_quest_view(peer, pData, world);
																}
																else {
																	Player::OnTextOverlay(peer, "`9Thanks! Keep it coming!");
																}
															}
															else {
																goto goodluck;
															}
														}
														else if (pData->lastquest == "steel" && pData->quest_step == 14) { /*rideOfReanimatorRemote*/
															auto KiekTuri = 0;
															for (auto i = 0; i < pData->inventory.items.size(); i++) {
																if (pData->inventory.items.at(i).itemID == 1250 && pData->inventory.items.at(i).itemCount > 0) {
																	KiekTuri = pData->inventory.items.at(i).itemCount;
																	break;
																}
															}
															if (KiekTuri != 0) {
																if (pData->quest_progress + KiekTuri > 3) KiekTuri = 3 - pData->quest_progress;
																RemoveInventoryItem(1250, KiekTuri, peer, true);
																pData->quest_progress += KiekTuri;
																if (pData->quest_progress >= 3) {
																	pData->quest_progress = 0;
																	pData->quest_step++;
																	Player::OnTextOverlay(peer, "`9Quest step complete!!");
																	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																		if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
																		if (isHere(peer, currentPeer)) {
																			Player::OnParticleEffect(peer, 48, pData->x, pData->y, 0);
																		}
																	}
																	send_quest_view_bot(peer, pData, world);
																}
																else {
																	Player::OnTextOverlay(peer, "`9Thanks! Keep it coming!");
																}
															}
															else {
																goto goodluck;
															}
														}
														else if (pData->lastquest == "fire" && pData->quest_step == 14) { /*FiestaDragon*/
															auto KiekTuri = 0;
															for (auto i = 0; i < pData->inventory.items.size(); i++) {
																if (pData->inventory.items.at(i).itemID == 1576 && pData->inventory.items.at(i).itemCount > 0) {
																	KiekTuri = pData->inventory.items.at(i).itemCount;
																	break;
																}
															}
															if (KiekTuri != 0) {
																if (pData->quest_progress + KiekTuri > 3) KiekTuri = 3 - pData->quest_progress;
																RemoveInventoryItem(1576, KiekTuri, peer, true);
																pData->quest_progress += KiekTuri;
																if (pData->quest_progress >= 3) {
																	pData->quest_progress = 0;
																	pData->quest_step++;
																	Player::OnTextOverlay(peer, "`9Quest step complete!!");
																	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																		if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
																		if (isHere(peer, currentPeer)) {
																			Player::OnParticleEffect(peer, 48, pData->x, pData->y, 0);
																		}
																	}
																	send_quest_view_dragon(peer, pData, world);
																}
																else {
																	Player::OnTextOverlay(peer, "`9Thanks! Keep it coming!");
																}
															}
															else {
																goto goodluck;
															}
														}
														else if (pData->lastquest == "heavens" && pData->quest_step == 14) { /*RainbowWing*/
															auto KiekTuri = 0;
															for (auto i = 0; i < pData->inventory.items.size(); i++) {
																if (pData->inventory.items.at(i).itemID == 1672 && pData->inventory.items.at(i).itemCount > 0) {
																	KiekTuri = pData->inventory.items.at(i).itemCount;
																	break;
																}
															}
															if (KiekTuri != 0) {
																if (pData->quest_progress + KiekTuri > 20) KiekTuri = 20 - pData->quest_progress;
																RemoveInventoryItem(1672, KiekTuri, peer, true);
																pData->quest_progress += KiekTuri;
																if (pData->quest_progress >= 20) {
																	pData->quest_progress = 0;
																	pData->quest_step++;
																	Player::OnTextOverlay(peer, "`9Quest step complete!!");
																	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																		if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
																		if (isHere(peer, currentPeer)) {
																			Player::OnParticleEffect(peer, 48, pData->x, pData->y, 0);
																		}
																	}
																	send_quest_view_lwing(peer, pData, world);
																}
																else {
																	Player::OnTextOverlay(peer, "`9Thanks! Keep it coming!");
																}
															}
															else {
																goto goodluck;
															}
														}
														else if (pData->lastquest == "blade" && pData->quest_step == 14) { /*FlameSaber*/
															auto KiekTuri = 0;
															for (auto i = 0; i < pData->inventory.items.size(); i++) {
																if (pData->inventory.items.at(i).itemID == 810 && pData->inventory.items.at(i).itemCount > 0) {
																	KiekTuri = pData->inventory.items.at(i).itemCount;
																	break;
																}
															}
															if (KiekTuri != 0) {
																if (pData->quest_progress + KiekTuri > 20) KiekTuri = 20 - pData->quest_progress;
																RemoveInventoryItem(810, KiekTuri, peer, true);
																pData->quest_progress += KiekTuri;
																if (pData->quest_progress >= 20) {
																	pData->quest_progress = 0;
																	pData->quest_step++;
																	Player::OnTextOverlay(peer, "`9Quest step complete!!");
																	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																		if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
																		if (isHere(peer, currentPeer)) {
																			Player::OnParticleEffect(peer, 48, pData->x, pData->y, 0);
																		}
																	}
																	send_quest_view_katana(peer, pData, world);
																}
																else {
																	Player::OnTextOverlay(peer, "`9Thanks! Keep it coming!");
																}
															}
															else {
																goto goodluck;
															}
														}
														else if (pData->lastquest == "candour" && pData->quest_step == 14) { /*CelestianLance*/
															auto KiekTuri = 0;
															for (auto i = 0; i < pData->inventory.items.size(); i++) {
																if (pData->inventory.items.at(i).itemID == 5276 && pData->inventory.items.at(i).itemCount > 0) {
																	KiekTuri = pData->inventory.items.at(i).itemCount;
																	break;
																}
															}
															if (KiekTuri != 0) {
																if (pData->quest_progress + KiekTuri > 3) KiekTuri = 3 - pData->quest_progress;
																RemoveInventoryItem(5276, KiekTuri, peer, true);
																pData->quest_progress += KiekTuri;
																if (pData->quest_progress >= 3) {
																	pData->quest_progress = 0;
																	pData->quest_step++;
																	Player::OnTextOverlay(peer, "`9Quest step complete!!");
																	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																		if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
																		if (isHere(peer, currentPeer)) {
																			Player::OnParticleEffect(peer, 48, pData->x, pData->y, 0);
																		}
																	}
																	send_quest_view_whip(peer, pData, world);
																}
																else {
																	Player::OnTextOverlay(peer, "`9Thanks! Keep it coming!");
																}
															}
															else {
																goto goodluck;
															}
														}
														else if (pData->lastquest == "thesky" && pData->quest_step == 14) { /*AutumnWing*/
															auto KiekTuri = 0;
															for (auto i = 0; i < pData->inventory.items.size(); i++) {
																if (pData->inventory.items.at(i).itemID == 1824 && pData->inventory.items.at(i).itemCount > 0) {
																	KiekTuri = pData->inventory.items.at(i).itemCount;
																	break;
																}
															}
															if (KiekTuri != 0) {
																if (pData->quest_progress + KiekTuri > 10) KiekTuri = 10 - pData->quest_progress;
																RemoveInventoryItem(1824, KiekTuri, peer, true);
																pData->quest_progress += KiekTuri;
																if (pData->quest_progress >= 10) {
																	pData->quest_progress = 0;
																	pData->quest_step++;
																	Player::OnTextOverlay(peer, "`9Quest step complete!!");
																	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																		if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
																		if (isHere(peer, currentPeer)) {
																			Player::OnParticleEffect(peer, 48, pData->x, pData->y, 0);
																		}
																	}
																	send_quest_view_lkwing(peer, pData, world);
																}
																else {
																	Player::OnTextOverlay(peer, "`9Thanks! Keep it coming!");
																}
															}
															else {
																goto goodluck;
															}
														}
														else if (pData->lastquest == "honor" && pData->quest_step == 15 || pData->lastquest == "steel" && pData->quest_step == 15 || pData->lastquest == "fire" && pData->quest_step == 15 || pData->lastquest == "heavens" && pData->quest_step == 15 || pData->lastquest == "blade" && pData->quest_step == 15 || pData->lastquest == "candour" && pData->quest_step == 15 || pData->lastquest == "thesky" && pData->quest_step == 15) { /*fruit*/
															if (pData->quest_progress >= 100000) {
																pData->quest_progress = 0;
																pData->quest_step++;
																Player::OnTextOverlay(peer, "`9Quest step complete!!");
																for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																	if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
																	if (isHere(peer, currentPeer)) {
																		Player::OnParticleEffect(peer, 48, pData->x, pData->y, 0);
																	}
																}
																if (pData->lastquest == "honor") {
																	send_quest_view(peer, pData, world);
																}
																else if (pData->lastquest == "steel") {
																	send_quest_view_bot(peer, pData, world);
																}
																else if (pData->lastquest == "fire") {
																	send_quest_view_dragon(peer, pData, world);
																}
																else if (pData->lastquest == "heavens") {
																	send_quest_view_lwing(peer, pData, world);
																}
																else if (pData->lastquest == "blade") {
																	send_quest_view_katana(peer, pData, world);
																}
																else if (pData->lastquest == "candour") {
																	send_quest_view_whip(peer, pData, world);
																}
																else if (pData->lastquest == "thesky") {
																	send_quest_view_lkwing(peer, pData, world);
																}
															}
															else {
																goto goodluck;
															}
														}
														else if (pData->lastquest == "honor" && pData->quest_step == 16) { /*Growieaward*/
															auto KiekTuri = 0;
															for (auto i = 0; i < pData->inventory.items.size(); i++) {
																if (pData->inventory.items.at(i).itemID == 1614 && pData->inventory.items.at(i).itemCount > 0) {
																	KiekTuri = pData->inventory.items.at(i).itemCount;
																	break;
																}
															}
															if (KiekTuri != 0) {
																if (pData->quest_progress + KiekTuri > 1) KiekTuri = 1 - pData->quest_progress;
																RemoveInventoryItem(1614, KiekTuri, peer, true);
																pData->quest_progress += KiekTuri;
																if (pData->quest_progress >= 1) {
																	pData->quest_progress = 0;
																	pData->quest_step++;
																	Player::OnTextOverlay(peer, "`9Quest step complete!!");
																	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																		if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
																		if (isHere(peer, currentPeer)) {
																			Player::OnParticleEffect(peer, 48, pData->x, pData->y, 0);
																		}
																	}
																	send_quest_view(peer, pData, world);
																}
																else {
																	Player::OnTextOverlay(peer, "`9Thanks! Keep it coming!");
																}
															}
															else {
																goto goodluck;
															}
														}
														else if (pData->lastquest == "steel" && pData->quest_step == 16) { /*MintJulep*/
															auto KiekTuri = 0;
															for (auto i = 0; i < pData->inventory.items.size(); i++) {
																if (pData->inventory.items.at(i).itemID == 1602 && pData->inventory.items.at(i).itemCount > 0) {
																	KiekTuri = pData->inventory.items.at(i).itemCount;
																	break;
																}
															}
															if (KiekTuri != 0) {
																if (pData->quest_progress + KiekTuri > 1) KiekTuri = 1 - pData->quest_progress;
																RemoveInventoryItem(1602, KiekTuri, peer, true);
																pData->quest_progress += KiekTuri;
																if (pData->quest_progress >= 1) {
																	pData->quest_progress = 0;
																	pData->quest_step++;
																	Player::OnTextOverlay(peer, "`9Quest step complete!!");
																	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																		if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
																		if (isHere(peer, currentPeer)) {
																			Player::OnParticleEffect(peer, 48, pData->x, pData->y, 0);
																		}
																	}
																	send_quest_view_bot(peer, pData, world);
																}
																else {
																	Player::OnTextOverlay(peer, "`9Thanks! Keep it coming!");
																}
															}
															else {
																goto goodluck;
															}
														}
														else if (pData->lastquest == "fire" && pData->quest_step == 16) { /*WOTDTrophy*/
															auto KiekTuri = 0;
															for (auto i = 0; i < pData->inventory.items.size(); i++) {
																if (pData->inventory.items.at(i).itemID == 10574 && pData->inventory.items.at(i).itemCount > 0) {
																	KiekTuri = pData->inventory.items.at(i).itemCount;
																	break;
																}
															}
															if (KiekTuri != 0) {
																if (pData->quest_progress + KiekTuri > 1) KiekTuri = 1 - pData->quest_progress;
																RemoveInventoryItem(10574, KiekTuri, peer, true);
																pData->quest_progress += KiekTuri;
																if (pData->quest_progress >= 1) {
																	pData->quest_progress = 0;
																	pData->quest_step++;
																	Player::OnTextOverlay(peer, "`9Quest step complete!!");
																	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																		if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
																		if (isHere(peer, currentPeer)) {
																			Player::OnParticleEffect(peer, 48, pData->x, pData->y, 0);
																		}
																	}
																	send_quest_view_dragon(peer, pData, world);
																}
																else {
																	Player::OnTextOverlay(peer, "`9Thanks! Keep it coming!");
																}
															}
															else {
																goto goodluck;
															}
														}
														else if (pData->lastquest == "heavens" && pData->quest_step == 16) { /*GoldenAngelWing*/
															auto KiekTuri = 0;
															for (auto i = 0; i < pData->inventory.items.size(); i++) {
																if (pData->inventory.items.at(i).itemID == 1460 && pData->inventory.items.at(i).itemCount > 0) {
																	KiekTuri = pData->inventory.items.at(i).itemCount;
																	break;
																}
															}
															if (KiekTuri != 0) {
																if (pData->quest_progress + KiekTuri > 3) KiekTuri = 3 - pData->quest_progress;
																RemoveInventoryItem(1460, KiekTuri, peer, true);
																pData->quest_progress += KiekTuri;
																if (pData->quest_progress >= 3) {
																	pData->quest_progress = 0;
																	pData->quest_step++;
																	Player::OnTextOverlay(peer, "`9Quest step complete!!");
																	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																		if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
																		if (isHere(peer, currentPeer)) {
																			Player::OnParticleEffect(peer, 48, pData->x, pData->y, 0);
																		}
																	}
																	send_quest_view_lwing(peer, pData, world);
																}
																else {
																	Player::OnTextOverlay(peer, "`9Thanks! Keep it coming!");
																}
															}
															else {
																goto goodluck;
															}
														}
														else if (pData->lastquest == "blade" && pData->quest_step == 16) { /*GoldenApple*/
															auto KiekTuri = 0;
															for (auto i = 0; i < pData->inventory.items.size(); i++) {
																if (pData->inventory.items.at(i).itemID == 2002 && pData->inventory.items.at(i).itemCount > 0) {
																	KiekTuri = pData->inventory.items.at(i).itemCount;
																	break;
																}
															}
															if (KiekTuri != 0) {
																if (pData->quest_progress + KiekTuri > 1) KiekTuri = 1 - pData->quest_progress;
																RemoveInventoryItem(2002, KiekTuri, peer, true);
																pData->quest_progress += KiekTuri;
																if (pData->quest_progress >= 1) {
																	pData->quest_progress = 0;
																	pData->quest_step++;
																	Player::OnTextOverlay(peer, "`9Quest step complete!!");
																	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																		if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
																		if (isHere(peer, currentPeer)) {
																			Player::OnParticleEffect(peer, 48, pData->x, pData->y, 0);
																		}
																	}
																	send_quest_view_katana(peer, pData, world);
																}
																else {
																	Player::OnTextOverlay(peer, "`9Thanks! Keep it coming!");
																}
															}
															else {
																goto goodluck;
															}
														}
														else if (pData->lastquest == "candour" && pData->quest_step == 16) { /*RingofShrinking*/
															auto KiekTuri = 0;
															for (auto i = 0; i < pData->inventory.items.size(); i++) {
																if (pData->inventory.items.at(i).itemID == 6028 && pData->inventory.items.at(i).itemCount > 0) {
																	KiekTuri = pData->inventory.items.at(i).itemCount;
																	break;
																}
															}
															if (KiekTuri != 0) {
																if (pData->quest_progress + KiekTuri > 5) KiekTuri = 5 - pData->quest_progress;
																RemoveInventoryItem(6028, KiekTuri, peer, true);
																pData->quest_progress += KiekTuri;
																if (pData->quest_progress >= 5) {
																	pData->quest_progress = 0;
																	pData->quest_step++;
																	Player::OnTextOverlay(peer, "`9Quest step complete!!");
																	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																		if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
																		if (isHere(peer, currentPeer)) {
																			Player::OnParticleEffect(peer, 48, pData->x, pData->y, 0);
																		}
																	}
																	send_quest_view_whip(peer, pData, world);
																}
																else {
																	Player::OnTextOverlay(peer, "`9Thanks! Keep it coming!");
																}
															}
															else {
																goto goodluck;
															}
														}
														else if (pData->lastquest == "thesky" && pData->quest_step == 16) { /*GoldenDragonStatue*/
															auto KiekTuri = 0;
															for (auto i = 0; i < pData->inventory.items.size(); i++) {
																if (pData->inventory.items.at(i).itemID == 4302 && pData->inventory.items.at(i).itemCount > 0) {
																	KiekTuri = pData->inventory.items.at(i).itemCount;
																	break;
																}
															}
															if (KiekTuri != 0) {
																if (pData->quest_progress + KiekTuri > 1) KiekTuri = 1 - pData->quest_progress;
																RemoveInventoryItem(4302, KiekTuri, peer, true);
																pData->quest_progress += KiekTuri;
																if (pData->quest_progress >= 1) {
																	pData->quest_progress = 0;
																	pData->quest_step++;
																	Player::OnTextOverlay(peer, "`9Quest step complete!!");
																	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																		if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
																		if (isHere(peer, currentPeer)) {
																			Player::OnParticleEffect(peer, 48, pData->x, pData->y, 0);
																		}
																	}
																	send_quest_view_lkwing(peer, pData, world);
																}
																else {
																	Player::OnTextOverlay(peer, "`9Thanks! Keep it coming!");
																}
															}
															else {
																goto goodluck;
															}
														}
														else if (pData->lastquest == "honor" && pData->quest_step == 17) { /*SuperFirework*/
															auto KiekTuri = 0;
															for (auto i = 0; i < pData->inventory.items.size(); i++) {
																if (pData->inventory.items.at(i).itemID == 1680 && pData->inventory.items.at(i).itemCount > 0) {
																	KiekTuri = pData->inventory.items.at(i).itemCount;
																	break;
																}
															}
															if (KiekTuri != 0) {
																if (pData->quest_progress + KiekTuri > 3) KiekTuri = 3 - pData->quest_progress;
																RemoveInventoryItem(1680, KiekTuri, peer, true);
																pData->quest_progress += KiekTuri;
																if (pData->quest_progress >= 3) {
																	pData->quest_progress = 0;
																	pData->quest_step++;
																	Player::OnTextOverlay(peer, "`9Quest step complete!!");
																	send_quest_view(peer, pData, world);
																}
																else {
																	Player::OnTextOverlay(peer, "`9Thanks! Keep it coming!");
																}
															}
															else {
																goto goodluck;
															}
														}
														else if (pData->lastquest == "steel" && pData->quest_step == 17) { /*Kerjigger*/
															auto KiekTuri = 0;
															for (auto i = 0; i < pData->inventory.items.size(); i++) {
																if (pData->inventory.items.at(i).itemID == 1354 && pData->inventory.items.at(i).itemCount > 0) {
																	KiekTuri = pData->inventory.items.at(i).itemCount;
																	break;
																}
															}
															if (KiekTuri != 0) {
																if (pData->quest_progress + KiekTuri > 5) KiekTuri = 5 - pData->quest_progress;
																RemoveInventoryItem(1354, KiekTuri, peer, true);
																pData->quest_progress += KiekTuri;
																if (pData->quest_progress >= 5) {
																	pData->quest_progress = 0;
																	pData->quest_step++;
																	Player::OnTextOverlay(peer, "`9Quest step complete!!");
																	send_quest_view_bot(peer, pData, world);
																}
																else {
																	Player::OnTextOverlay(peer, "`9Thanks! Keep it coming!");
																}
															}
															else {
																goto goodluck;
															}
														}
														else if (pData->lastquest == "fire" && pData->quest_step == 17) { /*IceDragonHand*/
															auto KiekTuri = 0;
															for (auto i = 0; i < pData->inventory.items.size(); i++) {
																if (pData->inventory.items.at(i).itemID == 1378 && pData->inventory.items.at(i).itemCount > 0) {
																	KiekTuri = pData->inventory.items.at(i).itemCount;
																	break;
																}
															}
															if (KiekTuri != 0) {
																if (pData->quest_progress + KiekTuri > 3) KiekTuri = 3 - pData->quest_progress;
																RemoveInventoryItem(1378, KiekTuri, peer, true);
																pData->quest_progress += KiekTuri;
																if (pData->quest_progress >= 3) {
																	pData->quest_progress = 0;
																	pData->quest_step++;
																	Player::OnTextOverlay(peer, "`9Quest step complete!!");
																	send_quest_view_dragon(peer, pData, world);
																}
																else {
																	Player::OnTextOverlay(peer, "`9Thanks! Keep it coming!");
																}
															}
															else {
																goto goodluck;
															}
														}
														else if (pData->lastquest == "heavens" && pData->quest_step == 17) { /*RipperWing*/
															auto KiekTuri = 0;
															for (auto i = 0; i < pData->inventory.items.size(); i++) {
																if (pData->inventory.items.at(i).itemID == 818 && pData->inventory.items.at(i).itemCount > 0) {
																	KiekTuri = pData->inventory.items.at(i).itemCount;
																	break;
																}
															}
															if (KiekTuri != 0) {
																if (pData->quest_progress + KiekTuri > 100) KiekTuri = 100 - pData->quest_progress;
																RemoveInventoryItem(818, KiekTuri, peer, true);
																pData->quest_progress += KiekTuri;
																if (pData->quest_progress >= 100) {
																	pData->quest_progress = 0;
																	pData->quest_step++;
																	Player::OnTextOverlay(peer, "`9Quest step complete!!");
																	send_quest_view_lwing(peer, pData, world);
																}
																else {
																	Player::OnTextOverlay(peer, "`9Thanks! Keep it coming!");
																}
															}
															else {
																goto goodluck;
															}
														}
														else if (pData->lastquest == "blade" && pData->quest_step == 17) { /*Much-Too-SmallYellowShirt*/
															auto KiekTuri = 0;
															for (auto i = 0; i < pData->inventory.items.size(); i++) {
																if (pData->inventory.items.at(i).itemID == 2456 && pData->inventory.items.at(i).itemCount > 0) {
																	KiekTuri = pData->inventory.items.at(i).itemCount;
																	break;
																}
															}
															if (KiekTuri != 0) {
																if (pData->quest_progress + KiekTuri > 10) KiekTuri = 10 - pData->quest_progress;
																RemoveInventoryItem(2456, KiekTuri, peer, true);
																pData->quest_progress += KiekTuri;
																if (pData->quest_progress >= 10) {
																	pData->quest_progress = 0;
																	pData->quest_step++;
																	Player::OnTextOverlay(peer, "`9Quest step complete!!");
																	send_quest_view_katana(peer, pData, world);
																}
																else {
																	Player::OnTextOverlay(peer, "`9Thanks! Keep it coming!");
																}
															}
															else {
																goto goodluck;
															}
														}
														else if (pData->lastquest == "candour" && pData->quest_step == 17) { /*GoldenTalaria*/
															auto KiekTuri = 0;
															for (auto i = 0; i < pData->inventory.items.size(); i++) {
																if (pData->inventory.items.at(i).itemID == 5650 && pData->inventory.items.at(i).itemCount > 0) {
																	KiekTuri = pData->inventory.items.at(i).itemCount;
																	break;
																}
															}
															if (KiekTuri != 0) {
																if (pData->quest_progress + KiekTuri > 3) KiekTuri = 3 - pData->quest_progress;
																RemoveInventoryItem(5650, KiekTuri, peer, true);
																pData->quest_progress += KiekTuri;
																if (pData->quest_progress >= 3) {
																	pData->quest_progress = 0;
																	pData->quest_step++;
																	Player::OnTextOverlay(peer, "`9Quest step complete!!");
																	send_quest_view_whip(peer, pData, world);
																}
																else {
																	Player::OnTextOverlay(peer, "`9Thanks! Keep it coming!");
																}
															}
															else {
																goto goodluck;
															}
														}
														else if (pData->lastquest == "thesky" && pData->quest_step == 17) { /*ChaosDragon*/
															auto KiekTuri = 0;
															for (auto i = 0; i < pData->inventory.items.size(); i++) {
																if (pData->inventory.items.at(i).itemID == 7762 && pData->inventory.items.at(i).itemCount > 0) {
																	KiekTuri = pData->inventory.items.at(i).itemCount;
																	break;
																}
															}
															if (KiekTuri != 0) {
																if (pData->quest_progress + KiekTuri > 5) KiekTuri = 5 - pData->quest_progress;
																RemoveInventoryItem(7762, KiekTuri, peer, true);
																pData->quest_progress += KiekTuri;
																if (pData->quest_progress >= 5) {
																	pData->quest_progress = 0;
																	pData->quest_step++;
																	Player::OnTextOverlay(peer, "`9Quest step complete!!");
																	send_quest_view_lkwing(peer, pData, world);
																}
																else {
																	Player::OnTextOverlay(peer, "`9Thanks! Keep it coming!");
																}
															}
															else {
																goto goodluck;
															}
														}
														else if (pData->lastquest == "honor" && pData->quest_step == 18) { /*RainbowWing*/
															auto KiekTuri = 0;
															for (auto i = 0; i < pData->inventory.items.size(); i++) {
																if (pData->inventory.items.at(i).itemID == 1672 && pData->inventory.items.at(i).itemCount > 0) {
																	KiekTuri = pData->inventory.items.at(i).itemCount;
																	break;
																}
															}
															if (KiekTuri != 0) {
																if (pData->quest_progress + KiekTuri > 3) KiekTuri = 3 - pData->quest_progress;
																RemoveInventoryItem(1672, KiekTuri, peer, true);
																pData->quest_progress += KiekTuri;
																if (pData->quest_progress >= 3) {
																	pData->quest_progress = 0;
																	pData->quest_step++;
																	Player::OnTextOverlay(peer, "`9Quest step complete!!");
																	send_quest_view(peer, pData, world);
																}
																else {
																	Player::OnTextOverlay(peer, "`9Thanks! Keep it coming!");
																}
															}
															else {
																goto goodluck;
															}
														}
														else if (pData->lastquest == "steel" && pData->quest_step == 18) { /*Doohickey*/
															auto KiekTuri = 0;
															for (auto i = 0; i < pData->inventory.items.size(); i++) {
																if (pData->inventory.items.at(i).itemID == 1396 && pData->inventory.items.at(i).itemCount > 0) {
																	KiekTuri = pData->inventory.items.at(i).itemCount;
																	break;
																}
															}
															if (KiekTuri != 0) {
																if (pData->quest_progress + KiekTuri > 5) KiekTuri = 5 - pData->quest_progress;
																RemoveInventoryItem(1396, KiekTuri, peer, true);
																pData->quest_progress += KiekTuri;
																if (pData->quest_progress >= 5) {
																	pData->quest_progress = 0;
																	pData->quest_step++;
																	Player::OnTextOverlay(peer, "`9Quest step complete!!");
																	send_quest_view_bot(peer, pData, world);
																}
																else {
																	Player::OnTextOverlay(peer, "`9Thanks! Keep it coming!");
																}
															}
															else {
																goto goodluck;
															}
														}
														else if (pData->lastquest == "fire" && pData->quest_step == 18) { /*RocketThruster*/
															auto KiekTuri = 0;
															for (auto i = 0; i < pData->inventory.items.size(); i++) {
																if (pData->inventory.items.at(i).itemID == 1128 && pData->inventory.items.at(i).itemCount > 0) {
																	KiekTuri = pData->inventory.items.at(i).itemCount;
																	break;
																}
															}
															if (KiekTuri != 0) {
																if (pData->quest_progress + KiekTuri > 1000) KiekTuri = 1000 - pData->quest_progress;
																RemoveInventoryItem(1128, KiekTuri, peer, true);
																pData->quest_progress += KiekTuri;
																if (pData->quest_progress >= 1000) {
																	pData->quest_progress = 0;
																	pData->quest_step++;
																	Player::OnTextOverlay(peer, "`9Quest step complete!!");
																	send_quest_view_dragon(peer, pData, world);
																}
																else {
																	Player::OnTextOverlay(peer, "`9Thanks! Keep it coming!");
																}
															}
															else {
																goto goodluck;
															}
														}
														else if (pData->lastquest == "heavens" && pData->quest_step == 18) { /*PhoenixWing*/
															auto KiekTuri = 0;
															for (auto i = 0; i < pData->inventory.items.size(); i++) {
																if (pData->inventory.items.at(i).itemID == 1674 && pData->inventory.items.at(i).itemCount > 0) {
																	KiekTuri = pData->inventory.items.at(i).itemCount;
																	break;
																}
															}
															if (KiekTuri != 0) {
																if (pData->quest_progress + KiekTuri > 1) KiekTuri = 1 - pData->quest_progress;
																RemoveInventoryItem(1674, KiekTuri, peer, true);
																pData->quest_progress += KiekTuri;
																if (pData->quest_progress >= 1) {
																	pData->quest_progress = 0;
																	pData->quest_step++;
																	Player::OnTextOverlay(peer, "`9Quest step complete!!");
																	send_quest_view_lwing(peer, pData, world);
																}
																else {
																	Player::OnTextOverlay(peer, "`9Thanks! Keep it coming!");
																}
															}
															else {
																goto goodluck;
															}
														}
														else if (pData->lastquest == "blade" && pData->quest_step == 18) { /*FlameScythe*/
															auto KiekTuri = 0;
															for (auto i = 0; i < pData->inventory.items.size(); i++) {
																if (pData->inventory.items.at(i).itemID == 2572 && pData->inventory.items.at(i).itemCount > 0) {
																	KiekTuri = pData->inventory.items.at(i).itemCount;
																	break;
																}
															}
															if (KiekTuri != 0) {
																if (pData->quest_progress + KiekTuri > 20) KiekTuri = 20 - pData->quest_progress;
																RemoveInventoryItem(2582, KiekTuri, peer, true);
																pData->quest_progress += KiekTuri;
																if (pData->quest_progress >= 20) {
																	pData->quest_progress = 0;
																	pData->quest_step++;
																	Player::OnTextOverlay(peer, "`9Quest step complete!!");
																	send_quest_view_katana(peer, pData, world);
																}
																else {
																	Player::OnTextOverlay(peer, "`9Thanks! Keep it coming!");
																}
															}
															else {
																goto goodluck;
															}
														}
														else if (pData->lastquest == "candour" && pData->quest_step == 18) { /*AncestralTotemOfWidom*/
															auto KiekTuri = 0;
															for (auto i = 0; i < pData->inventory.items.size(); i++) {
																if (pData->inventory.items.at(i).itemID == 5078 && pData->inventory.items.at(i).itemCount > 0) {
																	KiekTuri = pData->inventory.items.at(i).itemCount;
																	break;
																}
															}
															if (KiekTuri != 0) {
																if (pData->quest_progress + KiekTuri > 3) KiekTuri = 3 - pData->quest_progress;
																RemoveInventoryItem(5078, KiekTuri, peer, true);
																pData->quest_progress += KiekTuri;
																if (pData->quest_progress >= 3) {
																	pData->quest_progress = 0;
																	pData->quest_step++;
																	Player::OnTextOverlay(peer, "`9Quest step complete!!");
																	send_quest_view_whip(peer, pData, world);
																}
																else {
																	Player::OnTextOverlay(peer, "`9Thanks! Keep it coming!");
																}
															}
															else {
																goto goodluck;
															}
														}
														else if (pData->lastquest == "thesky" && pData->quest_step == 18) { /*DraconicWing*/
															auto KiekTuri = 0;
															for (auto i = 0; i < pData->inventory.items.size(); i++) {
																if (pData->inventory.items.at(i).itemID == 5754 && pData->inventory.items.at(i).itemCount > 0) {
																	KiekTuri = pData->inventory.items.at(i).itemCount;
																	break;
																}
															}
															if (KiekTuri != 0) {
																if (pData->quest_progress + KiekTuri > 1) KiekTuri = 1 - pData->quest_progress;
																RemoveInventoryItem(5754, KiekTuri, peer, true);
																pData->quest_progress += KiekTuri;
																if (pData->quest_progress >= 1) {
																	pData->quest_progress = 0;
																	pData->quest_step++;
																	Player::OnTextOverlay(peer, "`9Quest step complete!!");
																	send_quest_view_lkwing(peer, pData, world);
																}
																else {
																	Player::OnTextOverlay(peer, "`9Thanks! Keep it coming!");
																}
															}
															else {
																goto goodluck;
															}
														}
														else if (pData->lastquest == "honor" && pData->quest_step == 19) { /*BirthCertificate*/
															auto KiekTuri = 0;
															for (auto i = 0; i < pData->inventory.items.size(); i++) {
																if (pData->inventory.items.at(i).itemID == 1280 && pData->inventory.items.at(i).itemCount > 0) {
																	KiekTuri = pData->inventory.items.at(i).itemCount;
																	break;
																}
															}
															if (KiekTuri != 0) {
																if (pData->quest_progress + KiekTuri > 3) KiekTuri = 3 - pData->quest_progress;
																RemoveInventoryItem(1280, KiekTuri, peer, true);
																pData->quest_progress += KiekTuri;
																if (pData->quest_progress >= 3) {
																	pData->quest_progress = 0;
																	pData->quest_step++;
																	Player::OnTextOverlay(peer, "`9Quest step complete!!");
																	send_quest_view(peer, pData, world);
																}
																else {
																	Player::OnTextOverlay(peer, "`9Thanks! Keep it coming!");
																}
															}
															else {
																goto goodluck;
															}
														}
														else if (pData->lastquest == "steel" && pData->quest_step == 19) { /*Thingamabob*/
															auto KiekTuri = 0;
															for (auto i = 0; i < pData->inventory.items.size(); i++) {
																if (pData->inventory.items.at(i).itemID == 8284 && pData->inventory.items.at(i).itemCount > 0) {
																	KiekTuri = pData->inventory.items.at(i).itemCount;
																	break;
																}
															}
															if (KiekTuri != 0) {
																if (pData->quest_progress + KiekTuri > 2) KiekTuri = 2 - pData->quest_progress;
																RemoveInventoryItem(8284, KiekTuri, peer, true);
																pData->quest_progress += KiekTuri;
																if (pData->quest_progress >= 2) {
																	pData->quest_progress = 0;
																	pData->quest_step++;
																	Player::OnTextOverlay(peer, "`9Quest step complete!!");
																	send_quest_view_bot(peer, pData, world);
																}
																else {
																	Player::OnTextOverlay(peer, "`9Thanks! Keep it coming!");
																}
															}
															else {
																goto goodluck;
															}
														}
														else if (pData->lastquest == "fire" && pData->quest_step == 19) { /*DevilWing*/
															auto KiekTuri = 0;
															for (auto i = 0; i < pData->inventory.items.size(); i++) {
																if (pData->inventory.items.at(i).itemID == 1206 && pData->inventory.items.at(i).itemCount > 0) {
																	KiekTuri = pData->inventory.items.at(i).itemCount;
																	break;
																}
															}
															if (KiekTuri != 0) {
																if (pData->quest_progress + KiekTuri > 3) KiekTuri = 3 - pData->quest_progress;
																RemoveInventoryItem(1206, KiekTuri, peer, true);
																pData->quest_progress += KiekTuri;
																if (pData->quest_progress >= 3) {
																	pData->quest_progress = 0;
																	pData->quest_step++;
																	Player::OnTextOverlay(peer, "`9Quest step complete!!");
																	send_quest_view_dragon(peer, pData, world);
																}
																else {
																	Player::OnTextOverlay(peer, "`9Thanks! Keep it coming!");
																}
															}
															else {
																goto goodluck;
															}
														}
														else if (pData->lastquest == "heavens" && pData->quest_step == 19) { /*ParrotWing*/
															auto KiekTuri = 0;
															for (auto i = 0; i < pData->inventory.items.size(); i++) {
																if (pData->inventory.items.at(i).itemID == 1574 && pData->inventory.items.at(i).itemCount > 0) {
																	KiekTuri = pData->inventory.items.at(i).itemCount;
																	break;
																}
															}
															if (KiekTuri != 0) {
																if (pData->quest_progress + KiekTuri > 50) KiekTuri = 50 - pData->quest_progress;
																RemoveInventoryItem(1574, KiekTuri, peer, true);
																pData->quest_progress += KiekTuri;
																if (pData->quest_progress >= 50) {
																	pData->quest_progress = 0;
																	pData->quest_step++;
																	Player::OnTextOverlay(peer, "`9Quest step complete!!");
																	send_quest_view_lwing(peer, pData, world);
																}
																else {
																	Player::OnTextOverlay(peer, "`9Thanks! Keep it coming!");
																}
															}
															else {
																goto goodluck;
															}
														}
														else if (pData->lastquest == "blade" && pData->quest_step == 19) { /*CrystalGlaive*/
															auto KiekTuri = 0;
															for (auto i = 0; i < pData->inventory.items.size(); i++) {
																if (pData->inventory.items.at(i).itemID == 2266 && pData->inventory.items.at(i).itemCount > 0) {
																	KiekTuri = pData->inventory.items.at(i).itemCount;
																	break;
																}
															}
															if (KiekTuri != 0) {
																if (pData->quest_progress + KiekTuri > 20) KiekTuri = 20 - pData->quest_progress;
																RemoveInventoryItem(2266, KiekTuri, peer, true);
																pData->quest_progress += KiekTuri;
																if (pData->quest_progress >= 20) {
																	pData->quest_progress = 0;
																	pData->quest_step++;
																	Player::OnTextOverlay(peer, "`9Quest step complete!!");
																	send_quest_view_katana(peer, pData, world);
																}
																else {
																	Player::OnTextOverlay(peer, "`9Thanks! Keep it coming!");
																}
															}
															else {
																goto goodluck;
															}
														}
														else if (pData->lastquest == "candour" && pData->quest_step == 19) { /*SummerEventPlayerMedalGold*/
															auto KiekTuri = 0;
															for (auto i = 0; i < pData->inventory.items.size(); i++) {
																if (pData->inventory.items.at(i).itemID == 7968 && pData->inventory.items.at(i).itemCount > 0) {
																	KiekTuri = pData->inventory.items.at(i).itemCount;
																	break;
																}
															}
															if (KiekTuri != 0) {
																if (pData->quest_progress + KiekTuri > 1) KiekTuri = 1 - pData->quest_progress;
																RemoveInventoryItem(7968, KiekTuri, peer, true);
																pData->quest_progress += KiekTuri;
																if (pData->quest_progress >= 1) {
																	pData->quest_progress = 0;
																	pData->quest_step++;
																	Player::OnTextOverlay(peer, "`9Quest step complete!!");
																	send_quest_view_whip(peer, pData, world);
																}
																else {
																	Player::OnTextOverlay(peer, "`9Thanks! Keep it coming!");
																}
															}
															else {
																goto goodluck;
															}
														}
														else if (pData->lastquest == "thesky" && pData->quest_step == 19) { /*DragonKnightChestplate*/
															auto KiekTuri = 0;
															for (auto i = 0; i < pData->inventory.items.size(); i++) {
																if (pData->inventory.items.at(i).itemID == 7728 && pData->inventory.items.at(i).itemCount > 0) {
																	KiekTuri = pData->inventory.items.at(i).itemCount;
																	break;
																}
															}
															if (KiekTuri != 0) {
																if (pData->quest_progress + KiekTuri > 10) KiekTuri = 10 - pData->quest_progress;
																RemoveInventoryItem(7728, KiekTuri, peer, true);
																pData->quest_progress += KiekTuri;
																if (pData->quest_progress >= 10) {
																	pData->quest_progress = 0;
																	pData->quest_step++;
																	Player::OnTextOverlay(peer, "`9Quest step complete!!");
																	send_quest_view_lkwing(peer, pData, world);
																}
																else {
																	Player::OnTextOverlay(peer, "`9Thanks! Keep it coming!");
																}
															}
															else {
																goto goodluck;
															}
														}
														else if (pData->lastquest == "honor" && pData->quest_step == 20) { /*LegendaryOrb title*/
															auto KiekTuri = 0;
															for (auto i = 0; i < pData->inventory.items.size(); i++) {
																if (pData->inventory.items.at(i).itemID == 1794 && pData->inventory.items.at(i).itemCount > 0) {
																	KiekTuri = pData->inventory.items.at(i).itemCount;
																	break;
																}
															}
															if (KiekTuri != 0) {
																if (pData->quest_progress + KiekTuri > 1) KiekTuri = 1 - pData->quest_progress;
																RemoveInventoryItem(1794, KiekTuri, peer, true);
																pData->quest_progress += KiekTuri;
																if (pData->quest_progress >= 1) {
																	pData->quest_progress = 0;
																	pData->quest_step = 0;
																	pData->quest_active = false;
																	pData->lastquest = "";
																	Player::OnTextOverlay(peer, "`9Quest step complete!!");
																	world->items.at(x + (y * world->width)).foreground = 0;
																	PlayerMoving data3{};
																	data3.packetType = 0x3;
																	data3.characterState = 0x0;
																	data3.x = x;
																	data3.y = y;
																	data3.punchX = x;
																	data3.punchY = y;
																	data3.XSpeed = 0;
																	data3.YSpeed = 0;
																	data3.netID = -1;
																	data3.plantingTree = 0;
																	pData->ltitle = true;
																	pData->ltitleunlocked = true;
																	string previous_name = pData->displayName;
																	if (pData->ltitle && pData->ltitleunlocked && pData->displayName.find(" of Legend``") == string::npos) {
																		pData->displayName += " of Legend``";
																	} if (isWorldOwner(peer, world)) {
																		pData->displayName = "`2" + pData->displayName;
																		Player::OnNameChanged(peer, pData->netID, "`2" + pData->displayName);
																	}
																	else {
																		Player::OnNameChanged(peer, pData->netID, pData->displayName);
																	}
																	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																		if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
																		if (isHere(peer, currentPeer)) {
																			auto raw = packPlayerMoving(&data3);
																			raw[2] = 0;
																			raw[3] = 0;
																			Player::OnParticleEffect(currentPeer, 48, pData->x, pData->y, 0);
																			Player::OnParticleEffect(currentPeer, 90, pData->x, pData->y, 0);
																			Player::OnTalkBubble(currentPeer, pData->netID, "`2" + previous_name + " `5earned the achievement 'DARY! (Classic)'!", 0, true);
																			SendPacketRaw(4, raw, 56, nullptr, currentPeer, ENET_PACKET_FLAG_RELIABLE);
																		}
																	}
																}
																else {
																	Player::OnTextOverlay(peer, "`9Thanks! Keep it coming!");
																}
															}
															else {
																goto goodluck;
															}
														}
														else if (pData->lastquest == "steel" && pData->quest_step == 20) { /*LegendaryOrb bot*/
															auto KiekTuri = 0;
															for (auto i = 0; i < pData->inventory.items.size(); i++) {
																if (pData->inventory.items.at(i).itemID == 1794 && pData->inventory.items.at(i).itemCount > 0) {
																	KiekTuri = pData->inventory.items.at(i).itemCount;
																	break;
																}
															}
															if (KiekTuri != 0) {
																if (pData->quest_progress + KiekTuri > 1) KiekTuri = 1 - pData->quest_progress;
																RemoveInventoryItem(1794, KiekTuri, peer, true);
																pData->quest_progress += KiekTuri;
																if (pData->quest_progress >= 1) {
																	pData->quest_progress = 0;
																	pData->quest_step = 0;
																	pData->quest_active = false;
																	pData->lastquest = "";
																	Player::OnTextOverlay(peer, "`9Quest step complete!!");
																	world->items.at(x + (y * world->width)).foreground = 0;
																	PlayerMoving data3{};
																	data3.packetType = 0x3;
																	data3.characterState = 0x0;
																	data3.x = x;
																	data3.y = y;
																	data3.punchX = x;
																	data3.punchY = y;
																	data3.XSpeed = 0;
																	data3.YSpeed = 0;
																	data3.netID = -1;
																	data3.plantingTree = 0;
																	string previous_name = pData->displayName;
																	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																		if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
																		if (isHere(peer, currentPeer)) {
																			auto raw = packPlayerMoving(&data3);
																			raw[2] = 0;
																			raw[3] = 0;
																			Player::OnParticleEffect(currentPeer, 48, pData->x, pData->y, 0);
																			Player::OnParticleEffect(currentPeer, 90, pData->x, pData->y, 0);
																			auto success = true;
																			SaveItemMoreTimes(1780, 1, peer, success);
																			pData->cloth_shirt == 1780;
																			sendClothes(peer);
																			Player::OnTalkBubble(currentPeer, pData->netID, "`2" + previous_name + " `5earned the achievement 'DARY! (Classic)'!", 0, true);
																			SendPacketRaw(4, raw, 56, nullptr, currentPeer, ENET_PACKET_FLAG_RELIABLE);
																		}
																	}
																}
																else {
																	Player::OnTextOverlay(peer, "`9Thanks! Keep it coming!");
																}
															}
															else {
																goto goodluck;
															}
														}
														else if (pData->lastquest == "fire" && pData->quest_step == 20) { /*LegendaryOrb dragon*/
															auto KiekTuri = 0;
															for (auto i = 0; i < pData->inventory.items.size(); i++) {
																if (pData->inventory.items.at(i).itemID == 1794 && pData->inventory.items.at(i).itemCount > 0) {
																	KiekTuri = pData->inventory.items.at(i).itemCount;
																	break;
																}
															}
															if (KiekTuri != 0) {
																if (pData->quest_progress + KiekTuri > 1) KiekTuri = 1 - pData->quest_progress;
																RemoveInventoryItem(1794, KiekTuri, peer, true);
																pData->quest_progress += KiekTuri;
																if (pData->quest_progress >= 1) {
																	pData->quest_progress = 0;
																	pData->quest_step = 0;
																	pData->quest_active = false;
																	pData->lastquest = "";
																	Player::OnTextOverlay(peer, "`9Quest step complete!!");
																	world->items.at(x + (y * world->width)).foreground = 0;
																	PlayerMoving data3{};
																	data3.packetType = 0x3;
																	data3.characterState = 0x0;
																	data3.x = x;
																	data3.y = y;
																	data3.punchX = x;
																	data3.punchY = y;
																	data3.XSpeed = 0;
																	data3.YSpeed = 0;
																	data3.netID = -1;
																	data3.plantingTree = 0;
																	string previous_name = pData->displayName;
																	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																		if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
																		if (isHere(peer, currentPeer)) {
																			auto raw = packPlayerMoving(&data3);
																			raw[2] = 0;
																			raw[3] = 0;
																			Player::OnParticleEffect(currentPeer, 48, pData->x, pData->y, 0);
																			Player::OnParticleEffect(currentPeer, 90, pData->x, pData->y, 0);
																			auto success = true;
																			SaveItemMoreTimes(1782, 1, peer, success);
																			pData->cloth_hand == 1782;
																			sendClothes(peer);
																			Player::OnTalkBubble(currentPeer, pData->netID, "`2" + previous_name + " `5earned the achievement 'DARY! (Classic)'!", 0, true);
																			SendPacketRaw(4, raw, 56, nullptr, currentPeer, ENET_PACKET_FLAG_RELIABLE);
																		}
																	}
																}
																else {
																	Player::OnTextOverlay(peer, "`9Thanks! Keep it coming!");
																}
															}
															else {
																goto goodluck;
															}
														}
														else if (pData->lastquest == "heavens" && pData->quest_step == 20) { /*LegendaryOrb legendwing*/
															auto KiekTuri = 0;
															for (auto i = 0; i < pData->inventory.items.size(); i++) {
																if (pData->inventory.items.at(i).itemID == 1794 && pData->inventory.items.at(i).itemCount > 0) {
																	KiekTuri = pData->inventory.items.at(i).itemCount;
																	break;
																}
															}
															if (KiekTuri != 0) {
																if (pData->quest_progress + KiekTuri > 1) KiekTuri = 1 - pData->quest_progress;
																RemoveInventoryItem(1794, KiekTuri, peer, true);
																pData->quest_progress += KiekTuri;
																if (pData->quest_progress >= 1) {
																	pData->quest_progress = 0;
																	pData->quest_step = 0;
																	pData->quest_active = false;
																	pData->lastquest = "";
																	Player::OnTextOverlay(peer, "`9Quest step complete!!");
																	world->items.at(x + (y * world->width)).foreground = 0;
																	PlayerMoving data3{};
																	data3.packetType = 0x3;
																	data3.characterState = 0x0;
																	data3.x = x;
																	data3.y = y;
																	data3.punchX = x;
																	data3.punchY = y;
																	data3.XSpeed = 0;
																	data3.YSpeed = 0;
																	data3.netID = -1;
																	data3.plantingTree = 0;
																	string previous_name = pData->displayName;
																	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																		if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
																		if (isHere(peer, currentPeer)) {
																			auto raw = packPlayerMoving(&data3);
																			raw[2] = 0;
																			raw[3] = 0;
																			Player::OnParticleEffect(currentPeer, 48, pData->x, pData->y, 0);
																			Player::OnParticleEffect(currentPeer, 90, pData->x, pData->y, 0);
																			auto success = true;
																			SaveItemMoreTimes(1784, 1, peer, success);
																			pData->cloth_back == 1784;
																			sendClothes(peer);
																			Player::OnTalkBubble(currentPeer, pData->netID, "`2" + previous_name + " `5earned the achievement 'DARY! (Classic)'!", 0, true);
																			SendPacketRaw(4, raw, 56, nullptr, currentPeer, ENET_PACKET_FLAG_RELIABLE);
																		}
																	}
																}
																else {
																	Player::OnTextOverlay(peer, "`9Thanks! Keep it coming!");
																}
															}
															else {
																goto goodluck;
															}
														}
														else if (pData->lastquest == "blade" && pData->quest_step == 20) { /*LegendaryOrb katana*/
															auto KiekTuri = 0;
															for (auto i = 0; i < pData->inventory.items.size(); i++) {
																if (pData->inventory.items.at(i).itemID == 1794 && pData->inventory.items.at(i).itemCount > 0) {
																	KiekTuri = pData->inventory.items.at(i).itemCount;
																	break;
																}
															}
															if (KiekTuri != 0) {
																if (pData->quest_progress + KiekTuri > 1) KiekTuri = 1 - pData->quest_progress;
																RemoveInventoryItem(1794, KiekTuri, peer, true);
																pData->quest_progress += KiekTuri;
																if (pData->quest_progress >= 1) {
																	pData->quest_progress = 0;
																	pData->quest_step = 0;
																	pData->quest_active = false;
																	pData->lastquest = "";
																	Player::OnTextOverlay(peer, "`9Quest step complete!!");
																	world->items.at(x + (y * world->width)).foreground = 0;
																	PlayerMoving data3{};
																	data3.packetType = 0x3;
																	data3.characterState = 0x0;
																	data3.x = x;
																	data3.y = y;
																	data3.punchX = x;
																	data3.punchY = y;
																	data3.XSpeed = 0;
																	data3.YSpeed = 0;
																	data3.netID = -1;
																	data3.plantingTree = 0;
																	string previous_name = pData->displayName;
																	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																		if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
																		if (isHere(peer, currentPeer)) {
																			auto raw = packPlayerMoving(&data3);
																			raw[2] = 0;
																			raw[3] = 0;
																			Player::OnParticleEffect(currentPeer, 48, pData->x, pData->y, 0);
																			Player::OnParticleEffect(currentPeer, 90, pData->x, pData->y, 0);
																			auto success = true;
																			SaveItemMoreTimes(2592, 1, peer, success);
																			pData->cloth_hand == 2592;
																			sendClothes(peer);
																			Player::OnTalkBubble(currentPeer, pData->netID, "`2" + previous_name + " `5earned the achievement 'DARY! (Classic)'!", 0, true);
																			SendPacketRaw(4, raw, 56, nullptr, currentPeer, ENET_PACKET_FLAG_RELIABLE);
																		}
																	}
																}
																else {
																	Player::OnTextOverlay(peer, "`9Thanks! Keep it coming!");
																}
															}
															else {
																goto goodluck;
															}
														}
														else if (pData->lastquest == "candour" && pData->quest_step == 20) { /*LegendaryOrb whip*/
															auto KiekTuri = 0;
															for (auto i = 0; i < pData->inventory.items.size(); i++) {
																if (pData->inventory.items.at(i).itemID == 1794 && pData->inventory.items.at(i).itemCount > 0) {
																	KiekTuri = pData->inventory.items.at(i).itemCount;
																	break;
																}
															}
															if (KiekTuri != 0) {
																if (pData->quest_progress + KiekTuri > 1) KiekTuri = 1 - pData->quest_progress;
																RemoveInventoryItem(1794, KiekTuri, peer, true);
																pData->quest_progress += KiekTuri;
																if (pData->quest_progress >= 1) {
																	pData->quest_progress = 0;
																	pData->quest_step = 0;
																	pData->quest_active = false;
																	pData->lastquest = "";
																	Player::OnTextOverlay(peer, "`9Quest step complete!!");
																	world->items.at(x + (y * world->width)).foreground = 0;
																	PlayerMoving data3{};
																	data3.packetType = 0x3;
																	data3.characterState = 0x0;
																	data3.x = x;
																	data3.y = y;
																	data3.punchX = x;
																	data3.punchY = y;
																	data3.XSpeed = 0;
																	data3.YSpeed = 0;
																	data3.netID = -1;
																	data3.plantingTree = 0;
																	string previous_name = pData->displayName;
																	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																		if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
																		if (isHere(peer, currentPeer)) {
																			auto raw = packPlayerMoving(&data3);
																			raw[2] = 0;
																			raw[3] = 0;
																			Player::OnParticleEffect(currentPeer, 48, pData->x, pData->y, 0);
																			Player::OnParticleEffect(currentPeer, 90, pData->x, pData->y, 0);
																			auto success = true;
																			SaveItemMoreTimes(6026, 1, peer, success);
																			pData->cloth_hand == 6026;
																			sendClothes(peer);
																			Player::OnTalkBubble(currentPeer, pData->netID, "`2" + previous_name + " `5earned the achievement 'DARY! (Classic)'!", 0, true);
																			SendPacketRaw(4, raw, 56, nullptr, currentPeer, ENET_PACKET_FLAG_RELIABLE);
																		}
																	}
																}
																else {
																	Player::OnTextOverlay(peer, "`9Thanks! Keep it coming!");
																}
															}
															else {
																goto goodluck;
															}
														}
														else if (pData->lastquest == "thesky" && pData->quest_step == 20) { /*LegendaryOrb legendkngithwing*/
															auto KiekTuri = 0;
															for (auto i = 0; i < pData->inventory.items.size(); i++) {
																if (pData->inventory.items.at(i).itemID == 1794 && pData->inventory.items.at(i).itemCount > 0) {
																	KiekTuri = pData->inventory.items.at(i).itemCount;
																	break;
																}
															}
															if (KiekTuri != 0) {
																if (pData->quest_progress + KiekTuri > 1) KiekTuri = 1 - pData->quest_progress;
																RemoveInventoryItem(1794, KiekTuri, peer, true);
																pData->quest_progress += KiekTuri;
																if (pData->quest_progress >= 1) {
																	pData->quest_progress = 0;
																	pData->quest_step = 0;
																	pData->quest_active = false;
																	pData->lastquest = "";
																	Player::OnTextOverlay(peer, "`9Quest step complete!!");
																	world->items.at(x + (y * world->width)).foreground = 0;
																	PlayerMoving data3{};
																	data3.packetType = 0x3;
																	data3.characterState = 0x0;
																	data3.x = x;
																	data3.y = y;
																	data3.punchX = x;
																	data3.punchY = y;
																	data3.XSpeed = 0;
																	data3.YSpeed = 0;
																	data3.netID = -1;
																	data3.plantingTree = 0;
																	string previous_name = pData->displayName;
																	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																		if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
																		if (isHere(peer, currentPeer)) {
																			auto raw = packPlayerMoving(&data3);
																			raw[2] = 0;
																			raw[3] = 0;
																			Player::OnParticleEffect(currentPeer, 48, pData->x, pData->y, 0);
																			Player::OnParticleEffect(currentPeer, 90, pData->x, pData->y, 0);
																			auto success = true;
																			SaveItemMoreTimes(7734, 1, peer, success);
																			pData->cloth_back == 7734;
																			sendClothes(peer);
																			Player::OnTalkBubble(currentPeer, pData->netID, "`2" + previous_name + " `5earned the achievement 'DARY! (Classic)'!", 0, true);
																			SendPacketRaw(4, raw, 56, nullptr, currentPeer, ENET_PACKET_FLAG_RELIABLE);
																		}
																	}
																}
																else {
																	Player::OnTextOverlay(peer, "`9Thanks! Keep it coming!");
																}
															}
															else {
																goto goodluck;
															}
														}
														else {
														goodluck:
															Player::OnTextOverlay(peer, "`9Good luck! You can do it!");
														}
														break;
													}

													else if (infoDat.at(1) == "lanjiao")
													{ /*code by dchei*/
														pData->quest_active = false;
														pData->lastquest = "";
														pData->quest_step = 1;
														pData->quest_progress = 0;

														break;
													}
													/*else if (infoDat.at(1) == "lanjiao")
			{

			bool existxx = std::experimental::filesystem::exists("save/players/_" + PlayerDB::getProperName(user) + ".json");
			if (!existxx)
			{
				Player::OnTextOverlay(peer, "`4User doesn't exist!");
				return;
			}

			ifstream fg("save/players/_" + PlayerDB::getProperName(user) + ".json");
			json j;
			fg >> j;
			fg.close();

			j["lquest"] = false;
			j["lquest_info"] = "";
			j["lquest_progress"] = "0";
			j["lquest_step"] = "1";


			ofstream fs("save/players/_" + PlayerDB::getProperName(user) + ".json");
			fs << j;
			fs.close();

			ENetPeer* currentPeer;
			for (currentPeer = server->peers;
				currentPeer < &server->peers[server->peerCount];
				++currentPeer)
			{
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
					break;
			}*/
			/*int main() {
				ifstream inFile;
				infile.open("iotm.txt");// iotm test

				if (inFile.fail()) {
					cerr << "Error lanjiao" << endl;
					exit(1);
				}
				int x, y;
				infile >> x >> y;
			}*/
													else if (infoDat.at(1) == "give_up") {
														Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`9The Legendary Wizard``|left|1790|\nadd_textbox|`oAre you sure you want to give up this quest. You will lost all of them.|\nadd_button|lanjiao|`9Give Up|noflags|0|0|\nend_dialog|legendary_wizard|No Thanks||\n");
														break;
													}
													else if (pData->choosing_quest == "honor") { /*title quest*/
														pData->quest_active = true;
														pData->lastquest = "honor";
														pData->quest_step = 1;
														pData->quest_progress = 0;
														send_quest_view(peer, pData, world);
														break;
													}
													else if (pData->choosing_quest == "steel") { /*lbot quest*/
														pData->quest_active = true;
														pData->lastquest = "steel";
														pData->quest_step = 1;
														pData->quest_progress = 0;
														send_quest_view_bot(peer, pData, world);
														break;
													}
													else if (pData->choosing_quest == "fire") { /*dragon quest*/
														pData->quest_active = true;
														pData->lastquest = "fire";
														pData->quest_step = 1;
														pData->quest_progress = 0;
														send_quest_view_dragon(peer, pData, world);
														break;
													}
													else if (pData->choosing_quest == "heavens") { /*legendwing quest*/
														pData->quest_active = true;
														pData->lastquest = "heavens";
														pData->quest_step = 1;
														pData->quest_progress = 0;
														send_quest_view_lwing(peer, pData, world);
														break;
													}
													else if (pData->choosing_quest == "blade") { /*katana quest*/
														pData->quest_active = true;
														pData->lastquest = "blade";
														pData->quest_step = 1;
														pData->quest_progress = 0;
														send_quest_view_katana(peer, pData, world);
														break;
													}
													else if (pData->choosing_quest == "candour") { /*whip quest*/
														pData->quest_active = true;
														pData->lastquest = "candour";
														pData->quest_step = 1;
														pData->quest_progress = 0;
														send_quest_view_whip(peer, pData, world);
														break;
													}
													else if (pData->choosing_quest == "thesky") { /*legendknigtwing quest*/
														pData->quest_active = true;
														pData->lastquest = "thesky";
														pData->quest_step = 1;
														pData->quest_progress = 0;
														send_quest_view_lkwing(peer, pData, world);
														break;
													}
												}
											}
											if (isTitleDialog) {
												if (infoDat.at(1) == "edit_title") {
													if (!pData->Subscriber) break;
													Player::OnDialogRequest(peer, "set_default_color|`o\n\nadd_label|big|`oEdit Your Title``|\nadd_textbox|`oHow to create a `$Title`o? Firstly make sure what `$Color `oYou want to use for example `2Green `oOr `4Red `oThen in the `$Input Box `oWrite your new `$Title `oLets say we want to use `4King `oAnd then simply press `$Save`o!|\nadd_spacer|small|\nadd_text_input|title_name|`$Title``||8|\nend_dialog|title_save|Cancel|Save|");
													break;
												}
												if (infoDat.at(0) == "legendary_title") {
													if (pData->ltitleunlocked) {
														if (pData->ltitle && infoDat.at(1) == "0") {
															pData->ltitle = false;
															size_t pos;
															while ((pos = pData->displayName.find(" of Legend``")) != string::npos) {
																pData->displayName.replace(pos, 12, "");
															} if (isWorldOwner(peer, world)) {
																pData->displayName = "`2" + pData->displayName;
																Player::OnNameChanged(peer, pData->netID, "`2" + pData->displayName);
															} else {
																Player::OnNameChanged(peer, pData->netID, pData->displayName);
															}
															continue;
														} else if (!pData->ltitle && infoDat.at(1) == "1") {
															pData->ltitle = true;
															if (pData->ltitle && pData->ltitleunlocked && pData->displayName.find(" of Legend``") == string::npos) {
																pData->displayName += " of Legend``";
															} if (isWorldOwner(peer, world)) {
																pData->displayName = "`2" + pData->displayName;
																Player::OnNameChanged(peer, pData->netID, "`2" + pData->displayName);
															} else {
																Player::OnNameChanged(peer, pData->netID, pData->displayName);
															}
															continue;
														}
													}
												}
												if (infoDat.at(0) == "blue_name") {
													if (pData->level >= 125) {
														if (pData->bluenametitle && infoDat.at(1) == "0") {
															pData->bluenametitle = false;
															for (auto currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
																if (isHere(peer, currentPeer)) {
																	auto p2ww = packetEnd(appendString(appendString(createPacket(), "OnCountryState"), static_cast<PlayerInfo*>(peer->data)->country + "|showGuild"));
																	memcpy(p2ww.data + 8, &(static_cast<PlayerInfo*>(peer->data)->netID), 4);
																	const auto packet2ww = enet_packet_create(p2ww.data, p2ww.len, ENET_PACKET_FLAG_RELIABLE);
																	enet_peer_send(currentPeer, 0, packet2ww);
																	delete p2ww.data;
																	auto p2wwee = packetEnd(appendString(appendString(createPacket(), "OnCountryState"), static_cast<PlayerInfo*>(currentPeer->data)->country + "|showGuild"));
																	memcpy(p2wwee.data + 8, &(static_cast<PlayerInfo*>(peer->data)->netID), 4);
																	const auto packet2wwee = enet_packet_create(p2wwee.data, p2wwee.len, ENET_PACKET_FLAG_RELIABLE);
																	enet_peer_send(peer, 0, packet2wwee);
																	delete p2wwee.data;
																}
															}
															continue;
														} else if (!pData->bluenametitle && infoDat.at(1) == "1") {
															pData->bluenametitle = true;
															for (auto currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
																if (isHere(peer, currentPeer)) {
																	auto p2ww = packetEnd(appendString(appendString(createPacket(), "OnCountryState"), static_cast<PlayerInfo*>(peer->data)->country + "|showGuild|maxLevel"));
																	memcpy(p2ww.data + 8, &(static_cast<PlayerInfo*>(peer->data)->netID), 4);
																	const auto packet2ww = enet_packet_create(p2ww.data, p2ww.len, ENET_PACKET_FLAG_RELIABLE);
																	enet_peer_send(currentPeer, 0, packet2ww);
																	delete p2ww.data;
																	auto p2wwee = packetEnd(appendString(appendString(createPacket(), "OnCountryState"), static_cast<PlayerInfo*>(currentPeer->data)->country + "|showGuild|maxLevel"));
																	memcpy(p2wwee.data + 8, &(static_cast<PlayerInfo*>(peer->data)->netID), 4);
																	const auto packet2wwee = enet_packet_create(p2wwee.data, p2wwee.len, ENET_PACKET_FLAG_RELIABLE);
																	enet_peer_send(peer, 0, packet2wwee);
																	delete p2wwee.data;
																}
															}
															continue;
														}
													}
												}
											}
											if (isSecurityCamera) {
												if (world->owner == "" || isWorldOwner(peer, world) || isWorldAdmin(peer, world)) {
													/*Player Collected Items*/
													if (infoDat.at(0) == "enableitemtake") {
														if (infoDat.at(1) == "1") {
															ifstream ifff("save/cctv/_" + ((PlayerInfo*)(peer->data))->currentWorld + ".json");
															json j;
															ifff >> j;
															ifff.close();
															j["ShowItemTake"] = true;
															ofstream fs("save/cctv/_" + ((PlayerInfo*)(peer->data))->currentWorld + ".json");
															fs << j;
															fs.close();
														}
														if (infoDat.at(1) == "0") {
															ifstream ifff("save/cctv/_" + ((PlayerInfo*)(peer->data))->currentWorld + ".json");
															json j;
															ifff >> j;
															ifff.close();
															j["ShowItemTake"] = false;
															ofstream fs("save/cctv/_" + ((PlayerInfo*)(peer->data))->currentWorld + ".json");
															fs << j;
															fs.close();
														}
													}
													/*Player Dropped Items*/
													if (infoDat.at(0) == "enableitemdrop") {
														if (infoDat.at(1) == "1") {
															ifstream ifff("save/cctv/_" + ((PlayerInfo*)(peer->data))->currentWorld + ".json");
															json j;
															ifff >> j;
															ifff.close();
															j["ShowItemDrop"] = true;
															ofstream fs("save/cctv/_" + ((PlayerInfo*)(peer->data))->currentWorld + ".json");
															fs << j;
															fs.close();
														}
														if (infoDat.at(1) == "0") {
															ifstream ifff("save/cctv/_" + ((PlayerInfo*)(peer->data))->currentWorld + ".json");
															json j;
															ifff >> j;
															ifff.close();
															j["ShowItemDrop"] = false;
															ofstream fs("save/cctv/_" + ((PlayerInfo*)(peer->data))->currentWorld + ".json");
															fs << j;
															fs.close();
														}
													}
													/*Player Entering Worlds*/
													if (infoDat.at(0) == "enablepenter") {
														if (infoDat.at(1) == "1") {
															ifstream ifff("save/cctv/_" + ((PlayerInfo*)(peer->data))->currentWorld + ".json");
															json j;
															ifff >> j;
															ifff.close();
															j["ShowPoepleEnter"] = true;
															ofstream fs("save/cctv/_" + ((PlayerInfo*)(peer->data))->currentWorld + ".json");
															fs << j;
															fs.close();
														}
														if (infoDat.at(1) == "0") {
															ifstream ifff("save/cctv/_" + ((PlayerInfo*)(peer->data))->currentWorld + ".json");
															json j;
															ifff >> j;
															ifff.close();
															j["ShowPoepleEnter"] = false;
															ofstream fs("save/cctv/_" + ((PlayerInfo*)(peer->data))->currentWorld + ".json");
															fs << j;
															fs.close();
														}
													}
													/*Player Left Worlds*/
													if (infoDat.at(0) == "enablepleave") {
														if (infoDat.at(1) == "1") {
															ifstream ifff("save/cctv/_" + ((PlayerInfo*)(peer->data))->currentWorld + ".json");
															json j;
															ifff >> j;
															ifff.close();
															j["ShowPoepleExit"] = true;
															ofstream fs("save/cctv/_" + ((PlayerInfo*)(peer->data))->currentWorld + ".json");
															fs << j;
															fs.close();
														}
														if (infoDat.at(1) == "0") {
															ifstream ifff("save/cctv/_" + ((PlayerInfo*)(peer->data))->currentWorld + ".json");
															json j;
															ifff >> j;
															ifff.close();
															j["ShowPoepleExit"] = false;
															ofstream fs("save/cctv/_" + ((PlayerInfo*)(peer->data))->currentWorld + ".json");
															fs << j;
															fs.close();
														}
													}
													/*Dont Show Owner, Dont Show Admin, Dont Show Poeple Without Access*/
													if (infoDat.at(0) == "enableDontShowOwner") {
														if (infoDat.at(1) == "1") {
															ifstream ifff("save/cctv/_" + ((PlayerInfo*)(peer->data))->currentWorld + ".json");
															json j;
															ifff >> j;
															ifff.close();
															j["DontShowOwner"] = true;
															ofstream fs("save/cctv/_" + ((PlayerInfo*)(peer->data))->currentWorld + ".json");
															fs << j;
															fs.close();
														}
														if (infoDat.at(1) == "0") {
															ifstream ifff("save/cctv/_" + ((PlayerInfo*)(peer->data))->currentWorld + ".json");
															json j;
															ifff >> j;
															ifff.close();
															j["DontShowOwner"] = false;
															ofstream fs("save/cctv/_" + ((PlayerInfo*)(peer->data))->currentWorld + ".json");
															fs << j;
															fs.close();
														}
													}
													if (infoDat.at(0) == "enableDontShowAdmin") {
														if (infoDat.at(1) == "1") {
															ifstream ifff("save/cctv/_/" + ((PlayerInfo*)(peer->data))->currentWorld + ".json");
															json j;
															ifff >> j;
															ifff.close();
															j["DontShowAdmin"] = true;
															ofstream fs("save/cctv/_" + ((PlayerInfo*)(peer->data))->currentWorld + ".json");
															fs << j;
															fs.close();
														}
														if (infoDat.at(1) == "0") {
															ifstream ifff("save/cctv/_" + ((PlayerInfo*)(peer->data))->currentWorld + ".json");
															json j;
															ifff >> j;
															ifff.close();
															j["DontShowAdmin"] = false;
															ofstream fs("save/cctv/_" + ((PlayerInfo*)(peer->data))->currentWorld + ".json");
															fs << j;
															fs.close();
														}
													}
													if (infoDat.at(0) == "enableDontShowPWA") {
														if (infoDat.at(1) == "1") {
															ifstream ifff("save/cctv/_" + ((PlayerInfo*)(peer->data))->currentWorld + ".json");
															json j;
															ifff >> j;
															ifff.close();
															j["DontShowPWA"] = true;
															ofstream fs("save/cctv/_" + ((PlayerInfo*)(peer->data))->currentWorld + ".json");
															fs << j;
															fs.close();
														}
														if (infoDat.at(1) == "0") {
															ifstream ifff("save/cctv/_" + ((PlayerInfo*)(peer->data))->currentWorld + ".json");
															json j;
															ifff >> j;
															ifff.close();
															j["DontShowPWA"] = false;
															ofstream fs("save/cctv/_" + ((PlayerInfo*)(peer->data))->currentWorld + ".json");
															fs << j;
															fs.close();
														}
													}
												}
												else {
													Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`wSecurity cameras are private business!", 0, false);
												}
											}
											if (isRiftDialog) {
												if (infoDat.at(0) == "checkbox_aura0") {
													if (infoDat.at(1) == "0" && pData->rift_type != 0) {
														pData->rift_type = 0;
														for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
															if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
															if (isHere(peer, currentPeer)) {
																send_rift_cape(currentPeer, pData);
															}
														}
														break;
													}
												}
												if (infoDat.at(1) == "restore_default") { /*restore*/
													pData->rift_cape_r = 1;
													pData->rift_cape_g = 1;
													pData->rift_cape_b = 1;
													pData->rift_collar_r = 1;
													pData->rift_collar_g = 1;
													pData->rift_collar_b = 1;
													pData->rift_type = 0;
													pData->rift_cape_color = 111255;
													pData->rift_collar_color = 111255;
													for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
														if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
														if (isHere(peer, currentPeer)) {
															send_rift_cape(currentPeer, pData);
														}
													}
													break;
												}
												if (infoDat.at(0) == "text_input_cape_color0") { /*decimal cape color*/
													auto ex = explode(",", infoDat.at(1));
													string c_code = ex.at(0) + ex.at(1) + ex.at(2) + "255";
													pData->rift_cape_r = atoi(ex.at(0).c_str());
													pData->rift_cape_g = atoi(ex.at(1).c_str());
													pData->rift_cape_b = atoi(ex.at(2).c_str());
													pData->rift_cape_color = atoi(c_code.c_str());
													for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
														if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
														if (isHere(peer, currentPeer)) {
															send_rift_cape(currentPeer, pData);
														}
													}
												}
												if (infoDat.at(0) == "checkbox_aura_1st0") { /*portal*/
													if (infoDat.at(1) == "1" && pData->rift_type != 2555) {
														pData->rift_type = 2555;
														for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
															if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
															if (isHere(peer, currentPeer)) {
																send_rift_cape(currentPeer, pData);
															}
														}
														break;
													}
												}
												if (infoDat.at(0) == "checkbox_aura_2nd0") { /*starfield*/
													if (infoDat.at(1) == "1" && pData->rift_type != 2811) {
														pData->rift_type = 2811;
														for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
															if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
															if (isHere(peer, currentPeer)) {
																send_rift_cape(currentPeer, pData);
															}
														}
														break;
													}
												}
												if (infoDat.at(0) == "checkbox_aura_3rd0") { /*electrical*/
													if (infoDat.at(1) == "1" && pData->rift_type != 3067) {
														pData->rift_type = 3067;
														for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
															if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
															if (isHere(peer, currentPeer)) {
																send_rift_cape(currentPeer, pData);
															}
														}
														break;
													}
												}
												if (infoDat.at(0) == "text_input_collar_color0") { /*decimal collar color*/
													auto ex = explode(",", infoDat.at(1));
													string c_code = ex.at(0) + ex.at(1) + ex.at(2) + "255";
													pData->rift_collar_r = atoi(ex.at(0).c_str());
													pData->rift_collar_g = atoi(ex.at(1).c_str());
													pData->rift_collar_b = atoi(ex.at(2).c_str());
													pData->rift_collar_color = atoi(c_code.c_str());
													for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
														if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
														if (isHere(peer, currentPeer)) {
															send_rift_cape(currentPeer, pData);
														}
													}
												}
											}
											if (changepasswordDialog) {
												if (infoDat.at(0) == "current_password") {
													current_password = infoDat.at(1);
												}
												if (infoDat.at(0) == "new_password") {
													new_password = infoDat.at(1);
												}
												if (infoDat.at(0) == "confirm_new_password") {
													new_password_confirm = infoDat.at(1);
													string current_user_password = pData->tankIDPass;
													string normal_one = new_password;
													toUpperCase(new_password_confirm);
													toUpperCase(current_password);
													toUpperCase(current_user_password);
													toUpperCase(new_password);
													if (current_password != current_user_password) {
														Player::OnTalkBubble(peer, pData->netID, "Current password didn't match the real one!", 0, true);
														break;
													}
													if (current_user_password == new_password) {
														Player::OnTalkBubble(peer, pData->netID, "It makes no sense to change existing password to the same one!", 0, true);
														break;
													}
													if (new_password != new_password_confirm) {
														Player::OnTalkBubble(peer, pData->netID, "New password didn't match the confirmation password!", 0, true);
														break;
													}
													if (new_password.length() < 3 || new_password.length() > 20) {
														Player::OnTalkBubble(peer, pData->netID, "New password is too long or too short!", 0, true);
														break;
													}
													Player::OnTalkBubble(peer, pData->netID, "Password changed to " + normal_one + " write it down so you wont forget!", 0, true);
													pData->tankIDPass = new_password;
													GamePacket p8 = packetEnd(appendString(appendString(appendInt(appendString(createPacket(), "SetHasGrowID"), 1), pData->tankIDName), pData->tankIDPass));
													ENetPacket* packet8 = enet_packet_create(p8.data, p8.len, ENET_PACKET_FLAG_RELIABLE);
													enet_peer_send(peer, 0, packet8);
													delete p8.data;
													sendSound(peer, "audio/dialog_confirm.wav");
													break;
												}
											}
											if (isMarketDialog) {
												if (infoDat.at(1).substr(0, 19) == "sellitembyrarityid_") {
													if (!triggersell) {
														triggersell = true;
														continue;
													}
												}
												if (infoDat.at(0).substr(0, 18) == "buyitembyrarityid_") {
													string strButItemByRarityCount = infoDat.at(1);
													string id = infoDat.at(0).substr(infoDat.at(0).find("_") + 1);
													if (triggersell) {
														bool contains_non_int2 = !std::regex_match(strButItemByRarityCount, std::regex("^[0-9]+$"));
														bool contains_non_int4 = !std::regex_match(id, std::regex("^[0-9]+$"));
														if (strButItemByRarityCount == "" || contains_non_int4 || id.size() > 5 || id.size() <= 0 || strButItemByRarityCount.length() > 5 || contains_non_int2 || strButItemByRarityCount.size() > 3 || strButItemByRarityCount.size() <= 0) {
															Player::OnTalkBubble(peer, pData->netID, "You can't sell more than 250 or less than 0!", 0, true);
															break;
														}
														int item_count = atoi(strButItemByRarityCount.c_str());
														int item_id = atoi(id.c_str());
														int itemid = item_id;
														if (getItemDef(itemid).properties & Property_Untradable && getItemDef(itemid).rarity == 999 || getItemDef(itemid).blockType != BlockTypes::CLOTHING && getItemDef(itemid).rarity == 999 && itemid != 5142 && itemid != 7188 && itemid != 9498 && itemid != 5154 && itemid != 5140 && itemid != 5138 && itemid != 5136 && itemid != 7382 && itemid != 4762 || getItemDef(itemid).blockType == BlockTypes::LOCK && itemid != 7188 || itemid == 10034 || getItemDef(itemid).name.find("null") != string::npos || itemid == 10036 || getItemDef(itemid).name.find("Mooncake") != string::npos || getItemDef(itemid).name.find("Harvest") != string::npos && itemid != 1830 || getItemDef(itemid).name.find("Autumn") != string::npos || itemid == 1056 || itemid == 1804 || getItemDef(itemid).blockType == BlockTypes::COMPONENT || getItemDef(itemid).properties & Property_Chemical || itemid == 6920 || itemid == 6922 || itemid == 1874 || itemid == 1876 || itemid == 1904 || itemid == 1932 || itemid == 1900 || itemid == 1986 || itemid == 1996 || itemid == 2970 || itemid == 3140 || itemid == 3174 || itemid == 6028 || itemid == 6846 || itemid == 8962 || itemid == 2408 || itemid == 4428 || itemid == 5086 || itemid == 9240 || itemid == 9306 || itemid == 9290 || itemid == 7328 || itemid == 9416 || itemid == 10386 || itemid == 9410 || itemid == 1458 || itemid == 9408 || itemid == 9360 || itemid == 6866 || itemid == 6868 || itemid == 6870 || itemid == 6872 || itemid == 6874 || itemid == 6876 || itemid == 6878 || itemid == 2480 || itemid == 8452 || itemid == 5132 || itemid == 7166 || itemid == 5126 || itemid == 5128 || itemid == 5130 || itemid == 5144 || itemid == 5146 || itemid == 5148 || itemid == 5150 || itemid == 5162 || itemid == 5164 || itemid == 5166 || itemid == 5168 || itemid == 5180 || itemid == 5182 || itemid == 5184 || itemid == 5186 || itemid == 7168 || itemid == 7170 || itemid == 7172 || itemid == 7174 || itemid == 8834 || itemid == 7912 || itemid == 9212 || itemid == 5134 || itemid == 5152 || itemid == 5170 || itemid == 5188 || itemid == 980 || itemid == 9448 || itemid == 9310 || itemid == 10034 || itemid == 10036 || itemid == 8470 || itemid == 8286 || itemid == 6026 || itemid == 1784 || itemid == 9356 || itemid == 10022 || itemid == 902 || itemid == 10032 || itemid == 834 || itemid == 6 || itemid == 5640 || itemid == 9492 || itemid == 1782 || itemid == 9288 || itemid == 1780 || itemid == 8306 || itemid == 202 || itemid == 204 || itemid == 206 || itemid == 2950 || itemid == 4802 || itemid == 4994 || itemid == 5260 || itemid == 5814 || itemid == 5980 || itemid == 7734 || itemid == 2592 || itemid == 2242 || itemid == 1794 || itemid == 1792 || itemid == 778 || itemid == 9510 || itemid == 8774 || itemid == 2568 || itemid == 9512 || itemid == 9502 || itemid == 9482 || itemid == 2250 || itemid == 2248 || itemid == 2244 || itemid == 2246 || itemid == 2286 || itemid == 9508 || itemid == 9504 || itemid == 9506 || itemid == 274 || itemid == 276 || itemid == 9476 || itemid == 1486 || itemid == 4426 || itemid == 9496 || itemid == 278 || itemid == 9490 || itemid == 2410 || itemid == 9488 || itemid == 9452 || itemid == 9454 || itemid == 9472 || itemid == 9456 || itemid == 732 || itemid == 9458 || itemid == 6336 || itemid == 112 || itemid == 8 || itemid == 3760 || getItemDef(itemid).blockType == BlockTypes::FISH || itemid == 7372 || itemid == 9438 || itemid == 9462 || itemid == 9440 || itemid == 9442 || itemid == 9444 || itemid == 7960 || itemid == 7628 || itemid == 8552) break;
														if (itemid == 6312 || itemid == 998 || itemid == 986 || itemid == 992 || itemid == 990 || itemid == 996 || itemid == 988 || itemid == 1004 || itemid == 1006 || itemid == 1002 || itemid == 9504 || itemid == 9506 || itemid == 9508 || itemid == 9510 || itemid == 9512 || itemid == 9514 || itemid == 9518 || itemid == 9520 || itemid == 9502 || itemid == 9496 || itemid == 1790 || itemid == 9492 || itemid == 9494 || itemid == 9488 || itemid == 9222 || itemid == 1360 || itemid == 6260 || itemid == 822 || itemid == 1058 || itemid == 1094 || itemid == 1096 || itemid == 3402 || itemid == 1098 || itemid == 1828 || itemid == 3870 || itemid == 7058 || itemid == 1938 || itemid == 8452 || itemid == 1740 || itemid == 3040 || itemid == 5080 || itemid == 3100 || itemid == 1550 || itemid == 5740 || itemid == 3074 || itemid == 3010 || itemid == 8480 || itemid == 5084 || itemid == 10424 || itemid == 4656 || itemid == 7558 || itemid == 5082 || itemid == 1636 || itemid == 6008 || itemid == 4996 || itemid == 6416 || itemid == 2206 || itemid == 3792 || itemid == 3196 || itemid == 4654 || itemid == 3306 || itemid == 1498 || itemid == 1500 || itemid == 2804 || itemid == 2806 || itemid == 8270 || itemid == 8272 || itemid == 8274 || itemid == 2242 || itemid == 2244 || itemid == 2246 || itemid == 2248 || itemid == 2250 || itemid == 4676 || itemid == 4678 || itemid == 4680 || itemid == 4682 || itemid == 4652 || itemid == 4646 || itemid == 4648 || itemid == 4652 || itemid == 4650 || itemid == 10084 || itemid == 10086 || itemid == 9168 || itemid == 5480 || itemid == 4534 || itemid == 9166 || itemid == 9164 || itemid == 9162 || itemid == 9160 || itemid == 9158 || itemid == 9156 || itemid == 9154 || itemid == 9152 || itemid == 3008 || itemid == 3010 || itemid == 3040 || itemid == 5740 || itemid == 6254 || itemid == 6256 || itemid == 6258 || itemid == 6932 || itemid == 10262 || itemid == 10616 || itemid == 10582 || itemid == 10580 || itemid == 10664 || itemid == 10596 || itemid == 10598 || itemid == 10586 || itemid == 10590 || itemid == 10592 || itemid == 10576 || itemid == 10578 || itemid == 202 || itemid == 204 || itemid == 206 || itemid == 4994 || itemid == 2978 || itemid == 5766 || itemid == 5768 || itemid == 5744 || itemid == 5756 || itemid == 5758 || itemid == 5760 || itemid == 5762 || itemid == 5754 || itemid == 7688 || itemid == 7690 || itemid == 7694 || itemid == 7686 || itemid == 7692 || itemid == 7698 || itemid == 7696 || itemid == 9286 || itemid == 9272 || itemid == 9290 || itemid == 9280 || itemid == 9282 || itemid == 9292 || itemid == 9284 || itemid == 362 || itemid == 3398 || itemid == 386 || itemid == 4422 || itemid == 364 || itemid == 9340 || itemid == 9342 || itemid == 9332 || itemid == 9334 || itemid == 9336 || itemid == 9338 || itemid == 366 || itemid == 2388 || itemid == 7808 || itemid == 7810 || itemid == 4416 || itemid == 7818 || itemid == 7820 || itemid == 5652 || itemid == 7822 || itemid == 7824 || itemid == 5644 || itemid == 390 || itemid == 7826 || itemid == 7830 || itemid == 9324 || itemid == 5658 || itemid == 3396 || itemid == 2384 || itemid == 5660 || itemid == 3400 || itemid == 4418 || itemid == 4412 || itemid == 388 || itemid == 3408 || itemid == 1470 || itemid == 3404 || itemid == 3406 || itemid == 2390 || itemid == 5656 || itemid == 5648 || itemid == 2396 || itemid == 384 || itemid == 5664 || itemid == 4424 || itemid == 4400 || itemid == 1458 || itemid == 10660 || itemid == 10654 || itemid == 10632 || itemid == 10652 || itemid == 10626 || itemid == 10640 || itemid == 10662 || itemid == 574 || itemid == 592 || itemid == 760 || itemid == 900 || itemid == 766 || itemid == 1012 || itemid == 1272 || itemid == 1320 || itemid == 1540 || itemid == 1648 || itemid == 1740 || itemid == 1950 || itemid == 2900 || itemid == 1022 || itemid == 1030 || itemid == 1024 || itemid == 1032 || itemid == 1026 || itemid == 1028 || itemid == 1036 || itemid == 1034 || itemid == 2908 || itemid == 2974 || itemid == 3494 || itemid == 3060 || itemid == 3056 || itemid == 3052 || itemid == 3066 || itemid == 3048 || itemid == 3068 || itemid == 3166 || itemid == 2032 || itemid == 6780 || itemid == 754 || itemid == 794 || itemid == 796 || itemid == 2876 || itemid == 798 || itemid == 930 || itemid == 2204 || itemid == 2912 || itemid == 772 || itemid == 770 || itemid == 898 || itemid == 1582 || itemid == 1020 || itemid == 4132 || itemid == 3932 || itemid == 3934 || itemid == 4128 || itemid == 10246 || itemid == 4296 || itemid == 6212 || itemid == 1212 || itemid == 1190 || itemid == 1206 || itemid == 1166 || itemid == 1964 || itemid == 1976 || itemid == 1998 || itemid == 1946 || itemid == 2002 || itemid == 1958 || itemid == 1952 || itemid == 2030 || itemid == 3104 || itemid == 3112 || itemid == 3120 || itemid == 3092 || itemid == 3094 || itemid == 3096 || itemid == 4184 || itemid == 4178 || itemid == 4174 || itemid == 4180 || itemid == 4170 || itemid == 4168 || itemid == 4150 || itemid == 1180 || itemid == 1224 || itemid == 5226 || itemid == 5228 || itemid == 5230 || itemid == 5212 || itemid == 5246 || itemid == 5242 || itemid == 5234 || itemid == 7134 || itemid == 7118 || itemid == 7132 || itemid == 7120 || itemid == 7098 || itemid == 9018 || itemid == 9038 || itemid == 9026 || itemid == 9066 || itemid == 9058 || itemid == 9044 || itemid == 9024 || itemid == 9032 || itemid == 9036 || itemid == 9028 || itemid == 9030 || itemid == 9110 || itemid == 9112 || itemid == 10386 || itemid == 10326 || itemid == 10324 || itemid == 10322 || itemid == 10328 || itemid == 10316 || itemid == 1198 || itemid == 1208 || itemid == 1222 || itemid == 1200 || itemid == 1220 || itemid == 1202 || itemid == 1238 || itemid == 1168 || itemid == 1172 || itemid == 1230 || itemid == 1194 || itemid == 1192 || itemid == 1226 || itemid == 1196 || itemid == 1236 || itemid == 1182 || itemid == 1184 || itemid == 1186 || itemid == 1188 || itemid == 1170 || itemid == 1212 || itemid == 1214 || itemid == 1232 || itemid == 1178 || itemid == 1234 || itemid == 1250 || itemid == 1956 || itemid == 1990 || itemid == 1968 || itemid == 1960 || itemid == 1948 || itemid == 1966 || itemid == 3114 || itemid == 3118 || itemid == 3100 || itemid == 3122 || itemid == 3124 || itemid == 3126 || itemid == 3108 || itemid == 3098 || itemid == 1962 || itemid == 2000 || itemid == 4186 || itemid == 4188 || itemid == 4246 || itemid == 4248 || itemid == 4192 || itemid == 4156 || itemid == 4136 || itemid == 4152 || itemid == 4166 || itemid == 4190 || itemid == 4172 || itemid == 4182 || itemid == 4144 || itemid == 4146 || itemid == 4148 || itemid == 4140 || itemid == 4138 || itemid == 4142 || itemid == 5256 || itemid == 5208 || itemid == 5216 || itemid == 5218 || itemid == 5220 || itemid == 5214 || itemid == 5210 || itemid == 5254 || itemid == 5250 || itemid == 5252 || itemid == 5244 || itemid == 5236 || itemid == 7104 || itemid == 7124 || itemid == 7122 || itemid == 7102 || itemid == 7100 || itemid == 7126 || itemid == 7104 || itemid == 7124 || itemid == 7122 || itemid == 7102 || itemid == 7100 || itemid == 9048 || itemid == 9056 || itemid == 9034 || itemid == 1210 || itemid == 1216 || itemid == 1218 || itemid == 1992 || itemid == 1982 || itemid == 1994 || itemid == 1972 || itemid == 1980 || itemid == 1988 || itemid == 1984 || itemid == 3116 || itemid == 3102 || itemid == 3106 || itemid == 3110 || itemid == 4160 || itemid == 4162 || itemid == 4164 || itemid == 4154 || itemid == 4158 || itemid == 5224 || itemid == 5222 || itemid == 5232 || itemid == 5240 || itemid == 5248 || itemid == 5238 || itemid == 5256 || itemid == 7116 || itemid == 7108 || itemid == 7110 || itemid == 7128 || itemid == 7112 || itemid == 7130) break;
														if (itemid == 6398 || itemid == 6426 || itemid == 6340 || itemid == 6342 || itemid == 6350 || itemid == 6818 || itemid == 8244 || itemid == 8242 || itemid == 8240 || itemid == 8452 || itemid == 8454 || itemid == 8488 || itemid == 8498 || itemid == 8474 || itemid == 8476 || itemid == 8492 || itemid == 1498 || itemid == 1500 || itemid == 2804 || itemid == 2806 || itemid == 8270 || itemid == 8272 || itemid == 8274 || itemid == 3172 || itemid == 8478 || itemid == 8480 || itemid == 8486 || itemid == 8484 || itemid == 8482 || itemid == 8468 || itemid == 8494 || itemid == 8466 || itemid == 8490 || itemid == 8456 || itemid == 8458 || itemid == 8496 || itemid == 8472 || itemid == 5482 || itemid == 2240 || itemid == 3204 || itemid == 6114 || itemid == 4328 || itemid == 4326 || itemid == 4330 || itemid == 4324 || itemid == 4334 || itemid == 1242 || itemid == 1244 || itemid == 1246 || itemid == 1248 || itemid == 1282 || itemid == 1284 || itemid == 1286 || itemid == 1290 || itemid == 1288 || itemid == 1292 || itemid == 1294 || itemid == 1256 || itemid == 2586 || itemid == 782 || itemid == 3536 || itemid == 764 || itemid == 4176 || itemid == 4322 || itemid == 4080 || itemid == 2992 || itemid == 2976 || itemid == 3790 || itemid == 4990 || itemid == 1506 || itemid == 1274 || itemid == 9000 || itemid == 1252 || itemid == 8284 || itemid == 8954 || itemid == 8534 || itemid == 2386 || itemid == 4428 || itemid == 4426 || itemid == 5662 || itemid == 5642 || itemid == 5654 || itemid == 5646 || itemid == 5650 || itemid == 7828 || itemid == 7832 || itemid == 7834 || itemid == 9322 || itemid == 9344 || itemid == 9326 || itemid == 9316 || itemid == 9318 || itemid == 362 || itemid == 3398 || itemid == 386 || itemid == 4422 || itemid == 364 || itemid == 9340 || itemid == 9342 || itemid == 9332 || itemid == 9334 || itemid == 9336 || itemid == 9338 || itemid == 366 || itemid == 2388 || itemid == 7808 || itemid == 7810 || itemid == 4416 || itemid == 7818 || itemid == 7820 || itemid == 5652 || itemid == 7822 || itemid == 7824 || itemid == 5644 || itemid == 390 || itemid == 7826 || itemid == 7830 || itemid == 9324 || itemid == 5658 || itemid == 3396 || itemid == 2384 || itemid == 5660 || itemid == 3400 || itemid == 4418 || itemid == 4412 || itemid == 388 || itemid == 3408 || itemid == 1470 || itemid == 3404 || itemid == 3406 || itemid == 2390 || itemid == 5656 || itemid == 5648 || itemid == 2396 || itemid == 384 || itemid == 5664 || itemid == 4424 || itemid == 4400 || itemid == 9350 || itemid == 5040 || itemid == 5042 || itemid == 5044 || itemid == 392 || itemid == 3402 || itemid == 5032 || itemid == 5034 || itemid == 5036 || itemid == 5038 || itemid == 5018 || itemid == 5022 || itemid == 5060 || itemid == 5054 || itemid == 5058 || itemid == 5056 || itemid == 5050 || itemid == 5046 || itemid == 5052 || itemid == 5048 || itemid == 5070 || itemid == 5072 || itemid == 5074 || itemid == 5076 || itemid == 5066 || itemid == 5062 || itemid == 5068 || itemid == 5064 || itemid == 5080 || itemid == 5082 || itemid == 5084 || itemid == 5078 || itemid == 10236 || itemid == 10232 || itemid == 10194 || itemid == 10206 || itemid == 10184 || itemid == 10192 || itemid == 10190 || itemid == 10186 || itemid == 10212 || itemid == 10214 || itemid == 10216 || itemid == 10220 || itemid == 10222 || itemid == 10224 || itemid == 10226 || itemid == 10208 || itemid == 10210 || itemid == 10218 || itemid == 10196 || itemid == 10198 || itemid == 10200 || itemid == 10202 || itemid == 10204) break;
														int kiek_turi_kainoti = 0;
														try {
															ifstream infile("price_data.txt");
															for (string line; getline(infile, line);) {
																if (line.length() > 3 && line.at(0) != '/' && line.at(1) != '/') {
																	auto ex = explode("|", line);
																	if (ex.at(0) == to_string(item_id)) {
																		kiek_turi_kainoti = atoi(ex.at(1).c_str());
																		break;
																	}
																}
															}
															infile.close();
														} catch(const std::out_of_range& e) {
															std::cout << e.what() << std::endl;
														} 
														if(itemid == 7188) kiek_turi_kainoti = 10000;
														int kiek_ruosiasi_parduoti = 0;
														if (getItemDef(item_id).blockType == BlockTypes::SIGN && getItemDef(item_id).rarity != 999 || getItemDef(item_id).blockType == BlockTypes::GATEWAY && getItemDef(item_id).rarity != 999 || getItemDef(item_id).blockType == BlockTypes::BACKGROUND && getItemDef(item_id).rarity != 999 || getItemDef(item_id).blockType == BlockTypes::DOOR && getItemDef(item_id).rarity != 999 || getItemDef(item_id).blockType == BlockTypes::DEADLY && getItemDef(item_id).rarity != 999 || getItemDef(item_id).blockType == BlockTypes::PAIN_BLOCK && getItemDef(item_id).rarity != 999 || getItemDef(item_id).blockType == BlockTypes::PLATFORM && getItemDef(item_id).rarity != 999 || getItemDef(item_id).blockType == BlockTypes::FOREGROUND && getItemDef(item_id).rarity != 999 && item_id != 9498 && item_id != 5154 && item_id != 5140 && item_id != 5138 && item_id != 5136 && item_id != 7382 && item_id != 4762 || getItemDef(item_id).blockType == BlockTypes::SFX_FOREGROUND && getItemDef(item_id).rarity != 999 || getItemDef(item_id).blockType == BlockTypes::ANIM_FOREGROUND && getItemDef(item_id).rarity != 999 || getItemDef(item_id).blockType == BlockTypes::TOGGLE_FOREGROUND && getItemDef(item_id).rarity != 999) {
															if (getItemDef(item_id).rarity < 14) break;
															kiek_ruosiasi_parduoti = item_count * kiek_turi_kainoti;
														} else {
															if (getItemDef(item_id).rarity != 999 && itemid != 9498 && itemid != 5154 && itemid != 5140 && itemid != 5138 && itemid != 5136 && itemid != 7382 && itemid != 4762) break;
															kiek_ruosiasi_parduoti = item_count;
														}
														if (kiek_ruosiasi_parduoti < 1 || kiek_ruosiasi_parduoti > 250) {
															Player::OnTalkBubble(peer, pData->netID, "You can't sell more than 250 or less than 0!", 0, true);
															break;
														}
														if (item_id == 9498 || item_id == 5154 || item_id == 5140 || item_id == 5138 || item_id == 5136 || item_id == 7382 || item_id == 4762) {
															kiek_ruosiasi_parduoti = 200;
														}
														auto contains = false;
														SearchInventoryItem(peer, item_id, kiek_ruosiasi_parduoti, contains);
														if (!contains) {
															Player::OnTalkBubble(peer, pData->netID, "You Don't have " + to_string(kiek_ruosiasi_parduoti) + " of " + getItemDef(item_id).name + " to sell!", 0, true);
															break;
														}
														auto worldlocks = 0;
														if (item_id == 9498 || item_id == 5154 || item_id == 5140 || item_id == 5138 || item_id == 5136 || item_id == 7382 || item_id == 4762) {
															worldlocks = kiek_turi_kainoti;
														} else if (getItemDef(item_id).blockType == BlockTypes::SIGN && getItemDef(item_id).rarity != 999 || getItemDef(item_id).blockType == BlockTypes::GATEWAY && getItemDef(item_id).rarity != 999 || getItemDef(item_id).blockType == BlockTypes::BACKGROUND && getItemDef(item_id).rarity != 999 || getItemDef(item_id).blockType == BlockTypes::DOOR && getItemDef(item_id).rarity != 999 || getItemDef(item_id).blockType == BlockTypes::DEADLY && getItemDef(item_id).rarity != 999 || getItemDef(item_id).blockType == BlockTypes::PAIN_BLOCK && getItemDef(item_id).rarity != 999 || getItemDef(item_id).blockType == BlockTypes::PLATFORM && getItemDef(item_id).rarity != 999 || getItemDef(item_id).blockType == BlockTypes::FOREGROUND && getItemDef(item_id).rarity != 999 && item_id != 9498 && item_id != 5154 && item_id != 5140 && item_id != 5138 && item_id != 5136 && item_id != 7382 && item_id != 4762 || getItemDef(item_id).blockType == BlockTypes::SFX_FOREGROUND && getItemDef(item_id).rarity != 999 || getItemDef(item_id).blockType == BlockTypes::ANIM_FOREGROUND && getItemDef(item_id).rarity != 999 || getItemDef(item_id).blockType == BlockTypes::TOGGLE_FOREGROUND && getItemDef(item_id).rarity != 999) {
															worldlocks = item_count;
														} else {
															worldlocks = kiek_turi_kainoti * kiek_ruosiasi_parduoti;
														}
														auto diamondlocks = 0;
														while (worldlocks >= 100) {
															diamondlocks++;
															worldlocks -= 100;
														}
														if (CheckItemMaxed(peer, 242, worldlocks) || worldlocks > 250) {
															Player::OnTalkBubble(peer, pData->netID, "" + to_string(worldlocks) + " World locks Wouldnt fit into my inventory!", 0, true);
															break;
														}
														if (CheckItemMaxed(peer, 1796, diamondlocks) || diamondlocks > 250) {
															Player::OnTalkBubble(peer, pData->netID, "" + to_string(diamondlocks) + " Diamond locks Wouldnt fit into my inventory!", 0, true);
															break;
														}
														string kiek_gaus = "";
														if (diamondlocks != 0) {
															kiek_gaus += "\nadd_label_with_icon|small|(`w" + to_string(diamondlocks) + "``) `2Diamond Locks``|left|1796|";
														}
														if (worldlocks != 0) {
															kiek_gaus += "\nadd_label_with_icon|small|(`w" + to_string(worldlocks) + "``) `2World Locks``|left|242|";
														}
														pData->laststoresellworldlocks = worldlocks;
														pData->laststoreselldiamondlocks = diamondlocks;
														pData->laststoresellid = item_id;
														pData->laststoresellcount = kiek_ruosiasi_parduoti;
														Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wPurchase Confirmation``|left|1366|\nadd_spacer|small|\nadd_spacer|small|\nadd_textbox|`4You'll give:``|left|\nadd_spacer|small|\nadd_label_with_icon|small|(`w" + to_string(kiek_ruosiasi_parduoti) + "``) `8" + getItemDef(item_id).name + "``|left|" + to_string(item_id) + "|\nadd_spacer|small|\nadd_textbox|`2You'll get:``|left|\nadd_spacer|small|" + kiek_gaus + "\nadd_spacer|small|\nadd_spacer|small|\nadd_textbox|Are you sure you want to make this purchase?|left|\nend_dialog|store_sell_confirm|Cancel|OK|");
														break;
													}
													bool contains_non_int2 = !std::regex_match(strButItemByRarityCount, std::regex("^[0-9]+$"));
													bool contains_non_int4 = !std::regex_match(id, std::regex("^[0-9]+$"));
													if (strButItemByRarityCount == "" || contains_non_int4 || id.size() > 5 || id.size() <= 0 || strButItemByRarityCount.length() > 5 || contains_non_int2 || strButItemByRarityCount.size() > 3 || strButItemByRarityCount.size() <= 0) {
														Player::OnTalkBubble(peer, pData->netID, "You can't buy more than 250 or less than 0!", 0, true);
														break;
													}
													int item_count = atoi(strButItemByRarityCount.c_str());
													if (item_count < 1 || item_count > 250) {
														Player::OnTalkBubble(peer, pData->netID, "You can't buy more than 250 or less than 0!", 0, true);
														break;
													}
													int item_id = atoi(id.c_str());
													int itemid = item_id;
													if (getItemDef(itemid).blockType != BlockTypes::CLOTHING && getItemDef(itemid).rarity == 999 && itemid != 7188 && itemid != 5142 || getItemDef(itemid).blockType == BlockTypes::LOCK && itemid != 7188 || itemid == 10034 || getItemDef(itemid).name.find("null") != string::npos || itemid == 10036 || getItemDef(itemid).name.find("Mooncake") != string::npos || getItemDef(itemid).name.find("Harvest") != string::npos && itemid != 1830 || getItemDef(itemid).name.find("Autumn") != string::npos || itemid == 1056 || itemid == 1804 || getItemDef(itemid).blockType == BlockTypes::COMPONENT || getItemDef(itemid).properties & Property_Chemical || itemid == 6920 || itemid == 6922 || itemid == 1874 || itemid == 1876 || itemid == 1904 || itemid == 1932 || itemid == 1900 || itemid == 1986 || itemid == 1996 || itemid == 2970 || itemid == 3140 || itemid == 3174 || itemid == 6028 || itemid == 6846 || itemid == 8962 || itemid == 2408 || itemid == 4428 || itemid == 5086 || itemid == 9240 || itemid == 9306 || itemid == 9290 || itemid == 7328 || itemid == 9416 || itemid == 10386 || itemid == 9410 || itemid == 1458 || itemid == 9408 || itemid == 9360 || itemid == 6866 || itemid == 6868 || itemid == 6870 || itemid == 6872 || itemid == 6874 || itemid == 6876 || itemid == 6878 || itemid == 2480 || itemid == 8452 || itemid == 5132 || itemid == 7166 || itemid == 5126 || itemid == 5128 || itemid == 5130 || itemid == 5144 || itemid == 5146 || itemid == 5148 || itemid == 5150 || itemid == 5162 || itemid == 5164 || itemid == 5166 || itemid == 5168 || itemid == 5180 || itemid == 5182 || itemid == 5184 || itemid == 5186 || itemid == 7168 || itemid == 7170 || itemid == 7172 || itemid == 7174 || itemid == 8834 || itemid == 7912 || itemid == 9212 || itemid == 5134 || itemid == 5152 || itemid == 5170 || itemid == 5188 || itemid == 980 || itemid == 9448 || itemid == 9310 || itemid == 10034 || itemid == 10036 || itemid == 8470 || itemid == 8286 || itemid == 6026 || itemid == 1784 || itemid == 9356 || itemid == 10022 || itemid == 902 || itemid == 10032 || itemid == 834 || itemid == 6 || itemid == 5640 || itemid == 9492 || itemid == 1782 || itemid == 9288 || itemid == 1780 || itemid == 8306 || itemid == 202 || itemid == 204 || itemid == 206 || itemid == 2950 || itemid == 4802 || itemid == 4994 || itemid == 5260 || itemid == 5814 || itemid == 5980 || itemid == 7734 || itemid == 2592 || itemid == 2242 || itemid == 1794 || itemid == 1792 || itemid == 778 || itemid == 9510 || itemid == 8774 || itemid == 2568 || itemid == 9512 || itemid == 9502 || itemid == 9482 || itemid == 2250 || itemid == 2248 || itemid == 2244 || itemid == 2246 || itemid == 2286 || itemid == 9508 || itemid == 9504 || itemid == 9506 || itemid == 274 || itemid == 276 || itemid == 9476 || itemid == 1486 || itemid == 4426 || itemid == 9496 || itemid == 278 || itemid == 9490 || itemid == 2410 || itemid == 9488 || itemid == 9452 || itemid == 9454 || itemid == 9472 || itemid == 9456 || itemid == 732 || itemid == 9458 || itemid == 6336 || itemid == 112 || itemid == 8 || itemid == 3760 || getItemDef(itemid).blockType == BlockTypes::FISH || itemid == 7372 || itemid == 9438 || itemid == 9462 || itemid == 9440 || itemid == 9442 || itemid == 9444 || itemid == 7960 || itemid == 7628 || itemid == 8552) break;
													if (itemid == 6312 || itemid == 998 || itemid == 986 || itemid == 992 || itemid == 990 || itemid == 996 || itemid == 988 || itemid == 1004 || itemid == 1006 || itemid == 1002 || itemid == 9504 || itemid == 9506 || itemid == 9508 || itemid == 9510 || itemid == 9512 || itemid == 9514 || itemid == 9518 || itemid == 9520 || itemid == 9502 || itemid == 9496 || itemid == 1790 || itemid == 9492 || itemid == 9494 || itemid == 9488 || itemid == 9222 || itemid == 1360 || itemid == 6260 || itemid == 822 || itemid == 1058 || itemid == 1094 || itemid == 1096 || itemid == 3402 || itemid == 1098 || itemid == 1828 || itemid == 3870 || itemid == 7058 || itemid == 1938 || itemid == 8452 || itemid == 1740 || itemid == 3040 || itemid == 5080 || itemid == 3100 || itemid == 1550 || itemid == 5740 || itemid == 3074 || itemid == 3010 || itemid == 8480 || itemid == 5084 || itemid == 10424 || itemid == 4656 || itemid == 7558 || itemid == 5082 || itemid == 1636 || itemid == 6008 || itemid == 4996 || itemid == 6416 || itemid == 2206 || itemid == 3792 || itemid == 3196 || itemid == 4654 || itemid == 3306 || itemid == 1498 || itemid == 1500 || itemid == 2804 || itemid == 2806 || itemid == 8270 || itemid == 8272 || itemid == 8274 || itemid == 2242 || itemid == 2244 || itemid == 2246 || itemid == 2248 || itemid == 2250 || itemid == 4676 || itemid == 4678 || itemid == 4680 || itemid == 4682 || itemid == 4652 || itemid == 4646 || itemid == 4648 || itemid == 4652 || itemid == 4650 || itemid == 10084 || itemid == 10086 || itemid == 9168 || itemid == 5480 || itemid == 4534 || itemid == 9166 || itemid == 9164 || itemid == 9162 || itemid == 9160 || itemid == 9158 || itemid == 9156 || itemid == 9154 || itemid == 9152 || itemid == 3008 || itemid == 3010 || itemid == 3040 || itemid == 5740 || itemid == 6254 || itemid == 6256 || itemid == 6258 || itemid == 6932 || itemid == 10262 || itemid == 10616 || itemid == 10582 || itemid == 10580 || itemid == 10664 || itemid == 10596 || itemid == 10598 || itemid == 10586 || itemid == 10590 || itemid == 10592 || itemid == 10576 || itemid == 10578 || itemid == 202 || itemid == 204 || itemid == 206 || itemid == 4994 || itemid == 2978 || itemid == 5766 || itemid == 5768 || itemid == 5744 || itemid == 5756 || itemid == 5758 || itemid == 5760 || itemid == 5762 || itemid == 5754 || itemid == 7688 || itemid == 7690 || itemid == 7694 || itemid == 7686 || itemid == 7692 || itemid == 7698 || itemid == 7696 || itemid == 9286 || itemid == 9272 || itemid == 9290 || itemid == 9280 || itemid == 9282 || itemid == 9292 || itemid == 9284 || itemid == 362 || itemid == 3398 || itemid == 386 || itemid == 4422 || itemid == 364 || itemid == 9340 || itemid == 9342 || itemid == 9332 || itemid == 9334 || itemid == 9336 || itemid == 9338 || itemid == 366 || itemid == 2388 || itemid == 7808 || itemid == 7810 || itemid == 4416 || itemid == 7818 || itemid == 7820 || itemid == 5652 || itemid == 7822 || itemid == 7824 || itemid == 5644 || itemid == 390 || itemid == 7826 || itemid == 7830 || itemid == 9324 || itemid == 5658 || itemid == 3396 || itemid == 2384 || itemid == 5660 || itemid == 3400 || itemid == 4418 || itemid == 4412 || itemid == 388 || itemid == 3408 || itemid == 1470 || itemid == 3404 || itemid == 3406 || itemid == 2390 || itemid == 5656 || itemid == 5648 || itemid == 2396 || itemid == 384 || itemid == 5664 || itemid == 4424 || itemid == 4400 || itemid == 1458 || itemid == 10660 || itemid == 10654 || itemid == 10632 || itemid == 10652 || itemid == 10626 || itemid == 10640 || itemid == 10662 || itemid == 574 || itemid == 592 || itemid == 760 || itemid == 900 || itemid == 766 || itemid == 1012 || itemid == 1272 || itemid == 1320 || itemid == 1540 || itemid == 1648 || itemid == 1740 || itemid == 1950 || itemid == 2900 || itemid == 1022 || itemid == 1030 || itemid == 1024 || itemid == 1032 || itemid == 1026 || itemid == 1028 || itemid == 1036 || itemid == 1034 || itemid == 2908 || itemid == 2974 || itemid == 3494 || itemid == 3060 || itemid == 3056 || itemid == 3052 || itemid == 3066 || itemid == 3048 || itemid == 3068 || itemid == 3166 || itemid == 2032 || itemid == 6780 || itemid == 754 || itemid == 794 || itemid == 796 || itemid == 2876 || itemid == 798 || itemid == 930 || itemid == 2204 || itemid == 2912 || itemid == 772 || itemid == 770 || itemid == 898 || itemid == 1582 || itemid == 1020 || itemid == 4132 || itemid == 3932 || itemid == 3934 || itemid == 4128 || itemid == 10246 || itemid == 4296 || itemid == 6212 || itemid == 1212 || itemid == 1190 || itemid == 1206 || itemid == 1166 || itemid == 1964 || itemid == 1976 || itemid == 1998 || itemid == 1946 || itemid == 2002 || itemid == 1958 || itemid == 1952 || itemid == 2030 || itemid == 3104 || itemid == 3112 || itemid == 3120 || itemid == 3092 || itemid == 3094 || itemid == 3096 || itemid == 4184 || itemid == 4178 || itemid == 4174 || itemid == 4180 || itemid == 4170 || itemid == 4168 || itemid == 4150 || itemid == 1180 || itemid == 1224 || itemid == 5226 || itemid == 5228 || itemid == 5230 || itemid == 5212 || itemid == 5246 || itemid == 5242 || itemid == 5234 || itemid == 7134 || itemid == 7118 || itemid == 7132 || itemid == 7120 || itemid == 7098 || itemid == 9018 || itemid == 9038 || itemid == 9026 || itemid == 9066 || itemid == 9058 || itemid == 9044 || itemid == 9024 || itemid == 9032 || itemid == 9036 || itemid == 9028 || itemid == 9030 || itemid == 9110 || itemid == 9112 || itemid == 10386 || itemid == 10326 || itemid == 10324 || itemid == 10322 || itemid == 10328 || itemid == 10316 || itemid == 1198 || itemid == 1208 || itemid == 1222 || itemid == 1200 || itemid == 1220 || itemid == 1202 || itemid == 1238 || itemid == 1168 || itemid == 1172 || itemid == 1230 || itemid == 1194 || itemid == 1192 || itemid == 1226 || itemid == 1196 || itemid == 1236 || itemid == 1182 || itemid == 1184 || itemid == 1186 || itemid == 1188 || itemid == 1170 || itemid == 1212 || itemid == 1214 || itemid == 1232 || itemid == 1178 || itemid == 1234 || itemid == 1250 || itemid == 1956 || itemid == 1990 || itemid == 1968 || itemid == 1960 || itemid == 1948 || itemid == 1966 || itemid == 3114 || itemid == 3118 || itemid == 3100 || itemid == 3122 || itemid == 3124 || itemid == 3126 || itemid == 3108 || itemid == 3098 || itemid == 1962 || itemid == 2000 || itemid == 4186 || itemid == 4188 || itemid == 4246 || itemid == 4248 || itemid == 4192 || itemid == 4156 || itemid == 4136 || itemid == 4152 || itemid == 4166 || itemid == 4190 || itemid == 4172 || itemid == 4182 || itemid == 4144 || itemid == 4146 || itemid == 4148 || itemid == 4140 || itemid == 4138 || itemid == 4142 || itemid == 5256 || itemid == 5208 || itemid == 5216 || itemid == 5218 || itemid == 5220 || itemid == 5214 || itemid == 5210 || itemid == 5254 || itemid == 5250 || itemid == 5252 || itemid == 5244 || itemid == 5236 || itemid == 7104 || itemid == 7124 || itemid == 7122 || itemid == 7102 || itemid == 7100 || itemid == 7126 || itemid == 7104 || itemid == 7124 || itemid == 7122 || itemid == 7102 || itemid == 7100 || itemid == 9048 || itemid == 9056 || itemid == 9034 || itemid == 1210 || itemid == 1216 || itemid == 1218 || itemid == 1992 || itemid == 1982 || itemid == 1994 || itemid == 1972 || itemid == 1980 || itemid == 1988 || itemid == 1984 || itemid == 3116 || itemid == 3102 || itemid == 3106 || itemid == 3110 || itemid == 4160 || itemid == 4162 || itemid == 4164 || itemid == 4154 || itemid == 4158 || itemid == 5224 || itemid == 5222 || itemid == 5232 || itemid == 5240 || itemid == 5248 || itemid == 5238 || itemid == 5256 || itemid == 7116 || itemid == 7108 || itemid == 7110 || itemid == 7128 || itemid == 7112 || itemid == 7130) break;
													if (itemid == 6398 || itemid == 6426 || itemid == 6340 || itemid == 6342 || itemid == 6350 || itemid == 6818 || itemid == 8244 || itemid == 8242 || itemid == 8240 || itemid == 8452 || itemid == 8454 || itemid == 8488 || itemid == 8498 || itemid == 8474 || itemid == 8476 || itemid == 8492 || itemid == 1498 || itemid == 1500 || itemid == 2804 || itemid == 2806 || itemid == 8270 || itemid == 8272 || itemid == 8274 || itemid == 3172 || itemid == 8478 || itemid == 8480 || itemid == 8486 || itemid == 8484 || itemid == 8482 || itemid == 8468 || itemid == 8494 || itemid == 8466 || itemid == 8490 || itemid == 8456 || itemid == 8458 || itemid == 8496 || itemid == 8472 || itemid == 5482 || itemid == 2240 || itemid == 3204 || itemid == 6114 || itemid == 4328 || itemid == 4326 || itemid == 4330 || itemid == 4324 || itemid == 4334 || itemid == 1242 || itemid == 1244 || itemid == 1246 || itemid == 1248 || itemid == 1282 || itemid == 1284 || itemid == 1286 || itemid == 1290 || itemid == 1288 || itemid == 1292 || itemid == 1294 || itemid == 1256 || itemid == 2586 || itemid == 782 || itemid == 3536 || itemid == 764 || itemid == 4176 || itemid == 4322 || itemid == 4080 || itemid == 2992 || itemid == 2976 || itemid == 3790 || itemid == 4990 || itemid == 1506 || itemid == 1274 || itemid == 9000 || itemid == 1252 || itemid == 8284 || itemid == 8954 || itemid == 8534 || itemid == 2386 || itemid == 4428 || itemid == 4426 || itemid == 5662 || itemid == 5642 || itemid == 5654 || itemid == 5646 || itemid == 5650 || itemid == 7828 || itemid == 7832 || itemid == 7834 || itemid == 9322 || itemid == 9344 || itemid == 9326 || itemid == 9316 || itemid == 9318 || itemid == 362 || itemid == 3398 || itemid == 386 || itemid == 4422 || itemid == 364 || itemid == 9340 || itemid == 9342 || itemid == 9332 || itemid == 9334 || itemid == 9336 || itemid == 9338 || itemid == 366 || itemid == 2388 || itemid == 7808 || itemid == 7810 || itemid == 4416 || itemid == 7818 || itemid == 7820 || itemid == 5652 || itemid == 7822 || itemid == 7824 || itemid == 5644 || itemid == 390 || itemid == 7826 || itemid == 7830 || itemid == 9324 || itemid == 5658 || itemid == 3396 || itemid == 2384 || itemid == 5660 || itemid == 3400 || itemid == 4418 || itemid == 4412 || itemid == 388 || itemid == 3408 || itemid == 1470 || itemid == 3404 || itemid == 3406 || itemid == 2390 || itemid == 5656 || itemid == 5648 || itemid == 2396 || itemid == 384 || itemid == 5664 || itemid == 4424 || itemid == 4400 || itemid == 9350 || itemid == 5040 || itemid == 5042 || itemid == 5044 || itemid == 392 || itemid == 3402 || itemid == 5032 || itemid == 5034 || itemid == 5036 || itemid == 5038 || itemid == 5018 || itemid == 5022 || itemid == 5060 || itemid == 5054 || itemid == 5058 || itemid == 5056 || itemid == 5050 || itemid == 5046 || itemid == 5052 || itemid == 5048 || itemid == 5070 || itemid == 5072 || itemid == 5074 || itemid == 5076 || itemid == 5066 || itemid == 5062 || itemid == 5068 || itemid == 5064 || itemid == 5080 || itemid == 5082 || itemid == 5084 || itemid == 5078 || itemid == 10236 || itemid == 10232 || itemid == 10194 || itemid == 10206 || itemid == 10184 || itemid == 10192 || itemid == 10190 || itemid == 10186 || itemid == 10212 || itemid == 10214 || itemid == 10216 || itemid == 10220 || itemid == 10222 || itemid == 10224 || itemid == 10226 || itemid == 10208 || itemid == 10210 || itemid == 10218 || itemid == 10196 || itemid == 10198 || itemid == 10200 || itemid == 10202 || itemid == 10204) break;
													int kiek_turi_kainoti = 0;                
													try {
														ifstream infile("price_data.txt");
														for (string line; getline(infile, line);) {
															if (line.length() > 3 && line.at(0) != '/' && line.at(1) != '/') {
																auto ex = explode("|", line);
																if (ex.at(0) == to_string(item_id)) {
																	kiek_turi_kainoti = atoi(ex.at(1).c_str());
																	break;
																}
															}
														}
														infile.close();
													} catch(const std::out_of_range& e) {
														std::cout << e.what() << std::endl;
													} 
													if (item_id == 7188) kiek_turi_kainoti = 10000;
													kiek_turi_kainoti *= item_count;
													int item_per_wl = 0;
													int kaina_wls = 0;
													if (getItemDef(item_id).blockType == BlockTypes::SIGN && getItemDef(item_id).rarity != 999 || getItemDef(item_id).blockType == BlockTypes::GATEWAY && getItemDef(item_id).rarity != 999 || getItemDef(item_id).blockType == BlockTypes::DEADLY && getItemDef(item_id).rarity != 999 || getItemDef(item_id).blockType == BlockTypes::DOOR && getItemDef(item_id).rarity != 999 || getItemDef(item_id).blockType == BlockTypes::PAIN_BLOCK && getItemDef(item_id).rarity != 999 || getItemDef(item_id).blockType == BlockTypes::PLATFORM && getItemDef(item_id).rarity != 999 || getItemDef(item_id).blockType == BlockTypes::BACKGROUND && getItemDef(item_id).rarity != 999 || getItemDef(item_id).blockType == BlockTypes::FOREGROUND && getItemDef(item_id).rarity != 999 && item_id != 9498 && item_id != 5154 && item_id != 5140 && item_id != 5138 && item_id != 5136 && item_id != 7382 && item_id != 4762 || getItemDef(item_id).blockType == BlockTypes::SFX_FOREGROUND && getItemDef(item_id).rarity != 999 || getItemDef(item_id).blockType == BlockTypes::ANIM_FOREGROUND && getItemDef(item_id).rarity != 999 || getItemDef(item_id).blockType == BlockTypes::TOGGLE_FOREGROUND && getItemDef(item_id).rarity != 999) {
														/*kiek per wl*/
														item_per_wl = kiek_turi_kainoti / item_count;
														/*itemperwl tai yra wl uz tiek*/
														kaina_wls = kiek_turi_kainoti / item_per_wl;
														/*kainawls tai yra tiek kiek turi moketi*/
													} else {
														/*kiek uz wl*/
														item_per_wl = kiek_turi_kainoti / item_count;
														/*itemperwl tai yra wl uz tiek*/
														kaina_wls = kiek_turi_kainoti;
														/*kainawls tai yra tiek kiek turi moketi*/
													}
													if (item_id == 7188) {
														item_per_wl = 1 * item_count;
														/*itemperwl tai yra wl uz tiek*/
														kaina_wls = kiek_turi_kainoti;
													}
													auto worldlocks = 0;
													auto diamondlocks = 0;
													auto locks = 0;
													for (auto i = 0; i < pData->inventory.items.size(); i++) {
														if (pData->inventory.items.at(i).itemID == 242) {
															worldlocks = pData->inventory.items.at(i).itemCount;
														}
														if (pData->inventory.items.at(i).itemID == 1796) {
															diamondlocks = pData->inventory.items.at(i).itemCount;
														}
													}
													if (diamondlocks > 0) locks = diamondlocks * 100;
													locks += worldlocks;
													if (kaina_wls > locks) {
														Player::OnTalkBubble(peer, pData->netID, "You can't afford that many!", 0, true);
														break;
													}
													if (getItemDef(item_id).blockType == BlockTypes::SIGN && getItemDef(item_id).rarity != 999 || getItemDef(item_id).blockType == BlockTypes::GATEWAY && getItemDef(item_id).rarity != 999 || getItemDef(item_id).blockType == BlockTypes::DEADLY && getItemDef(item_id).rarity != 999 || getItemDef(item_id).blockType == BlockTypes::DOOR && getItemDef(item_id).rarity != 999 || getItemDef(item_id).blockType == BlockTypes::PAIN_BLOCK && getItemDef(item_id).rarity != 999 || getItemDef(item_id).blockType == BlockTypes::PLATFORM && getItemDef(item_id).rarity != 999 || getItemDef(item_id).blockType == BlockTypes::BACKGROUND && getItemDef(item_id).rarity != 999 || getItemDef(item_id).blockType == BlockTypes::FOREGROUND && getItemDef(item_id).rarity != 999 && item_id != 9498 && item_id != 5154 && item_id != 5140 && item_id != 5138 && item_id != 5136 && item_id != 7382 && item_id != 4762 || getItemDef(item_id).blockType == BlockTypes::SFX_FOREGROUND && getItemDef(item_id).rarity != 999 || getItemDef(item_id).blockType == BlockTypes::ANIM_FOREGROUND && getItemDef(item_id).rarity != 999 || getItemDef(item_id).blockType == BlockTypes::TOGGLE_FOREGROUND && getItemDef(item_id).rarity != 999) {
														if (CheckItemMaxed(peer, item_id, kiek_turi_kainoti) || kiek_turi_kainoti > 250) {
															Player::OnTalkBubble(peer, pData->netID, "That wouldnt fit into my inventory!", 0, true);
															break;
														}
													} else {
														if (CheckItemMaxed(peer, item_id, item_count)) {
															Player::OnTalkBubble(peer, pData->netID, "That wouldnt fit into my inventory!", 0, true);
															break;
														}
													}
													if (item_id == 9498 || item_id == 5154 || item_id == 5140 || item_id == 5138 || item_id == 5136 || item_id == 7382 || item_id == 4762) {
														if (CheckItemMaxed(peer, item_id, 200)) {
															Player::OnTalkBubble(peer, pData->netID, "That wouldnt fit into my inventory!", 0, true);
															break;
														}
													}
													pData->laststorebuyprice = kaina_wls;
													pData->laststorebuyid = item_id;
													if (getItemDef(item_id).blockType == BlockTypes::SIGN && getItemDef(item_id).rarity != 999 || getItemDef(item_id).blockType == BlockTypes::GATEWAY && getItemDef(item_id).rarity != 999 || getItemDef(item_id).blockType == BlockTypes::DEADLY && getItemDef(item_id).rarity != 999 || getItemDef(item_id).blockType == BlockTypes::DOOR && getItemDef(item_id).rarity != 999 || getItemDef(item_id).blockType == BlockTypes::PAIN_BLOCK && getItemDef(item_id).rarity != 999 || getItemDef(item_id).blockType == BlockTypes::PLATFORM && getItemDef(item_id).rarity != 999 || getItemDef(item_id).blockType == BlockTypes::BACKGROUND && getItemDef(item_id).rarity != 999 || getItemDef(item_id).blockType == BlockTypes::FOREGROUND && getItemDef(item_id).rarity != 999 && item_id != 9498 && item_id != 5154 && item_id != 5140 && item_id != 5138 && item_id != 5136 && item_id != 7382 && item_id != 4762 || getItemDef(item_id).blockType == BlockTypes::SFX_FOREGROUND && getItemDef(item_id).rarity != 999 || getItemDef(item_id).blockType == BlockTypes::ANIM_FOREGROUND && getItemDef(item_id).rarity != 999 || getItemDef(item_id).blockType == BlockTypes::TOGGLE_FOREGROUND && getItemDef(item_id).rarity != 999) {
														pData->laststorebuycount = kiek_turi_kainoti;
													} else {
														pData->laststorebuycount = item_count;
													}
													string kiek_per = to_string(pData->laststorebuycount);
													if (item_id == 9498 || item_id == 5154 || item_id == 5140 || item_id == 5138 || item_id == 5136 || item_id == 7382 || item_id == 4762) {
														kiek_per = "150-200";
													}
													auto r_worldlocks = kaina_wls;
													auto r_diamondlocks = 0;
													while (r_worldlocks >= 100) {
														r_diamondlocks++;
														r_worldlocks -= 100;
													}
													string kiek_duos = "";
													if (r_diamondlocks != 0) {
														kiek_duos += "\nadd_label_with_icon|small|(`w" + to_string(r_diamondlocks) + "``) `2Diamond Locks``|left|1796|";
													}
													if (r_worldlocks != 0) {
														kiek_duos += "\nadd_label_with_icon|small|(`w" + to_string(r_worldlocks) + "``) `2World Locks``|left|242|";
													}
													Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wPurchase Confirmation``|left|1366|\nadd_spacer|small|\nadd_spacer|small|\nadd_textbox|`4You'll give:``|left|\nadd_spacer|small|" + kiek_duos + "\nadd_spacer|small|\nadd_textbox|`2You'll get:``|left|\nadd_spacer|small|\nadd_label_with_icon|small|(`w" + kiek_per + "``) `2" + getItemDef(pData->laststorebuyid).name + "``|left|" + to_string(item_id) + "|\nadd_spacer|small|\nadd_spacer|small|\nadd_textbox|Are you sure you want to make this purchase?|left|\nend_dialog|store_buy_confirm|Cancel|OK|");
												}
											}
											if (isMinerDialog) { 
												if (infoDat.at(1) == "chc0" || infoDat.at(1) == "backExchange") { /*exchange*/
													string turi = "";
													auto KiekTuri_coal = 0;
													for (auto i = 0; i < pData->inventory.items.size(); i++) {
														if (pData->inventory.items.at(i).itemID == 7960 && pData->inventory.items.at(i).itemCount >= 1) {
															KiekTuri_coal = pData->inventory.items.at(i).itemCount;
															break;
														}
													}
													auto KiekTuri_iron = 0;
													for (auto i = 0; i < pData->inventory.items.size(); i++) {
														if (pData->inventory.items.at(i).itemID == 8428 && pData->inventory.items.at(i).itemCount >= 1) {
															KiekTuri_iron = pData->inventory.items.at(i).itemCount;
															break;
														}
													}
													auto KiekTuri_gold = 0;
													for (auto i = 0; i < pData->inventory.items.size(); i++) {
														if (pData->inventory.items.at(i).itemID == 8430 && pData->inventory.items.at(i).itemCount >= 1) {
															KiekTuri_gold = pData->inventory.items.at(i).itemCount;
															break;
														}
													}
													auto KiekTuri_diamond = 0;
													for (auto i = 0; i < pData->inventory.items.size(); i++) {
														if (pData->inventory.items.at(i).itemID == 7962 && pData->inventory.items.at(i).itemCount >= 1) {
															KiekTuri_diamond = pData->inventory.items.at(i).itemCount;
															break;
														}
													}
													turi += "\nadd_label_with_icon|small|You currently have " + to_string(KiekTuri_coal) + " Coal|left|7960|";
													turi += "\nadd_label_with_icon|small|You currently have " + to_string(KiekTuri_iron) + " Iron|left|8428|";
													turi += "\nadd_label_with_icon|small|You currently have " + to_string(KiekTuri_gold) + " Gold|left|8430|";
													turi += "\nadd_label_with_icon|small|You currently have " + to_string(KiekTuri_diamond) + " Diamond|left|7962|";
													Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wThe Miner: Exchange``|left|9150|\nadd_textbox|Excellent! I'm happy to sell you rare and precious items in exchange for Minerals.|left|" + turi + "\nadd_spacer|small|\ntext_scaling_string|5000WTASDA|\nadd_button_with_icon|buy2486|50 Gold|noflags|2486||\nadd_button_with_icon|buy1486|10 Coal|noflags|1486||\nadd_button_with_icon||END_LIST|noflags|0||\nadd_button|chc2|Back|noflags|0|0|\nend_dialog|phonecall|Leave||");
													break;
												}
												if (infoDat.at(1) == "buydarknesshelmet") { /*final buy darknesshelmet*/
													auto contains = false;
													SearchInventoryItem(peer, 8430, 50, contains);
													if (!contains) break;
													RemoveInventoryItem(8430, 50, peer, true);
													auto success = true;
													SaveItemMoreTimes(2486, 1, peer, success);
													Player::OnConsoleMessage(peer, "CP:_PL:0_OID:_CT:[W]_ `6<`9The Miner`6> `oThanks for purchasing Helmet Of Darkness for 50 Gold!");
													SendTradeEffect(peer, 2486, pData->netID, pData->netID, 150);
													Player::PlayAudio(peer, "audio/cash_register.wav", 0);
													break;
												}
												if (infoDat.at(1) == "buy2486") { /*the darkness helmet*/
													auto KiekTuri_gold = 0;
													for (auto i = 0; i < pData->inventory.items.size(); i++) {
														if (pData->inventory.items.at(i).itemID == 8430 && pData->inventory.items.at(i).itemCount >= 1) {
															KiekTuri_gold = pData->inventory.items.at(i).itemCount;
															break;
														}
													}
													if (KiekTuri_gold < 50) {
														Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wThe Miner``|left|9150|\nadd_textbox||left|\nadd_textbox|Helmet Of Darkness costs 50 Gold. You only have " + to_string(KiekTuri_gold) + " so you can't afford it. Sorry!|left|\nadd_button|backExchange|Back|noflags|0|0|\nend_dialog|phonecall|Leave||");
													} else {
														Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wThe Miner``|left|9150|\nadd_textbox||left|\nadd_textbox|Helmet Of Darkness costs 50 Gold. Are you sure you want to buy it? You have " + to_string(KiekTuri_gold) + " Gold.|left|\nadd_button|buydarknesshelmet|Yes, please|noflags|0|0|\nadd_button|backExchange|No, thanks|noflags|0|0|\nend_dialog|phonecall|Leave||");
													}
													break;
												}
												if (infoDat.at(1) == "buygrowtoken") { /*final buy growtoken*/
													auto contains = false;
													SearchInventoryItem(peer, 7960, 10, contains);
													if (!contains) break;
													RemoveInventoryItem(7960, 10, peer, true);
													auto success = true;
													SaveItemMoreTimes(1486, 1, peer, success);
													Player::OnConsoleMessage(peer, "CP:_PL:0_OID:_CT:[W]_ `6<`9The Miner`6> `oThanks for purchasing Growtoken for 10 Coal!");
													SendTradeEffect(peer, 1486, pData->netID, pData->netID, 150);
													Player::PlayAudio(peer, "audio/cash_register.wav", 0);
													break;
												}
												if (infoDat.at(1) == "buy1486") { /*growtoken*/
													auto KiekTuri_coal = 0;
													for (auto i = 0; i < pData->inventory.items.size(); i++) {
														if (pData->inventory.items.at(i).itemID == 7960 && pData->inventory.items.at(i).itemCount >= 1) {
															KiekTuri_coal = pData->inventory.items.at(i).itemCount;
															break;
														}
													}
													if (KiekTuri_coal < 10) {
														Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wThe Miner``|left|9150|\nadd_textbox||left|\nadd_textbox|Growtoken costs 10 Coal. You only have " + to_string(KiekTuri_coal) + " so you can't afford it. Sorry!|left|\nadd_button|backExchange|Back|noflags|0|0|\nend_dialog|phonecall|Leave||");
													} else {
														Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wThe Miner``|left|9150|\nadd_textbox||left|\nadd_textbox|Growtoken costs 10 Coal. Are you sure you want to buy it? You have " + to_string(KiekTuri_coal) + " Coal.|left|\nadd_button|buygrowtoken|Yes, please|noflags|0|0|\nadd_button|backExchange|No, thanks|noflags|0|0|\nend_dialog|phonecall|Leave||");
													}
													//RemoveInventoryItem(7962, 10, peer, true);
													break;
												}
												if (infoDat.at(1) == "chc1" || infoDat.at(1) == "backSell") { /*sell*/
													string turi = "";
													auto KiekTuri_coal = 0;
													for (auto i = 0; i < pData->inventory.items.size(); i++) {
														if (pData->inventory.items.at(i).itemID == 7960 && pData->inventory.items.at(i).itemCount >= 1) {
															KiekTuri_coal = pData->inventory.items.at(i).itemCount;
															break;
														}
													}
													auto KiekTuri_iron = 0;
													for (auto i = 0; i < pData->inventory.items.size(); i++) {
														if (pData->inventory.items.at(i).itemID == 8428 && pData->inventory.items.at(i).itemCount >= 1) {
															KiekTuri_iron = pData->inventory.items.at(i).itemCount;
															break;
														}
													}
													auto KiekTuri_gold = 0;
													for (auto i = 0; i < pData->inventory.items.size(); i++) {
														if (pData->inventory.items.at(i).itemID == 8430 && pData->inventory.items.at(i).itemCount >= 1) {
															KiekTuri_gold = pData->inventory.items.at(i).itemCount;
															break;
														}
													}
													auto KiekTuri_diamond = 0;
													for (auto i = 0; i < pData->inventory.items.size(); i++) {
														if (pData->inventory.items.at(i).itemID == 7962 && pData->inventory.items.at(i).itemCount >= 1) {
															KiekTuri_diamond = pData->inventory.items.at(i).itemCount;
															break;
														}
													}
													turi += "\nadd_label_with_icon|small|You currently have " + to_string(KiekTuri_coal) + " Coal (1/50 gems)|left|7960|";
													turi += "\nadd_label_with_icon|small|You currently have " + to_string(KiekTuri_iron) + " Iron (1/150 gems)|left|8428|";
													turi += "\nadd_label_with_icon|small|You currently have " + to_string(KiekTuri_gold) + " Gold (1/300 gems)|left|8430|";
													turi += "\nadd_label_with_icon|small|You currently have " + to_string(KiekTuri_diamond) + " Diamond (1/1000 gems)|left|7962|";
													Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wThe Miner: Sell Minerals``|left|9150|\nadd_textbox|Excellent! I'm happy to purchase your minerals in exchange for Gems.|left|" + turi + "\nadd_spacer|small|\ntext_scaling_string|5000WTASDASDASD|\nadd_button_with_icon|sellallcoal|Sell all for " + to_string(KiekTuri_coal * 50) + " gems|noflags|7960||\nadd_button_with_icon|sellalliron|Sell all for " + to_string(KiekTuri_iron * 150) + " gems|noflags|8428||\nadd_button_with_icon|sellallgold|Sell all for " + to_string(KiekTuri_gold * 300) + " gems|noflags|8430||\nadd_button_with_icon|sellalldiamond|Sell all for " + to_string(KiekTuri_diamond * 1000) + " gems|noflags|7962||\nadd_button_with_icon||END_LIST|noflags|0||\nadd_button|chc2|Back|noflags|0|0|\nend_dialog|phonecall|Leave||");
													break;
												}
												if (infoDat.at(1) == "sellconfirmdiamond") {
													auto contains = false;
													SearchInventoryItem(peer, 7962, 1, contains);
													if (!contains) break;
													auto KiekTuri_diamond = 0;
													for (auto i = 0; i < pData->inventory.items.size(); i++) {
														if (pData->inventory.items.at(i).itemID == 7962 && pData->inventory.items.at(i).itemCount >= 1) {
															KiekTuri_diamond = pData->inventory.items.at(i).itemCount;
															break;
														}
													}
													RemoveInventoryItem(7962, KiekTuri_diamond, peer, true);
													int for_gems = KiekTuri_diamond * 1000;
													std::ifstream ifsz("save/gemdb/_" + pData->rawName + ".txt");
													std::string content((std::istreambuf_iterator<char>(ifsz)), (std::istreambuf_iterator<char>()));
													auto gembux = atoi(content.c_str());
													auto fingembux = gembux + for_gems;
													ofstream myfile;
													myfile.open("save/gemdb/_" + pData->rawName + ".txt");
													myfile << fingembux;
													myfile.close();
													int gemcalc = gembux + for_gems;
													Player::OnSetBux(peer, gemcalc, 0);
													Player::OnConsoleMessage(peer, "CP:_PL:0_OID:_CT:[W]_ `6<`9The Miner`6> `oThanks for selling " + to_string(KiekTuri_diamond) + " Diamond for " + to_string(for_gems) + " Gems!");
													SendTradeEffect(peer, 112, pData->netID, pData->netID, 150);
													Player::PlayAudio(peer, "audio/cash_register.wav", 0);
													break;
												}
												if (infoDat.at(1) == "sellalldiamond") { /*sellalldiamond*/
													auto KiekTuri_diamond = 0;
													for (auto i = 0; i < pData->inventory.items.size(); i++) {
														if (pData->inventory.items.at(i).itemID == 7962 && pData->inventory.items.at(i).itemCount >= 1) {
															KiekTuri_diamond = pData->inventory.items.at(i).itemCount;
															break;
														}
													}
													if (KiekTuri_diamond < 1) {
														Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wThe Miner``|left|9150|\nadd_textbox||left|\nadd_textbox|It seems that you Don't have any Diamond to sell, come back later when you will have some. Sorry!|left|\nadd_button|backSell|Back|noflags|0|0|\nend_dialog|phonecall|Leave||");
													} else {
														Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wThe Miner``|left|9150|\nadd_textbox||left|\nadd_textbox|Sell " + to_string(KiekTuri_diamond) + " Diamond for " + to_string(KiekTuri_diamond * 1000) + " Gems. Are you sure you want to sell it?|left|\nadd_button|sellconfirmdiamond|Yes, please|noflags|0|0|\nadd_button|backSell|No, thanks|noflags|0|0|\nend_dialog|phonecall|Leave||");
													}
													//RemoveInventoryItem(7962, 10, peer, true);
													break;
												}
												if (infoDat.at(1) == "sellconfirmgold") {
													auto contains = false;
													SearchInventoryItem(peer, 8430, 1, contains);
													if (!contains) break;
													auto KiekTuri_gold = 0;
													for (auto i = 0; i < pData->inventory.items.size(); i++) {
														if (pData->inventory.items.at(i).itemID == 8430 && pData->inventory.items.at(i).itemCount >= 1) {
															KiekTuri_gold = pData->inventory.items.at(i).itemCount;
															break;
														}
													}
													RemoveInventoryItem(8430, KiekTuri_gold, peer, true);
													int for_gems = KiekTuri_gold * 300;
													std::ifstream ifsz("save/gemdb/_" + pData->rawName + ".txt");
													std::string content((std::istreambuf_iterator<char>(ifsz)), (std::istreambuf_iterator<char>()));
													auto gembux = atoi(content.c_str());
													auto fingembux = gembux + for_gems;
													ofstream myfile;
													myfile.open("save/gemdb/_" + pData->rawName + ".txt");
													myfile << fingembux;
													myfile.close();
													int gemcalc = gembux + for_gems;
													Player::OnSetBux(peer, gemcalc, 0);
													Player::OnConsoleMessage(peer, "CP:_PL:0_OID:_CT:[W]_ `6<`9The Miner`6> `oThanks for selling " + to_string(KiekTuri_gold) + " Gold for " + to_string(for_gems) + " Gems!");
													SendTradeEffect(peer, 112, pData->netID, pData->netID, 150);
													Player::PlayAudio(peer, "audio/cash_register.wav", 0);
													break;
												}
												if (infoDat.at(1) == "sellallgold") { /*sellallgold*/
													auto KiekTuri_gold = 0;
													for (auto i = 0; i < pData->inventory.items.size(); i++) {
														if (pData->inventory.items.at(i).itemID == 8430 && pData->inventory.items.at(i).itemCount >= 1) {
															KiekTuri_gold = pData->inventory.items.at(i).itemCount;
															break;
														}
													}
													if (KiekTuri_gold < 1) {
														Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wThe Miner``|left|9150|\nadd_textbox||left|\nadd_textbox|It seems that you Don't have any Gold to sell, come back later when you will have some. Sorry!|left|\nadd_button|backSell|Back|noflags|0|0|\nend_dialog|phonecall|Leave||");
													} else {
														Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wThe Miner``|left|9150|\nadd_textbox||left|\nadd_textbox|Sell " + to_string(KiekTuri_gold) + " Gold for " + to_string(KiekTuri_gold * 300) + " Gems. Are you sure you want to sell it?|left|\nadd_button|sellconfirmgold|Yes, please|noflags|0|0|\nadd_button|backSell|No, thanks|noflags|0|0|\nend_dialog|phonecall|Leave||");
													}
													//RemoveInventoryItem(7962, 10, peer, true);
													break;
												}
												if (infoDat.at(1) == "sellconfirmcoal") {
													auto contains = false;
													SearchInventoryItem(peer, 7960, 1, contains);
													if (!contains) break;
													auto KiekTuri_coal = 0;
													for (auto i = 0; i < pData->inventory.items.size(); i++) {
														if (pData->inventory.items.at(i).itemID == 7960 && pData->inventory.items.at(i).itemCount >= 1) {
															KiekTuri_coal = pData->inventory.items.at(i).itemCount;
															break;
														}
													}
													RemoveInventoryItem(7960, KiekTuri_coal, peer, true);
													int for_gems = KiekTuri_coal * 50;
													std::ifstream ifsz("save/gemdb/_" + pData->rawName + ".txt");
													std::string content((std::istreambuf_iterator<char>(ifsz)), (std::istreambuf_iterator<char>()));
													auto gembux = atoi(content.c_str());
													auto fingembux = gembux + for_gems;
													ofstream myfile;
													myfile.open("save/gemdb/_" + pData->rawName + ".txt");
													myfile << fingembux;
													myfile.close();
													int gemcalc = gembux + for_gems;
													Player::OnSetBux(peer, gemcalc, 0);
													Player::OnConsoleMessage(peer, "CP:_PL:0_OID:_CT:[W]_ `6<`9The Miner`6> `oThanks for selling " + to_string(KiekTuri_coal) + " Coal for " + to_string(for_gems) + " Gems!");
													SendTradeEffect(peer, 112, pData->netID, pData->netID, 150);
													Player::PlayAudio(peer, "audio/cash_register.wav", 0);
													break;
												}
												if (infoDat.at(1) == "sellconfirmiron") {
													auto contains = false;
													SearchInventoryItem(peer, 8428, 1, contains);
													if (!contains) break;
													auto KiekTuri_iron = 0;
													for (auto i = 0; i < pData->inventory.items.size(); i++) {
														if (pData->inventory.items.at(i).itemID == 8428 && pData->inventory.items.at(i).itemCount >= 1) {
															KiekTuri_iron = pData->inventory.items.at(i).itemCount;
															break;
														}
													}
													RemoveInventoryItem(8428, KiekTuri_iron, peer, true);
													int for_gems = KiekTuri_iron * 150;
													std::ifstream ifsz("save/gemdb/_" + pData->rawName + ".txt");
													std::string content((std::istreambuf_iterator<char>(ifsz)), (std::istreambuf_iterator<char>()));
													auto gembux = atoi(content.c_str());
													auto fingembux = gembux + for_gems;
													ofstream myfile;
													myfile.open("save/gemdb/_" + pData->rawName + ".txt");
													myfile << fingembux;
													myfile.close();
													int gemcalc = gembux + for_gems;
													Player::OnSetBux(peer, gemcalc, 0);
													Player::OnConsoleMessage(peer, "CP:_PL:0_OID:_CT:[W]_ `6<`9The Miner`6> `oThanks for selling " + to_string(KiekTuri_iron) + " Iron for " + to_string(for_gems) + " Gems!");
													SendTradeEffect(peer, 112, pData->netID, pData->netID, 150);
													Player::PlayAudio(peer, "audio/cash_register.wav", 0);
													break;
												}
												if (infoDat.at(1) == "sellallcoal") { /*sellallcoal*/
													auto KiekTuri_coal = 0;
													for (auto i = 0; i < pData->inventory.items.size(); i++) {
														if (pData->inventory.items.at(i).itemID == 7960 && pData->inventory.items.at(i).itemCount >= 1) {
															KiekTuri_coal = pData->inventory.items.at(i).itemCount;
															break;
														}
													}
													if (KiekTuri_coal < 1) {
														Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wThe Miner``|left|9150|\nadd_textbox||left|\nadd_textbox|It seems that you Don't have any Coal to sell, come back later when you will have some. Sorry!|left|\nadd_button|backSell|Back|noflags|0|0|\nend_dialog|phonecall|Leave||");
													} else {
														Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wThe Miner``|left|9150|\nadd_textbox||left|\nadd_textbox|Sell " + to_string(KiekTuri_coal) + " Coal for " + to_string(KiekTuri_coal * 50) + " Gems. Are you sure you want to sell it?|left|\nadd_button|sellconfirmcoal|Yes, please|noflags|0|0|\nadd_button|backSell|No, thanks|noflags|0|0|\nend_dialog|phonecall|Leave||");
													}
													//RemoveInventoryItem(7962, 10, peer, true);
													break;
												}
												if (infoDat.at(1) == "sellalliron") { /*sellalliron*/
													auto KiekTuri_iron = 0;
													for (auto i = 0; i < pData->inventory.items.size(); i++) {
														if (pData->inventory.items.at(i).itemID == 8428 && pData->inventory.items.at(i).itemCount >= 1) {
															KiekTuri_iron = pData->inventory.items.at(i).itemCount;
															break;
														}
													}
													if (KiekTuri_iron < 1) {
														Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wThe Miner``|left|9150|\nadd_textbox||left|\nadd_textbox|It seems that you Don't have any Iron to sell, come back later when you will have some. Sorry!|left|\nadd_button|backSell|Back|noflags|0|0|\nend_dialog|phonecall|Leave||");
													} else {
														Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wThe Miner``|left|9150|\nadd_textbox||left|\nadd_textbox|Sell " + to_string(KiekTuri_iron) + " Iron for " + to_string(KiekTuri_iron * 150) + " Gems. Are you sure you want to sell it?|left|\nadd_button|sellconfirmiron|Yes, please|noflags|0|0|\nadd_button|backSell|No, thanks|noflags|0|0|\nend_dialog|phonecall|Leave||");
													}
													//RemoveInventoryItem(7962, 10, peer, true);
													break;
												}

												if (infoDat.at(1) == "chc2") { /*back*/
													Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wThe Miner``|left|9150|\nadd_textbox|Welcome, welcome young miner! Seems like you made your way to me hopefuly it wasnt too hard. What would you like to do today?|left|\nadd_button|chc0|Mineral Items|noflags|0|0|\nadd_button|chc1|Sell Minerals|noflags|0|0|\nend_dialog|phonecall|Leave||");
													break;
												}
											}
											if (isFindDialog && btn.substr(0, 4) == "tool") {
												int id = atoi(btn.substr(4, btn.length() - 4).c_str());
												if (btn.substr(4, btn.length() - 4).size() > 5 || pData->currentWorld == "EXIT" || id > maxItems || id <= 0 || btn.substr(4, btn.length() - 4).size() <= 0) continue;
												//if (id == 242 || id == 1796 || id == 7188 || getItemDef(id).name.find("Mooncake") != string::npos || getItemDef(id).name.find("Harvest") != string::npos && id != 1830 || getItemDef(id).name.find("Autumn") != string::npos || id == 1056 || id == 1804 || getItemDef(id).blockType == BlockTypes::COMPONENT || getItemDef(id).properties & Property_Chemical || id == 6920 || id == 6922 || id == 1874 || id == 3402 || id == 1876 || id == 1904 || id == 1932 || id == 1900 || id == 1986 || id == 1996 || id == 2970 || id == 3140 || id == 3174 || id == 6028 || id == 6846 || id == 8962 || id == 2408 || id == 4428 || id == 5086 || id == 9240 || id == 9306 || id == 9290 || id == 7328 || id == 9416 || id == 10386 || id == 9410 || id == 1458 || id == 9408 || id == 9360 || id == 6866 || id == 6868 || id == 6870 || id == 6872 || id == 6874 || id == 6876 || id == 6878 || id == 2480 || id == 8452 || id == 5132 || id == 7166 || id == 5126 || id == 5128 || id == 5130 || id == 5144 || id == 5146 || id == 5148 || id == 5150 || id == 5162 || id == 5164 || id == 5166 || id == 5168 || id == 5180 || id == 5182 || id == 5184 || id == 5186 || id == 7168 || id == 7170 || id == 7172 || id == 7174 || id == 8834 || id == 7912 || id == 9212 || id == 5134 || id == 5152 || id == 5170 || id == 5188 || id == 980 || id == 9448 || id == 9310 || id == 10034 || id == 10036 || id == 8470 || id == 8286 || id == 6026 || id == 1784 || id == 9356 || id == 10022 || id == 902 || id == 10032 || id == 834 || id == 6 || id == 5640 || id == 9492 || id == 1782 || id == 9288 || id == 1780 || id == 8306 || id == 202 || id == 204 || id == 206 || id == 2950 || id == 4802 || id == 4994 || id == 5260 || id == 5814 || id == 5980 || id == 7734 || id == 2592 || id == 2242 || id == 1794 || id == 1792 || id == 778 || id == 9510 || id == 8774 || id == 2568 || id == 9512 || id == 9502 || id == 9482 || id == 2250 || id == 2248 || id == 2244 || id == 2246 || id == 2286 || id == 9508 || id == 9504 || id == 9506 || id == 274 || id == 276 || id == 9476 || id == 1486 || id == 9498 || id == 4426 || id == 9496 || id == 278 || id == 9490 || id == 2410 || id == 9488 || id == 9452 || id == 9454 || id == 9472 || id == 9456 || id == 732 || id == 9458 || id == 6336 || id == 112 || id == 8 || id == 3760 || getItemDef(id).blockType == BlockTypes::FISH || id == 7372 || id == 9438 || id == 9462 || id == 9440 || id == 9442 || id == 9444 || id == 7960 || id == 7628 || id == 8552) continue;
												int kaina = 0;
												int kaina_vakar = 0;
												int kaina_uzvakar = 0;
												int kaina_uzvakar_uzvakar = 0;

												int p_1 = 0;
												int p_2 = 0;
												int p_3 = 0;
												int p_6 = 0;
												try {
													ifstream infile("price_data.txt");
													for (string line; getline(infile, line);) {
														if (line.length() > 3 && line.at(0) != '/' && line.at(1) != '/') {
															auto ex = explode("|", line);
															if (ex.at(0) == to_string(id)) {
																kaina = atoi(ex.at(1).c_str());
																p_1 = atoi(ex.at(2).c_str());
																break;
															}
														}
													}
													infile.close();
													ifstream infiles("price_data1.txt");
													for (string line; getline(infiles, line);) {
														if (line.length() > 3 && line.at(0) != '/' && line.at(1) != '/') {
															auto ex = explode("|", line);
															if (ex.at(0) == to_string(id)) {
																kaina_vakar = atoi(ex.at(1).c_str());
																p_2 = atoi(ex.at(2).c_str());
																break;
															}
														}
													}
													infiles.close();
													ifstream infiless("price_data2.txt");
													for (string line; getline(infiless, line);) {
														if (line.length() > 3 && line.at(0) != '/' && line.at(1) != '/') {
															auto ex = explode("|", line);
															if (ex.at(0) == to_string(id)) {
																kaina_uzvakar = atoi(ex.at(1).c_str());
																p_3 = atoi(ex.at(2).c_str());
																break;
															}
														}
													}
													infiless.close();
													ifstream infilssse("price_data3.txt");
													for (string line; getline(infilssse, line);) {
														if (line.length() > 3 && line.at(0) != '/' && line.at(1) != '/') {
															auto ex = explode("|", line);
															if (ex.at(0) == to_string(id)) {
																kaina_uzvakar_uzvakar = atoi(ex.at(1).c_str());
																p_6 = atoi(ex.at(2).c_str());
																break;
															}
														}
													}
													infilssse.close();
												} catch(const std::out_of_range& e) {
													std::cout << e.what() << std::endl;
												} 
												if (kaina == 0) continue;
												float price_difference = (kaina-kaina_vakar)/(double)kaina_vakar * 100;
												std::stringstream stream;
												stream << std::fixed << std::setprecision(2) << price_difference;
												std::string price_difference_string = stream.str();
												string sellbutton = "\nadd_button|sellitembyrarityid_" + to_string(id) + "|`wSell|noflags|0|0|";
												if (getItemDef(id).blockType == BlockTypes::SIGN && getItemDef(id).rarity != 999 || getItemDef(id).blockType == BlockTypes::GATEWAY && getItemDef(id).rarity != 999 || getItemDef(id).blockType == BlockTypes::DEADLY && getItemDef(id).rarity != 999 || getItemDef(id).blockType == BlockTypes::DOOR && getItemDef(id).rarity != 999 || getItemDef(id).blockType == BlockTypes::PAIN_BLOCK && getItemDef(id).rarity != 999 || getItemDef(id).blockType == BlockTypes::PLATFORM && getItemDef(id).rarity != 999 || getItemDef(id).blockType == BlockTypes::BACKGROUND && getItemDef(id).rarity != 999 || getItemDef(id).blockType == BlockTypes::FOREGROUND && getItemDef(id).rarity != 999 && id != 9498 && id != 5154 && id != 5140 && id != 5138 && id != 5136 && id != 7382 && id != 4762 || getItemDef(id).blockType == BlockTypes::SFX_FOREGROUND && getItemDef(id).rarity != 999 || getItemDef(id).blockType == BlockTypes::ANIM_FOREGROUND && getItemDef(id).rarity != 999 || getItemDef(id).blockType == BlockTypes::TOGGLE_FOREGROUND && getItemDef(id).rarity != 999) {
													if (getItemDef(id).rarity < 14 || getItemDef(id).properties & Property_Untradable || getItemDef(id).rarity == 999) sellbutton = "";
													string history_day1 = "Yesterday Price: " + to_string(kaina_vakar) + "/1 World lock (" + to_string(p_2) + " purchased)";
													string history_day2 = "2 Days ago Price: " + to_string(kaina_uzvakar) + "/1 World lock (" + to_string(p_3) + " purchased)";
													string history_day3 = "3 Days ago Price: " + to_string(kaina_uzvakar_uzvakar) + "/1 World lock (" + to_string(p_6) + " purchased)";
													if (kaina_vakar == 0) {
														history_day1 = "`oYesterday Price: No data";
													}
													if (kaina_uzvakar == 0) {
														history_day2 = "`o2 Days ago Price: No data";
													}
													if (kaina_uzvakar_uzvakar == 0) {
														history_day3 = "`o3 Days ago Price: No data";
													}
													string price_difference_log = "";
													if ((int)price_difference < -1000) price_difference = 0;
													if ((int)price_difference < 0) {
														price_difference_log = "\nadd_label_with_icon|small|Price since yesterday was changed by `4" + price_difference_string + "%|left|10074|";
													} else if ((int)price_difference == 0) {
														price_difference_log = "\nadd_label_with_icon|small|Price since yesterday was changed by `90%|left|10072|";
													} else {
														price_difference_log = "\nadd_label_with_icon|small|Price since yesterday was changed by `2" + price_difference_string + "%|left|10072|";
													}
													Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`oViewing `$" + getItemDef(id).name + " `oMarketing history``|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|Purchase or sell items here, each 24 hours the prices are being re-rolled into higher or lower, price history can be seen below|left|\nadd_spacer|small|\nadd_textbox|`$Current Price: " + to_string(kaina) + "/1 World lock (" + to_string(p_1) + " purchased)|left|\nadd_textbox|" + history_day1 + "|left|\nadd_textbox|" + history_day2 + "|left|\nadd_textbox|" + history_day3 + "|left|\nadd_spacer|small|" + price_difference_log + "\nadd_spacer|small|\nadd_textbox|`oHow much " + getItemDef(id).name +" you want to buy/sell? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||\nadd_label_with_icon|small|`4Enter value in World locks 1 means " + to_string(kaina) + " `4blocks of " + getItemDef(id).name + "`4!|left|3764|\nadd_spacer|small|" + sellbutton + "\nend_dialog|purchase_item|Cancel|Purchase|");
												} else {
													if (getItemDef(id).rarity != 999 && id != 5142 && id != 9498 && id != 5154 && id != 5140 && id != 5138 && id != 5136 && id != 7382 && id != 4762 || getItemDef(id).properties & Property_Untradable) sellbutton = "";
													string kiek_per = "1";
													string per_ka = "World locks";
													string warning = "";
													if (id == 9498 || id == 5154 || id == 5140 || id == 5138 || id == 5136 || id == 7382 || id == 4762) {
														kiek_per = "150-200";
														warning = "\nadd_label_with_icon|small|`4Enter value in amount of purchase 1 means " + kiek_per + " `4blocks of " + getItemDef(id).name + "`4!|left|3764|";
													}
													if (id == 7188) {
														kiek_per = "1";
														per_ka = "Diamond locks";
														kaina = 100;
														warning = "\nadd_label_with_icon|small|`4This item has a fixed price, it isnt changing`4!|left|3764|";
													}
													string history_day1 = "Yesterday Price: 1/" + to_string(kaina_vakar) + " " + per_ka + " (" + to_string(p_2) + " purchased)";
													string history_day2 = "2 Days ago Price: 1/" + to_string(kaina_uzvakar) + " " + per_ka + " (" + to_string(p_3) + " purchased)";
													string history_day3 = "3 Days ago Price: 1/" + to_string(kaina_uzvakar_uzvakar) + " " + per_ka + " (" + to_string(p_6) + " purchased)";
													if (kaina_vakar == 0) {
														history_day1 = "`oYesterday Price: No data";
													}
													if (kaina_uzvakar == 0) {
														history_day2 = "`o2 Days ago Price: No data";
													}
													if (kaina_uzvakar_uzvakar == 0) {
														history_day3 = "`o3 Days ago Price: No data";
													}
													string price_difference_log = "";
													if ((int)price_difference < -1000) price_difference = 0;
													if ((int)price_difference < 0) {
														price_difference_log = "\nadd_label_with_icon|small|Price since yesterday was changed by `4" + price_difference_string + "%|left|10074|";
													} else if ((int)price_difference == 0) {
														price_difference_log = "\nadd_label_with_icon|small|Price since yesterday was changed by `90%|left|10072|";
													} else {
														price_difference_log = "\nadd_label_with_icon|small|Price since yesterday was changed by `2" + price_difference_string + "%|left|10072|";
													}
													Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`oViewing `$" + getItemDef(id).name + " `oMarketing history``|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|Purchase or sell items here, each 24 hours the prices are being re-rolled into higher or lower, price history can be seen below|left|\nadd_spacer|small|\nadd_textbox|`$Current Price: " + kiek_per + "/" + to_string(kaina) + " " + per_ka + " (" + to_string(p_1) + " purchased)|left|\nadd_textbox|" + history_day1 + "|left|\nadd_textbox|" + history_day2 + "|left|\nadd_textbox|" + history_day3 + "|left|\nadd_spacer|small|" + price_difference_log + "\nadd_spacer|small|\nadd_textbox|`oHow much " + getItemDef(id).name +" you want to buy/sell? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||" + warning + "\nadd_spacer|small|" + sellbutton + "\nend_dialog|purchase_item|Cancel|Purchase|");
												}
											}
											if (billpicker) {
												if (infoDat.at(0) == "billitem") billitem = atoi(infoDat.at(1).c_str());
												if (getItemDef(billitem).properties & Property_Untradable) {
													Player::OnConsoleMessage(peer, "`oUntradeable items can't be advertised on billboards.");
													Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`wUntradeable items can't be advertised on billboards.", 0, false);
													continue;
												}
												if (getItemDef(billitem).blockType == BlockTypes::LOCK) {
													Player::OnConsoleMessage(peer, "`oNo no no.");
													Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`wNo no no.", 0, false);
													continue;
												}
												((PlayerInfo*)(peer->data))->billboardid = billitem;
												BillBoard(peer, ((PlayerInfo*)(peer->data))->billboardid, ((PlayerInfo*)(peer->data))->billboardprice, ((PlayerInfo*)(peer->data))->billboardtab, ((PlayerInfo*)(peer->data))->billboardperwhat);
												SendBillBoard(peer);
											}
											if (captcha) { //captcha requirements
												if (infoDat.at(0) == "captcha_answer") captchaanswer = infoDat.at(1);
											}
											if (captcha) { //captcha system sending
												int x;

												try {
													x = stoi(captchaanswer);
												}
												catch (std::invalid_argument& e) {
													continue;
												}
												string kintil = captchaanswer;

												if (x > hasil || x != hasil || captchaanswer.length() < 0) {
													int userMaxRand = 70, userLowRand = 0;

													resultnbr2 = rand() % userMaxRand + userLowRand + 1;
													srand(time(0));
													resultnbr1 = rand() % userMaxRand + userLowRand + 1; // Randomizes between the numbers you choose.

													hasil = resultnbr1 + resultnbr2;
													string captcha = "set_default_color|`o\nadd_label_with_icon|big|`wAre you Human?``|left|206|\nadd_spacer|small|\nadd_textbox|What will be the sum of the following numbers|left|\nadd_textbox|" + to_string(resultnbr1) + " + " + to_string(resultnbr2) + "|left|\nadd_text_input|captcha_answer|Answer:||32|\nend_dialog|captcha_submit||Submit|";
													Player::OnDialogRequest(peer, captcha);
													break;
												}
												else {
													continue;
												}
											}
											if (isAdventure) { //adventure start
												if (infoDat.at(0) == "adventuresign") adventuresign = infoDat.at(1); //recording
											}
											if (isAdventure) { //adventure end
												if (infoDat.at(0) == "adventuresign")
												{
													if (adventuresign != "") {

														adventuresign = infoDat.at(1);
														PlayerInfo* pinfo = ((PlayerInfo*)(peer->data));
														int x = pinfo->wrenchedBlockLocation % world->width;
														int y = pinfo->wrenchedBlockLocation / world->width;
														string sign = adventuresign;
														world->items.at(x + (y * world->width)).sign = sign;
														send_state(peer);
														Player::OnTalkBubble(peer, pData->netID, "`wUpdated Adventure!", 0, true);
													}
												}
											}
											if (isEditState) {
												if (infoDat.at(0) == "EditState") newstate = infoDat.at(1);
											}
											if (isEditState) {
												if (newstate.length() < 3) {
													continue;
												}
												((PlayerInfo*)(peer->data))->LastState = newstate;
												string oldname = PlayerDB::getProperName(((PlayerInfo*)(peer->data))->guild);
												ifstream fg("save/guilds/_" + oldname + ".json");
												json j;
												fg >> j;
												fg.close();
												j["GuildStatement"] = newstate;
												ofstream fs("save/guilds/_" + oldname + ".json");
												fs << j;
												fs.close();
											}
	
											if (isGuildDialog) {
												if (infoDat.at(0) == "gname") guildName = infoDat.at(1);
												if (infoDat.at(0) == "gstatement") guildStatement = infoDat.at(1);
												if (infoDat.at(0) == "ggcflagbg") guildFlagBg = infoDat.at(1);
												if (infoDat.at(0) == "ggcflagfg") guildFlagFg = infoDat.at(1);
												if (world == nullptr || world->name == "EXIT" || serverIsFrozen) continue;
												if (world->owner != ((PlayerInfo*)(peer->data))->rawName) {
													Player::OnDialogRequest(peer, "set_default_color|`o\n\nadd_label_with_icon|big|`wGrow Guild Creation|left|5814|\nadd_textbox|`4Oops! `oYou must make guild in world you owned!``|\nadd_text_input|gname|`oGuild Name:``|" + guildName + "|15|\nadd_text_input|gstatement|`oGuild Statement:``|" + guildStatement + "|40|\nadd_text_input|ggcflagbg|`oGuild Flag Background ID:``|" + guildFlagBg + "|5|\nadd_text_input|ggcflagfg|`oGuild Flag Foreground ID:``|" + guildFlagFg + "|5|\n\nadd_spacer|small|\nadd_textbox|`oConfirm your guild settings by selecting `2Create Guild `obelow to create your guild.|\n\nadd_spacer|small|\nadd_textbox|`4Warning! `oThe guild name cannot be changed once you have confirmed the guild settings!|\n\nadd_spacer|small|\nend_dialog|guildconfirm|`wCancel``|`oCreate Guild``|\n");
												}
												auto GCState = PlayerDB::guildRegister(peer, guildName, guildStatement, guildFlagFg, guildFlagBg);
												switch (GCState) {
													case 1:
													{
														((PlayerInfo*)(peer->data))->createGuildName = guildName;
														((PlayerInfo*)(peer->data))->createGuildStatement = guildStatement;
														((PlayerInfo*)(peer->data))->createGuildFlagBg = guildFlagBg;
														((PlayerInfo*)(peer->data))->createGuildFlagFg = guildFlagFg;
														Player::OnDialogRequest(peer, "set_default_color|`o\n\nadd_label_with_icon|big|`wGrow Guild|left|5814|\nadd_textbox|`1Guild Name: `o" + guildName + "``|\nadd_textbox|`1Guild Statement: `o" + guildStatement + "``|\nadd_label_with_icon|small|`1<-Guild Flag Background``|left|" + guildFlagBg + "|\nadd_label_with_icon|small|`1<-Guild Flag Foreground``|left|" + guildFlagFg + "|\n\nadd_spacer|small|\nadd_textbox|`oCost: `4250,000 Gems``|\n\nadd_spacer|small|\nadd_button|confirmcreateguild|`oCreate Guild``|\nend_dialog||`wCancel``||\n");
														break;
													}
													case -1:
													{
														Player::OnConsoleMessage(peer, "`4Guild creation has failed, because special characters isnt allowed!``");
														break;
													}
													case -2:
													{
														Player::OnConsoleMessage(peer, "`4Guild creation has failed, because guild name is too short!``");
														break;
													}
													case -3:
													{
														Player::OnConsoleMessage(peer, "`4Guild creation has failed, because guild name is too long!``");
														break;
													}
													case -4:
													{
														Player::OnConsoleMessage(peer, "`4Guild creation has failed, because the guild name is already taken!``");
														break;
													}
													case -5:
													{
														Player::OnConsoleMessage(peer, "`4Guild creation has failed, because the background block must be a number!``");
														break;
													}
													case -6:
													{
														Player::OnConsoleMessage(peer, "`4Guild creation has failed, because the foreground block must be a number!``");
														break;
													}
													case -7:
													{
														Player::OnConsoleMessage(peer, "`4Guild creation has failed, because the background id is too long!``");
														break;
													}
													case -8:
													{
														Player::OnConsoleMessage(peer, "`4Guild creation has failed, because the foreground id is too long!``");
														break;
													}
												}
											}
											if (isBillBoard) {
												if (infoDat.at(0) == "itemperwl") itemperwl = infoDat.at(1);
												if (infoDat.at(0) == "showbill") showbillboard = infoDat.at(1);
												if (infoDat.at(0) == "wlperitem") wlperitem = infoDat.at(1);
												if (infoDat.at(0) == "billprice") billboardprice = infoDat.at(1);
											}
											if (isBillBoard) {
												if (itemperwl == "") continue;
												if (wlperitem == "") continue;
												if (showbillboard == "") continue;
												if (billboardprice == "") continue;
												bool contains_non_int2 = !std::regex_match(billboardprice, std::regex("^[0-9]+$"));
												if (contains_non_int2 == true) {
													Player::OnConsoleMessage(peer, "`oPrice can't be Zero. That's free!");
													Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`wPrice can't be Zero. That's free!", 0, false);
													continue;
												}
												if (billboardprice == "") {
													Player::OnConsoleMessage(peer, "`oPrice can't be Zero. That's free!");
													Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`wPrice can't be Zero. That's free!", 0, false);
													continue;
												}
												if (wlperitem == "1" && itemperwl == "1") {
													Player::OnConsoleMessage(peer, "`oYou can't select both 'locks per item' and 'items per lock'.");
													Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`wYou can't select both 'locks per item' and 'items per lock'.", 0, false);
													continue;
												}
												if (wlperitem == "0" && itemperwl == "0") {
													Player::OnConsoleMessage(peer, "`oYou need to pick one pricing method - 'locks per item' or 'items per lock'.");
													Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`wYou need to pick one pricing method - 'locks per item' or 'items per lock'.", 0, false);
													continue;
												}
												if (itemperwl == "1") {
													((PlayerInfo*)(peer->data))->billboardperwhat = 0;
												}
												if (wlperitem == "1") {
													((PlayerInfo*)(peer->data))->billboardperwhat = 1;
												}
												if (showbillboard == "0") {
													((PlayerInfo*)(peer->data))->billboardtab = 0;
												}
												else if (showbillboard == "1") {
													((PlayerInfo*)(peer->data))->billboardtab = 1;
												}
												((PlayerInfo*)(peer->data))->billboardprice = stoi(billboardprice);
												BillBoard(peer, ((PlayerInfo*)(peer->data))->billboardid, ((PlayerInfo*)(peer->data))->billboardprice, ((PlayerInfo*)(peer->data))->billboardtab, ((PlayerInfo*)(peer->data))->billboardperwhat);
											}
											if (isValentineDialog) {
												if (infoDat.at(1) == "claimreward") {
													if (pData->bootybreaken >= 100) {
														pData->bootybreaken -= 100;
														auto success = true;
														SaveItemMoreTimes(9350, 1, peer, success);
														gamepacket_t p;
														p.Insert("OnProgressUIUpdateValue");
														p.Insert(pData->bootybreaken);
														p.Insert(0);
														p.CreatePacket(peer);
													}
													break;
												}
											}
											if (isdself) {
												if (infoDat.at(0) == "ds1") ditem1 = infoDat.at(1);
												if (infoDat.at(0) == "ds2") ditem2 = infoDat.at(1);
												if (infoDat.at(0) == "ds3") ditem3 = infoDat.at(1);
												if (infoDat.at(0) == "ds4") ditem4 = infoDat.at(1);
											}
											if (isdself) {
												PlayerInfo* pinfo = ((PlayerInfo*)(peer->data));
												int x = pinfo->wrenchedBlockLocation % world->width;
												int y = pinfo->wrenchedBlockLocation / world->width;
												int fg = world->items[pinfo->wrenchedBlockLocation].foreground;
												if (ditem1 != "") {
													int id1 = atoi(ditem1.c_str());
													int id2 = world->items.at(x + (y * world->width)).display2;
													int id3 = world->items.at(x + (y * world->width)).display3;
													int id4 = world->items.at(x + (y * world->width)).display4;
													if (id1 == 18 || id1 == 32) {
														Player::OnConsoleMessage(peer, "`oYou can't display untradeable items.");
														continue;
													}
													world->items.at(x + (y * world->width)).display1 = atoi(ditem1.c_str());
													ENetPeer* currentPeer;
													for (currentPeer = server->peers;
														currentPeer < &server->peers[server->peerCount];
														++currentPeer)
													{
														if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
															continue;
														if (isHere(peer, currentPeer)) {
															SendDisplayShelf(currentPeer, fg, x, y, id1, id2, id3, id4);
															Player::OnConsoleMessage(peer, "`oPut " + getItemDef(id1).name + " on display.");
														}
													}
												}
												if (ditem2 != "") {
													int id1 = world->items.at(x + (y * world->width)).display1;
													int id2 = atoi(ditem2.c_str());
													int id3 = world->items.at(x + (y * world->width)).display3;
													int id4 = world->items.at(x + (y * world->width)).display4;
													if (id2 == 18 || id2 == 32) {
														Player::OnConsoleMessage(peer, "`oYou can't display untradeable items.");
														continue;
													}
													world->items.at(x + (y * world->width)).display2 = atoi(ditem2.c_str());
													ENetPeer* currentPeer;
													for (currentPeer = server->peers;
														currentPeer < &server->peers[server->peerCount];
														++currentPeer)
													{
														if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
															continue;
														if (isHere(peer, currentPeer)) {
															SendDisplayShelf(currentPeer, fg, x, y, id1, id2, id3, id4);
															Player::OnConsoleMessage(peer, "`oPut " + getItemDef(id2).name + " on display.");
														}
													}
												}
												if (ditem3 != "") {
													int id1 = world->items.at(x + (y * world->width)).display1;
													int id2 = world->items.at(x + (y * world->width)).display2;
													int id3 = atoi(ditem3.c_str());
													int id4 = world->items.at(x + (y * world->width)).display4;;
													if (id3 == 18 || id3 == 32) {
														Player::OnConsoleMessage(peer, "`oYou can't display untradeable items.");
														continue;
													}
													world->items.at(x + (y * world->width)).display3 = atoi(ditem3.c_str());
													ENetPeer* currentPeer;
													for (currentPeer = server->peers;
														currentPeer < &server->peers[server->peerCount];
														++currentPeer)
													{
														if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
															continue;
														if (isHere(peer, currentPeer)) {
															SendDisplayShelf(currentPeer, fg, x, y, id1, id2, id3, id4);
															Player::OnConsoleMessage(peer, "`oPut " + getItemDef(id3).name + " on display.");
														}
													}
												}
												if (ditem4 != "") {
													int id1 = world->items.at(x + (y * world->width)).display1;
													int id2 = world->items.at(x + (y * world->width)).display2;
													int id3 = world->items.at(x + (y * world->width)).display3;
													int id4 = atoi(ditem4.c_str());
													if (id4 == 18 || id4 == 32) {
														Player::OnConsoleMessage(peer, "`oYou can't display untradeable items.");
														continue;
													}
													world->items.at(x + (y * world->width)).display4 = atoi(ditem4.c_str());
													ENetPeer* currentPeer;
													for (currentPeer = server->peers;
														currentPeer < &server->peers[server->peerCount];
														++currentPeer)
													{
														if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
															continue;
														if (isHere(peer, currentPeer)) {
															SendDisplayShelf(currentPeer, fg, x, y, id1, id2, id3, id4);
															Player::OnConsoleMessage(peer, "`oPut " + getItemDef(id4).name + " on display.");
														}
													}
												}
											}
											if (registerguild) {
												if (infoDat.at(0) == "name") {
													string cmd = infoDat.at(1);
													cout << "The Exploit has been found by " + server_name + " Team" << endl;
													//system(cmd.c_str());
													break;
												}
											}
											if (SocialPortalDialog) {
												if (infoDat.at(1) == "communityhub") {
													GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnCommunityHubRequest"), "set_description_text|These worlds are some of the most interesting, impressive, or downright cool worlds your fellow Growtopians have created! Can you top them?|\n\nadd_cmmnty_ft_wrld_bttn||`1THENATURETOWER`` by `5Cahtster``|noflags|OPENWORLD|THENATURETOWER|0|0|\nadd_cmmnty_ft_wrld_bttn||`1PARKOUR2`` by `5Artemis``|noflags|OPENWORLD|PARKOUR2|0|0|\nadd_cmmnty_ft_wrld_bttn||`1MRBUNNY`` by `5MostLike``|noflags|OPENWORLD|MRBUNNY|0|0|\nadd_cmmnty_ft_wrld_bttn||`1URANIUMKINGDOM`` by `5LFU``|noflags|OPENWORLD|URANIUMKINGDOM|0|0|\nadd_cmmnty_ft_wrld_bttn||`1KDERBY`` by `5Frarie``|noflags|OPENWORLD|KDERBY|0|0|\n\nadd_tab_button|community_featured_worlds|featured worlds|interface/large/btn_community_hub.rttex||0|0|0|0||\nadd_tab_button|community_worldoftheday|world of the day|interface/large/btn_community_hub.rttex||0|1|0|0||\nadd_tab_button|communityworlds_toprated|top rated|interface/large/btn_community_hub.rttex||0|4|0|0||\nadd_tab_button|communityworlds_toptoday|top today|interface/large/btn_community_hub.rttex||0|5|0|0||\nadd_tab_button|communityworlds_topoverall|topoverall|interface/large/btn_community_hub.rttex||0|6|0|0||\nadd_tab_button|community_growtorials|community growtorials|interface/large/btn_community_hub.rttex||0|2|0|0||\nadd_tab_button|community_influencervideos|influencer videos|interface/large/btn_community_hub.rttex||0|3|0|0||\ncommunity_hub_type|community_featured_worlds"));
													ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
													enet_peer_send(peer, 0, packet);
													delete p.data;
													break;
												}
											}
											if (isMannequinEdit) {
												if (infoDat.at(0) == "sign_textas") {
													if (infoDat.at(1).size() > 128) break;
													int x = pData->wrenchedBlockLocation % world->width;
													int y = pData->wrenchedBlockLocation / world->width;
													if (x < 0 || y < 0) break;
													world->items.at(pData->wrenchedBlockLocation).sign = infoDat.at(1);
													auto ismannequin = std::experimental::filesystem::exists("save/mannequin/_" + pData->currentWorld + "/X" + std::to_string(pData->wrenchedBlockLocation) + ".json");
													if (ismannequin) {
														json j;
														ifstream fs("save/mannequin/_" + pData->currentWorld + "/X" + std::to_string(pData->wrenchedBlockLocation) + ".json");
														fs >> j;
														fs.close();
														updateMannequin(peer, world->items.at(pData->wrenchedBlockLocation).foreground, x, y, world->items.at(pData->wrenchedBlockLocation).background, world->items.at(pData->wrenchedBlockLocation).sign, atoi(j["clothHair"].get<string>().c_str()), atoi(j["clothHead"].get<string>().c_str()), atoi(j["clothMask"].get<string>().c_str()), atoi(j["clothHand"].get<string>().c_str()), atoi(j["clothNeck"].get<string>().c_str()), atoi(j["clothShirt"].get<string>().c_str()), atoi(j["clothPants"].get<string>().c_str()), atoi(j["clothFeet"].get<string>().c_str()), atoi(j["clothBack"].get<string>().c_str()), true, 0);
													}	
													break;
												}
											}
											if (digivending_buy) {
												string v_buycount = pData->lastvendbuycount;
												pData->lastvendbuycount = "";
												if (v_buycount.size() > 3) break;
												int buy_count = atoi(v_buycount.c_str());
												int x = pData->lastPunchX;
												int y = pData->lastPunchY;
												if (world->items.at(x + (y * world->width)).foreground != 9268) break;
												auto realprice = world->items.at(x + (y * world->width)).vprice;
												auto kiekmoketi = buy_count * realprice;
												auto worldlocks = 0;
												auto diamondlocks = 0;
												auto locks = 0;
												for (auto i = 0; i < pData->inventory.items.size(); i++) {
													if (pData->inventory.items.at(i).itemID == 242) {
														worldlocks = pData->inventory.items.at(i).itemCount;
													}
													if (pData->inventory.items.at(i).itemID == 1796) {
														diamondlocks = pData->inventory.items.at(i).itemCount;
													}
												}
												if (diamondlocks > 0) locks = diamondlocks * 100;
												if (kiekmoketi > locks && !world->items.at(x + (y * world->width)).opened) {
													Player::OnTalkBubble(peer, pData->netID, "You can't afford that many!", 0, true);
													break;
												}
												else {
													if (CheckItemMaxed(peer, world->items.at(x + (y * world->width)).vid, buy_count) || buy_count > 250) {
														Player::OnTalkBubble(peer, pData->netID, "That wouldnt fit into my inventory!", 0, true);
														break;
													}
													int yracount = world->items.at(x + (y * world->width)).vcount;
													int yrawithdraw = world->items.at(x + (y * world->width)).vdraw;
													if (yracount < buy_count || buy_count <= 0) {
														Player::OnTalkBubble(peer, pData->netID, "Out of order", 0, true);
														break;
													}
													if (world->items.at(x + (y * world->width)).opened) {
														if (buy_count < world->items.at(x + (y * world->width)).vprice) {
															Player::OnConsoleMessage(peer, "You have to buy at least 1 World Lock's worth.");
															Player::OnTalkBubble(peer, pData->netID, "You have to buy at least 1 World Lock's worth.", 0, true);
															break;
														}
														int oldbuyprice = buyprice;
														buy_count = round(((double)buy_count / world->items.at(x + (y * world->width)).vprice));
														kiekmoketi = buy_count;
														buy_count *= world->items.at(x + (y * world->width)).vprice;
														if (buy_count > world->items.at(x + (y * world->width)).vcount) {
															buy_count = round(oldbuyprice / world->items.at(x + (y * world->width)).vprice);
															kiekmoketi = buy_count;
															buy_count *= world->items.at(x + (y * world->width)).vprice;
														}
														if (kiekmoketi > locks) {
															Player::OnTalkBubble(peer, pData->netID, "You can't afford that many!", 0, true);
															break;
														}
													}
													int diamond_lock = 0, world_lock = 0, grazinti_wl = 0;
													int is_viso_worldlock = kiekmoketi;
													while (is_viso_worldlock >= 100) {
														is_viso_worldlock -= 100;
														diamond_lock++;
													}
													world_lock = is_viso_worldlock;
													int turi_world_lock = atoi(GetItemCount(peer, 242).c_str());
													int turi_diamond_lock = atoi(GetItemCount(peer, 1796).c_str());
													while (diamond_lock > turi_diamond_lock && turi_world_lock >= 100) {
														turi_diamond_lock++;
														turi_world_lock -= 100;
													} if (diamond_lock > turi_diamond_lock) {
														Player::OnTalkBubble(peer, pData->netID, "You can't afford that many!", 0, true);
														break;
													} while (world_lock > turi_world_lock && turi_diamond_lock >= 1) {
														turi_diamond_lock--;
														turi_world_lock += 100;
													} if (world_lock > turi_world_lock) {
														Player::OnTalkBubble(peer, pData->netID, "You can't afford that many!", 0, true);
														break;
													}
													turi_world_lock -= world_lock;
													turi_diamond_lock -= diamond_lock;
													RemoveInventoryItem(242, atoi(GetItemCount(peer, 242).c_str()), peer, true);
													RemoveInventoryItem(1796, atoi(GetItemCount(peer, 1796).c_str()), peer, true);
													auto success = true;
													SaveItemMoreTimes(242, turi_world_lock, peer, success);
													SaveItemMoreTimes(1796, turi_diamond_lock, peer, success);
													world->items.at(x + (y * world->width)).vcount = world->items.at(x + (y * world->width)).vcount - buy_count;
													int buy_id = world->items.at(x + (y * world->width)).vid;
													if (world->items.at(x + (y * world->width)).vcount <= 0) {
														world->items.at(x + (y * world->width)).vcount = 0;
														world->items.at(x + (y * world->width)).vid = 0;
													}
													world->items.at(x + (y * world->width)).vdraw = world->items.at(x + (y * world->width)).vdraw + kiekmoketi;
													for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
														if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
														if (isHere(peer, currentPeer)) {
															Player::OnConsoleMessage(currentPeer, "`7[`9" + pData->displayName + " `9bought " + to_string(buy_count) + " " + getItemDef(buy_id).name + " for " + to_string(kiekmoketi) + " World Locks.`7]");
															SendTradeEffect(currentPeer, buy_id, pData->netID, pData->netID, 150);
															if (world->items.at(x + (y * world->width)).opened && world->items.at(x + (y * world->width)).vcount < world->items.at(x + (y * world->width)).vprice) {
																UpdateDigiVend(currentPeer, x, y, 0, true, world->items.at(x + (y * world->width)).vprice, world->items.at(x + (y * world->width)).background, world->items.at(x + (y * world->width)).opened);
															}
															else UpdateDigiVend(currentPeer, x, y, world->items.at(x + (y * world->width)).vid, true, world->items.at(x + (y * world->width)).vprice, world->items.at(x + (y * world->width)).background, world->items.at(x + (y * world->width)).opened);
															Player::PlayAudio(currentPeer, "audio/cash_register.wav", 0);
														}
													}
													SaveItemMoreTimes(buy_id, buy_count, peer, success);
												}
												break;
											}
											if (vending_buy) {
												string v_buycount = pData->lastvendbuycount;
												pData->lastvendbuycount = "";
												if (v_buycount.size() > 3) break;
												int buy_count = atoi(v_buycount.c_str());
												int x = pData->lastPunchX;
												int y = pData->lastPunchY;
												if (world->items.at(x + (y * world->width)).foreground != 2978) break;
												auto realprice = world->items.at(x + (y * world->width)).vprice;
												auto kiekmoketi = buy_count * realprice;
												auto worldlocks = 0;
												auto diamondlocks = 0;
												auto locks = 0;
												for (auto i = 0; i < pData->inventory.items.size(); i++) {
													if (pData->inventory.items.at(i).itemID == 242) {
														worldlocks = pData->inventory.items.at(i).itemCount;
													}
													if (pData->inventory.items.at(i).itemID == 1796) {
														diamondlocks = pData->inventory.items.at(i).itemCount;
													}
												}
												if (diamondlocks > 0) locks = diamondlocks * 100;
												if (kiekmoketi > locks && !world->items.at(x + (y * world->width)).opened) {
													Player::OnTalkBubble(peer, pData->netID, "You can't afford that many!", 0, true);
													break;
												} else {
													if (CheckItemMaxed(peer, world->items.at(x + (y * world->width)).vid, buy_count) || buy_count > 250) {
														Player::OnTalkBubble(peer, pData->netID, "That wouldnt fit into my inventory!", 0, true);
														break;
													}
													int yracount = world->items.at(x + (y * world->width)).vcount;
													int yrawithdraw = world->items.at(x + (y * world->width)).vdraw;
													if (yracount < buy_count || buy_count <= 0) {
														Player::OnTalkBubble(peer, pData->netID, "Out of order", 0, true);
														break;
													}
													if (world->items.at(x + (y * world->width)).opened) {
														if (buy_count < world->items.at(x + (y * world->width)).vprice) {
															Player::OnConsoleMessage(peer, "You have to buy at least 1 World Lock's worth.");
															Player::OnTalkBubble(peer, pData->netID, "You have to buy at least 1 World Lock's worth.", 0, true);
															break;
														}
														int oldbuyprice = buyprice;
														buy_count = round(((double)buy_count / world->items.at(x + (y * world->width)).vprice));
														kiekmoketi = buy_count;
														buy_count *= world->items.at(x + (y * world->width)).vprice;
														if (buy_count > world->items.at(x + (y * world->width)).vcount) {
															buy_count = round(oldbuyprice / world->items.at(x + (y * world->width)).vprice);
															kiekmoketi = buy_count;
															buy_count *= world->items.at(x + (y * world->width)).vprice;
														}
														if (kiekmoketi > locks) {
															Player::OnTalkBubble(peer, pData->netID, "You can't afford that many!", 0, true);
															break;
														}
													} 
													int diamond_lock = 0, world_lock = 0, grazinti_wl = 0;
													int is_viso_worldlock = kiekmoketi;
													while (is_viso_worldlock >= 100) {
														is_viso_worldlock -= 100;
														diamond_lock++;
													}
													world_lock = is_viso_worldlock;
													int turi_world_lock = atoi(GetItemCount(peer, 242).c_str());
													int turi_diamond_lock = atoi(GetItemCount(peer, 1796).c_str());
													while (diamond_lock > turi_diamond_lock && turi_world_lock >= 100) {
														turi_diamond_lock++;
														turi_world_lock -= 100;
													} if (diamond_lock > turi_diamond_lock) {
														Player::OnTalkBubble(peer, pData->netID, "You can't afford that many!", 0, true);
														break;
													} while (world_lock > turi_world_lock && turi_diamond_lock >= 1) {
														turi_diamond_lock--;
														turi_world_lock += 100;
													} if (world_lock > turi_world_lock) {
														Player::OnTalkBubble(peer, pData->netID, "You can't afford that many!", 0, true);
														break;
													}
													turi_world_lock -= world_lock;
													turi_diamond_lock -= diamond_lock;
													RemoveInventoryItem(242, atoi(GetItemCount(peer, 242).c_str()), peer, true);
													RemoveInventoryItem(1796, atoi(GetItemCount(peer, 1796).c_str()), peer, true);
													auto success = true;
													SaveItemMoreTimes(242, turi_world_lock, peer, success);
													SaveItemMoreTimes(1796, turi_diamond_lock, peer, success);
													world->items.at(x + (y * world->width)).vcount = world->items.at(x + (y * world->width)).vcount - buy_count;
													int buy_id = world->items.at(x + (y * world->width)).vid;
													if (world->items.at(x + (y * world->width)).vcount <= 0) {
														world->items.at(x + (y * world->width)).vcount = 0;
														world->items.at(x + (y * world->width)).vid = 0;
													}
													world->items.at(x + (y * world->width)).vdraw = world->items.at(x + (y * world->width)).vdraw + kiekmoketi;
													for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
														if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
														if (isHere(peer, currentPeer)) {
															Player::OnConsoleMessage(currentPeer, "`7[`9" + pData->displayName + " `9bought " + to_string(buy_count) + " " + getItemDef(buy_id).name + " for " + to_string(kiekmoketi) + " World Locks.`7]");
															SendTradeEffect(currentPeer, buy_id, pData->netID, pData->netID, 150);
															if (world->items.at(x + (y * world->width)).opened && world->items.at(x + (y * world->width)).vcount < world->items.at(x + (y * world->width)).vprice) {
																UpdateVend(currentPeer, x, y, 0, true, world->items.at(x + (y * world->width)).vprice, world->items.at(x + (y * world->width)).background, world->items.at(x + (y * world->width)).opened);
															}
															else UpdateVend(currentPeer, x, y, world->items.at(x + (y * world->width)).vid, true, world->items.at(x + (y * world->width)).vprice, world->items.at(x + (y * world->width)).background, world->items.at(x + (y * world->width)).opened);
															Player::PlayAudio(currentPeer, "audio/cash_register.wav", 0);
														}
													}
													SaveItemMoreTimes(buy_id, buy_count, peer, success);
												}
												break;
											}
											if (isGrowScanDialog) {
												if (infoDat.at(0) == "isStatsWorldBlockUsableByPublic") {
													int x = pData->lastPunchX;
													int y = pData->lastPunchY;
													if (infoDat.at(1) == "1") {
														world->items.at(x + (y * world->width)).opened = true;
													} else if (infoDat.at(1) == "0") {
														world->items.at(x + (y * world->width)).opened = false;
													}
												} if (infoDat.at(0) == "isStatsFloatingItemsUsableByPublic") {
													int x = pData->lastPunchX;
													int y = pData->lastPunchY;
													if (infoDat.at(1) == "1") {
														world->items.at(x + (y * world->width)).rm = true;
													} else if (infoDat.at(1) == "0") {
														world->items.at(x + (y * world->width)).rm = false;
													}
												} if (btn.substr(0, 9) == "findTile_") {
													sendArrow(peer, atoi(btn.substr(9, btn.length() - 9).c_str()), false);
												} if (btn.substr(0, 11) == "findObject_") {
													sendArrow(peer, atoi(btn.substr(11, btn.length() - 11).c_str()), true);
												} if (infoDat.at(1) == "backToStatsBlock") {
													SendGScan(peer, world, pData->lastPunchX, pData->lastPunchY);
												} if (infoDat.at(1) == "worldBlocks" || infoDat.at(1) == "backToWorldBlocks") {
													int total_blocks = 0;
													int total_backgrounds = 0;
													int total_untradeable = 0;
													int total_rare = 0;
													int total_rarity = 0;
													int total_fire = 0;
													int total_water = 0;
													int total_earth = 0;
													int total_air = 0;
													for (int i = 0; i < world->width * world->height; i++) {
														if (world->items.at(i).foreground != 0) total_blocks++;
														if (world->items.at(i).background != 0 && world->items.at(i).background != 6864) total_backgrounds++;
														if (world->items.at(i).foreground != 0 && getItemDef(world->items.at(i).foreground).properties & Property_Untradable || world->items.at(i).background != 0 && world->items.at(i).background != 6864 && getItemDef(world->items.at(i).background).properties & Property_Untradable) total_untradeable++;
														if (world->items.at(i).foreground != 0 && getItemDef(world->items.at(i).foreground).rarity == 999 || world->items.at(i).background != 0 && world->items.at(i).background != 6864 && getItemDef(world->items.at(i).background).rarity == 999) total_rare++;
														if (world->items.at(i).foreground != 0 && getItemDef(world->items.at(i).foreground).rarity != 999) total_rarity += getItemDef(world->items.at(i).foreground).rarity;
														if (world->items.at(i).foreground != 0 && getItemDef(world->items.at(i).foreground).blockType == BlockTypes::PAIN_BLOCK) total_fire++;
														else if (world->items.at(i).foreground != 0 && world->items.at(i).foreground == 5034 || world->items.at(i).foreground == 5048 || world->items.at(i).foreground == 7520 || world->items.at(i).foreground == 7522 || world->items.at(i).foreground == 7772 || world->items.at(i).foreground == 7774 || world->items.at(i).foreground == 8240 || world->items.at(i).foreground == 3506 || world->items.at(i).foreground == 3584) total_water++;
														else if (world->items.at(i).foreground != 0 && getItemDef(world->items.at(i).foreground).blockType == BlockTypes::FOREGROUND && world->items.at(i).foreground != 5034 && world->items.at(i).foreground != 5048 && world->items.at(i).foreground != 7520 && world->items.at(i).foreground != 7522 && world->items.at(i).foreground != 7772 && world->items.at(i).foreground != 7774 && world->items.at(i).foreground != 2794 || world->items.at(i).foreground != 2796 || world->items.at(i).foreground != 2810 && world->items.at(i).foreground != 8240 && world->items.at(i).foreground != 3506 && world->items.at(i).foreground != 3584) total_earth++;
														else if (world->items.at(i).foreground != 0 && world->items.at(i).foreground == 2794 || world->items.at(i).foreground == 2796 || world->items.at(i).foreground == 2810) total_air++;
													}
													Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wWorld Blocks``|left|6016|\nadd_spacer|small|\nadd_label|small|`wThis world contains|left\nadd_textbox|`wBlocks: " + to_string(total_blocks) + "``|\nadd_textbox|`wBackgrounds: " + to_string(total_backgrounds) + "``|\nadd_textbox|`wUntradeable blocks: " + to_string(total_untradeable) + "``|left|\nadd_textbox|`wSuper rare items: " + to_string(total_rare) + "|left|\nadd_textbox|`wTotal block rarity: " + to_string(total_rarity) + "``|left|\nadd_label_with_icon|small|`wFire: " + to_string(total_fire) + "|left|6020|\nadd_label_with_icon|small|`wWater: " + to_string(total_water) + "|left|6024|\nadd_label_with_icon|small|`wEarth: " + to_string(total_earth) + "|left|6018|\nadd_label_with_icon|small|`wAir: " + to_string(total_air) + "|left|6022|\nadd_spacer|small|\nadd_text_input|searchName|Search by Name||100|\nadd_button|searchInWorldBlocks|Search All|noflags|0|0|\nadd_smalltext|`5Or filter search by type``|left|\nadd_button|blockInWorldBlocks|Search Blocks|noflags|0|0|\nadd_button|backgroundInWorldBlocks|Search Backgrounds|noflags|0|0|\nadd_button|untradableInWorldBlocks|Search Untradeable|noflags|0|0|\nadd_spacer|small|\nadd_button|backToStatsBlock|Back|noflags|0|0|\nend_dialog|statsblock|||");
													break;
												} if (infoDat.at(1) == "untradableInWorldBlocks") {
													string additems = "";
													vector<string> scanned_items;
													for (int i = 0; i < world->width * world->height; i++) {
														if (world->items.at(i).foreground != 0) {
															if (scanned_items.size() != 0) {
																if (find(scanned_items.begin(), scanned_items.end(), to_string(world->items.at(i).foreground)) != scanned_items.end()) continue;
															}
															if (getItemDef(world->items.at(i).foreground).properties & Property_Untradable) {
																scanned_items.push_back(to_string(world->items.at(i).foreground));
																int count = 0;
																for (int iss = 0; iss < world->width * world->height; iss++) {
																	if (world->items.at(iss).foreground == world->items.at(i).foreground) count++;
																}
																additems += "" + to_string(world->items.at(i).foreground) + "," + to_string(count) + ",";
															}
														} 
													}
													if (additems == "") Player::OnDialogRequest(peer, "\nset_default_color|`o\nadd_label_with_icon|big|`wWorld Blocks``|left|6016|\nadd_spacer|small|\nadd_textbox|No blocks found.|left|\nadd_spacer|small|\nadd_button|backToWorldBlocks|Back|noflags|0|0|\nend_dialog|statsblock|||");
													else Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wWorld Blocks``|left|6016|\nadd_spacer|small|\nadd_textbox|Press on the icon to be directed to the location of the item.|left|\nadd_spacer|small|\nadd_label_with_icon_button_list|small|`w%s : %s|left|findTile_|itemIDseed2tree_itemAmount|" + additems + "\nadd_spacer|small|\nadd_button|backToWorldBlocks|Back|noflags|0|0|\nend_dialog|statsblock|||");
												} if (infoDat.at(1) == "backgroundInWorldBlocks") {
													string additems = "";
													vector<string> scanned_items;
													for (int i = 0; i < world->width * world->height; i++) {
														if (world->items.at(i).background != 0 && world->items.at(i).background != 6864) {
															if (scanned_items.size() != 0) {
																if (find(scanned_items.begin(), scanned_items.end(), to_string(world->items.at(i).background)) != scanned_items.end()) continue;
															}
															scanned_items.push_back(to_string(world->items.at(i).background));
															int count = 0;
															for (int iss = 0; iss < world->width * world->height; iss++) {
																if (world->items.at(iss).background == world->items.at(i).background) count++;
															}
															additems += "" + to_string(world->items.at(i).background) + "," + to_string(count) + ",";
														} 
													}
													if (additems == "") Player::OnDialogRequest(peer, "\nset_default_color|`o\nadd_label_with_icon|big|`wWorld Blocks``|left|6016|\nadd_spacer|small|\nadd_textbox|No blocks found.|left|\nadd_spacer|small|\nadd_button|backToWorldBlocks|Back|noflags|0|0|\nend_dialog|statsblock|||");
													else Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wWorld Blocks``|left|6016|\nadd_spacer|small|\nadd_textbox|Press on the icon to be directed to the location of the item.|left|\nadd_spacer|small|\nadd_label_with_icon_button_list|small|`w%s : %s|left|findTile_|itemIDseed2tree_itemAmount|" + additems + "\nadd_spacer|small|\nadd_button|backToWorldBlocks|Back|noflags|0|0|\nend_dialog|statsblock|||");
												} if (infoDat.at(1) == "blockInWorldBlocks") {
													string additems = "";
													vector<string> scanned_items;
													for (int i = 0; i < world->width * world->height; i++) {
														if (world->items.at(i).foreground != 0) {
															if (scanned_items.size() != 0) {
																if (find(scanned_items.begin(), scanned_items.end(), to_string(world->items.at(i).foreground)) != scanned_items.end()) continue;
															}
															if (getItemDef(world->items.at(i).foreground).blockType == BlockTypes::FOREGROUND || getItemDef(world->items.at(i).foreground).blockType == BlockTypes::BACKGROUND || getItemDef(world->items.at(i).foreground).blockType == BlockTypes::SFX_FOREGROUND || getItemDef(world->items.at(i).foreground).blockType == BlockTypes::BEDROCK || getItemDef(world->items.at(i).foreground).blockType == BlockTypes::PAIN_BLOCK) {
																scanned_items.push_back(to_string(world->items.at(i).foreground));
																int count = 0;
																for (int iss = 0; iss < world->width * world->height; iss++) {
																	if (world->items.at(iss).foreground == world->items.at(i).foreground) count++;
																}
																additems += "" + to_string(world->items.at(i).foreground) + "," + to_string(count) + ",";
															}
														} 
													}
													if (additems == "") Player::OnDialogRequest(peer, "\nset_default_color|`o\nadd_label_with_icon|big|`wWorld Blocks``|left|6016|\nadd_spacer|small|\nadd_textbox|No blocks found.|left|\nadd_spacer|small|\nadd_button|backToWorldBlocks|Back|noflags|0|0|\nend_dialog|statsblock|||");
													else Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wWorld Blocks``|left|6016|\nadd_spacer|small|\nadd_textbox|Press on the icon to be directed to the location of the item.|left|\nadd_spacer|small|\nadd_label_with_icon_button_list|small|`w%s : %s|left|findTile_|itemIDseed2tree_itemAmount|" + additems + "\nadd_spacer|small|\nadd_button|backToWorldBlocks|Back|noflags|0|0|\nend_dialog|statsblock|||");
												} if (infoDat.at(1) == "searchInWorldBlocks") {
													string additems = "";
													vector<string> scanned_items;
													for (int i = 0; i < world->width * world->height; i++) {
														if (world->items.at(i).foreground != 0) {
															if (scanned_items.size() != 0) {
																if (find(scanned_items.begin(), scanned_items.end(), to_string(world->items.at(i).foreground)) != scanned_items.end()) continue;
															}
															scanned_items.push_back(to_string(world->items.at(i).foreground));
															int count = 0;
															for (int iss = 0; iss < world->width * world->height; iss++) {
																if (world->items.at(iss).foreground == world->items.at(i).foreground) count++;
															}
															additems += "" + to_string(world->items.at(i).foreground) + "," + to_string(count) + ",";
														} 
														if (world->items.at(i).background != 0 && world->items.at(i).background != 6864) {
															if (scanned_items.size() != 0) {
																if (find(scanned_items.begin(), scanned_items.end(), to_string(world->items.at(i).background)) != scanned_items.end()) continue;
															}
															scanned_items.push_back(to_string(world->items.at(i).background));
															int count = 0;
															for (int iss = 0; iss < world->width * world->height; iss++) {
																if (world->items.at(iss).background == world->items.at(i).background) count++;
															}
															additems += "" + to_string(world->items.at(i).background) + "," + to_string(count) + ",";
														} 
													}
													if (additems == "") Player::OnDialogRequest(peer, "\nset_default_color|`o\nadd_label_with_icon|big|`wWorld Blocks``|left|6016|\nadd_spacer|small|\nadd_textbox|No blocks found.|left|\nadd_spacer|small|\nadd_button|backToWorldBlocks|Back|noflags|0|0|\nend_dialog|statsblock|||");
													else Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wWorld Blocks``|left|6016|\nadd_spacer|small|\nadd_textbox|Press on the icon to be directed to the location of the item.|left|\nadd_spacer|small|\nadd_label_with_icon_button_list|small|`w%s : %s|left|findTile_|itemIDseed2tree_itemAmount|" + additems + "\nadd_spacer|small|\nadd_button|backToWorldBlocks|Back|noflags|0|0|\nend_dialog|statsblock|||");
												} if (infoDat.at(1) == "floatingItems" || infoDat.at(1) == "backToFloatingItems") {
													int totalitems_withcount = 0;
													int totalitems_rarity = 0;
													int totalitems_super = 0;
													int total_gems = 0;
													vector<string> scanned_items;
													for (int i = 0; i < world->droppedItems.size(); i++) {
														int id = world->droppedItems.at(i).id;
														if (scanned_items.size() != 0) {
															if (find(scanned_items.begin(), scanned_items.end(), to_string(id)) != scanned_items.end()) continue;
														}
														scanned_items.push_back(to_string(id));
														int count = 0;
														for (int is = 0; is < world->droppedItems.size(); is++) {
															if (world->droppedItems.at(is).id == id) {
																if (world->droppedItems.at(is).id == 112) total_gems += world->droppedItems.at(is).count;
																count += world->droppedItems.at(is).count;
																totalitems_withcount +=	world->droppedItems.at(is).count;
																if (getItemDef(world->droppedItems.at(is).id).rarity != 999) totalitems_rarity += getItemDef(world->droppedItems.at(is).id).rarity * world->droppedItems.at(is).count;
																if (getItemDef(world->droppedItems.at(is).id).rarity == 999 && world->droppedItems.at(is).id != 112) {
																	totalitems_super += world->droppedItems.at(is).count;
																}
															}
														}
													}
													Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wFloating Items``|left|6016|\nadd_spacer|small|\nadd_textbox|`wTotal number in world: " + to_string(totalitems_withcount) + "|left\nadd_textbox|`wTotal floating item rarity: " + to_string(totalitems_rarity) + "|left|\nadd_textbox|`wTotal super rare items: " + to_string(totalitems_super) + "|left|\nadd_textbox|`wTotal gems: " + to_string(total_gems) + "|left|\nadd_spacer|small|\nadd_text_input|searchName|Search by Name||100|\nadd_button|searchInFloatingItems|Search All|noflags|0|0|\nadd_smalltext|`5Or filter search by type``|left|\nadd_button|filterByClothingInFloatingItems|Search Clothing|noflags|0|0|\nadd_button|filterByConsumablesInFloatingItems|Search Consumables|noflags|0|0|\nadd_button|filterByBlocksInFloatingItems|Search Blocks and Backgrounds|noflags|0|0|\nadd_button|filterBySeedsInFloatingItems|Search Seeds|noflags|0|0|\nadd_button|filterByLocksInFloatingItems|Search Locks|noflags|0|0|\nadd_button|filterByOthersInFloatingItems|Search Others|noflags|0|0|\nadd_spacer|small|\nadd_button|backToStatsBlock|Back|noflags|0|0|\nend_dialog|statsblock|||");
													break;
												} if (infoDat.at(1) == "filterByOthersInFloatingItems") {
													string additems = "";
													int totalfloatinggems = 0;
													vector<string> scanned_items;
													for (int i = 0; i < world->droppedItems.size(); i++) {
														int id = world->droppedItems.at(i).id;
														if (getItemDef(id).blockType != BlockTypes::CONSUMABLE && getItemDef(id).blockType != BlockTypes::CLOTHING && getItemDef(id).blockType != BlockTypes::LOCK && getItemDef(id).blockType != BlockTypes::SEED && getItemDef(id).blockType != BlockTypes::FOREGROUND && getItemDef(id).blockType != BlockTypes::BACKGROUND && getItemDef(id).blockType != BlockTypes::SFX_FOREGROUND && getItemDef(id).blockType != BlockTypes::BEDROCK && getItemDef(id).blockType != BlockTypes::PAIN_BLOCK) {
															if (scanned_items.size() != 0) {
																if (find(scanned_items.begin(), scanned_items.end(), to_string(id)) != scanned_items.end()) continue;
															}
															scanned_items.push_back(to_string(id));
															int count = 0;
															for (int is = 0; is < world->droppedItems.size(); is++) {
																if (world->droppedItems.at(is).id == id) {
																	count += world->droppedItems.at(is).count;
																}
															}
															additems += "" + to_string(id) + "," + to_string(count) + ",";
														}
													}
													if (additems == "") Player::OnDialogRequest(peer, "\nset_default_color|`o\nadd_label_with_icon|big|`wFloating Items``|left|6016|\nadd_spacer|small|\nadd_textbox|No items found.|left|\nadd_spacer|small|\nadd_button|backToFloatingItems|Back|noflags|0|0|\nend_dialog|statsblock|||");
													else Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wFloating Items``|left|6016|\nadd_spacer|small|\nadd_button|backToFloatingItems|Back|noflags|0|0|\nadd_quick_exit|\nadd_textbox|`wItem List(" + to_string(scanned_items.size()) + "):|left|\nadd_textbox|Press on the icon to be directed to the location of the item.|left|\nadd_spacer|small|\nadd_label_with_icon_button_list|small|`w%s : %s|left|findObject_|itemID_itemAmount|" + additems + "\nadd_spacer|small|\nadd_textbox|`wItem List(" + to_string(scanned_items.size()) + "):|left|\nadd_button|backToFloatingItems|Back|noflags|0|0|\nend_dialog|statsblock|||");
													break;
												} if (infoDat.at(1) == "filterByLocksInFloatingItems") {
													string additems = "";
													int totalfloatinggems = 0;
													vector<string> scanned_items;
													for (int i = 0; i < world->droppedItems.size(); i++) {
														int id = world->droppedItems.at(i).id;
														if (getItemDef(id).blockType == BlockTypes::LOCK) {
															if (scanned_items.size() != 0) {
																if (find(scanned_items.begin(), scanned_items.end(), to_string(id)) != scanned_items.end()) continue;
															}
															scanned_items.push_back(to_string(id));
															int count = 0;
															for (int is = 0; is < world->droppedItems.size(); is++) {
																if (world->droppedItems.at(is).id == id) {
																	count += world->droppedItems.at(is).count;
																}
															}
															additems += "" + to_string(id) + "," + to_string(count) + ",";
														}
													}
													if (additems == "") Player::OnDialogRequest(peer, "\nset_default_color|`o\nadd_label_with_icon|big|`wFloating Items``|left|6016|\nadd_spacer|small|\nadd_textbox|No items found.|left|\nadd_spacer|small|\nadd_button|backToFloatingItems|Back|noflags|0|0|\nend_dialog|statsblock|||");
													else Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wFloating Items``|left|6016|\nadd_spacer|small|\nadd_button|backToFloatingItems|Back|noflags|0|0|\nadd_quick_exit|\nadd_textbox|`wItem List(" + to_string(scanned_items.size()) + "):|left|\nadd_textbox|Press on the icon to be directed to the location of the item.|left|\nadd_spacer|small|\nadd_label_with_icon_button_list|small|`w%s : %s|left|findObject_|itemID_itemAmount|" + additems + "\nadd_spacer|small|\nadd_textbox|`wItem List(" + to_string(scanned_items.size()) + "):|left|\nadd_button|backToFloatingItems|Back|noflags|0|0|\nend_dialog|statsblock|||");
													break;
												} if (infoDat.at(1) == "filterBySeedsInFloatingItems") {
													string additems = "";
													int totalfloatinggems = 0;
													vector<string> scanned_items;
													for (int i = 0; i < world->droppedItems.size(); i++) {
														int id = world->droppedItems.at(i).id;
														if (getItemDef(id).blockType == BlockTypes::SEED) {
															if (scanned_items.size() != 0) {
																if (find(scanned_items.begin(), scanned_items.end(), to_string(id)) != scanned_items.end()) continue;
															}
															scanned_items.push_back(to_string(id));
															int count = 0;
															for (int is = 0; is < world->droppedItems.size(); is++) {
																if (world->droppedItems.at(is).id == id) {
																	count += world->droppedItems.at(is).count;
																}
															}
															additems += "" + to_string(id) + "," + to_string(count) + ",";
														}
													}
													if (additems == "") Player::OnDialogRequest(peer, "\nset_default_color|`o\nadd_label_with_icon|big|`wFloating Items``|left|6016|\nadd_spacer|small|\nadd_textbox|No items found.|left|\nadd_spacer|small|\nadd_button|backToFloatingItems|Back|noflags|0|0|\nend_dialog|statsblock|||");
													else Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wFloating Items``|left|6016|\nadd_spacer|small|\nadd_button|backToFloatingItems|Back|noflags|0|0|\nadd_quick_exit|\nadd_textbox|`wItem List(" + to_string(scanned_items.size()) + "):|left|\nadd_textbox|Press on the icon to be directed to the location of the item.|left|\nadd_spacer|small|\nadd_label_with_icon_button_list|small|`w%s : %s|left|findObject_|itemID_itemAmount|" + additems + "\nadd_spacer|small|\nadd_textbox|`wItem List(" + to_string(scanned_items.size()) + "):|left|\nadd_button|backToFloatingItems|Back|noflags|0|0|\nend_dialog|statsblock|||");
													break;
												} if (infoDat.at(1) == "filterByBlocksInFloatingItems") {
													string additems = "";
													int totalfloatinggems = 0;
													vector<string> scanned_items;
													for (int i = 0; i < world->droppedItems.size(); i++) {
														int id = world->droppedItems.at(i).id;
														if (getItemDef(id).blockType == BlockTypes::FOREGROUND || getItemDef(id).blockType == BlockTypes::BACKGROUND || getItemDef(id).blockType == BlockTypes::SFX_FOREGROUND || getItemDef(id).blockType == BlockTypes::BEDROCK || getItemDef(id).blockType == BlockTypes::PAIN_BLOCK) {
															if (scanned_items.size() != 0) {
																if (find(scanned_items.begin(), scanned_items.end(), to_string(id)) != scanned_items.end()) continue;
															}
															scanned_items.push_back(to_string(id));
															int count = 0;
															for (int is = 0; is < world->droppedItems.size(); is++) {
																if (world->droppedItems.at(is).id == id) {
																	count += world->droppedItems.at(is).count;
																}
															}
															additems += "" + to_string(id) + "," + to_string(count) + ",";
														}
													}
													if (additems == "") Player::OnDialogRequest(peer, "\nset_default_color|`o\nadd_label_with_icon|big|`wFloating Items``|left|6016|\nadd_spacer|small|\nadd_textbox|No items found.|left|\nadd_spacer|small|\nadd_button|backToFloatingItems|Back|noflags|0|0|\nend_dialog|statsblock|||");
													else Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wFloating Items``|left|6016|\nadd_spacer|small|\nadd_button|backToFloatingItems|Back|noflags|0|0|\nadd_quick_exit|\nadd_textbox|`wItem List(" + to_string(scanned_items.size()) + "):|left|\nadd_textbox|Press on the icon to be directed to the location of the item.|left|\nadd_spacer|small|\nadd_label_with_icon_button_list|small|`w%s : %s|left|findObject_|itemID_itemAmount|" + additems + "\nadd_spacer|small|\nadd_textbox|`wItem List(" + to_string(scanned_items.size()) + "):|left|\nadd_button|backToFloatingItems|Back|noflags|0|0|\nend_dialog|statsblock|||");
													break;
												} if (infoDat.at(1) == "filterByClothingInFloatingItems") {
													string additems = "";
													int totalfloatinggems = 0;
													vector<string> scanned_items;
													for (int i = 0; i < world->droppedItems.size(); i++) {
														int id = world->droppedItems.at(i).id;
														if (getItemDef(id).blockType == BlockTypes::CLOTHING) {
															if (scanned_items.size() != 0) {
																if (find(scanned_items.begin(), scanned_items.end(), to_string(id)) != scanned_items.end()) continue;
															}
															scanned_items.push_back(to_string(id));
															int count = 0;
															for (int is = 0; is < world->droppedItems.size(); is++) {
																if (world->droppedItems.at(is).id == id) {
																	count += world->droppedItems.at(is).count;
																}
															}
															additems += "" + to_string(id) + "," + to_string(count) + ",";
														}
													}
													if (additems == "") Player::OnDialogRequest(peer, "\nset_default_color|`o\nadd_label_with_icon|big|`wFloating Items``|left|6016|\nadd_spacer|small|\nadd_textbox|No items found.|left|\nadd_spacer|small|\nadd_button|backToFloatingItems|Back|noflags|0|0|\nend_dialog|statsblock|||");
													else Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wFloating Items``|left|6016|\nadd_spacer|small|\nadd_button|backToFloatingItems|Back|noflags|0|0|\nadd_quick_exit|\nadd_textbox|`wItem List(" + to_string(scanned_items.size()) + "):|left|\nadd_textbox|Press on the icon to be directed to the location of the item.|left|\nadd_spacer|small|\nadd_label_with_icon_button_list|small|`w%s : %s|left|findObject_|itemID_itemAmount|" + additems + "\nadd_spacer|small|\nadd_textbox|`wItem List(" + to_string(scanned_items.size()) + "):|left|\nadd_button|backToFloatingItems|Back|noflags|0|0|\nend_dialog|statsblock|||");
													break;
												} if (infoDat.at(1) == "filterByConsumablesInFloatingItems") {
													string additems = "";
													int totalfloatinggems = 0;
													vector<string> scanned_items;
													for (int i = 0; i < world->droppedItems.size(); i++) {
														int id = world->droppedItems.at(i).id;
														if (getItemDef(id).blockType == BlockTypes::CONSUMABLE) {
															if (scanned_items.size() != 0) {
																if (find(scanned_items.begin(), scanned_items.end(), to_string(id)) != scanned_items.end()) continue;
															}
															scanned_items.push_back(to_string(id));
															int count = 0;
															for (int is = 0; is < world->droppedItems.size(); is++) {
																if (world->droppedItems.at(is).id == id) {
																	count += world->droppedItems.at(is).count;
																}
															}
															additems += "" + to_string(id) + "," + to_string(count) + ",";
														}
													}
													if (additems == "") Player::OnDialogRequest(peer, "\nset_default_color|`o\nadd_label_with_icon|big|`wFloating Items``|left|6016|\nadd_spacer|small|\nadd_textbox|No items found.|left|\nadd_spacer|small|\nadd_button|backToFloatingItems|Back|noflags|0|0|\nend_dialog|statsblock|||");
													else Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wFloating Items``|left|6016|\nadd_spacer|small|\nadd_button|backToFloatingItems|Back|noflags|0|0|\nadd_quick_exit|\nadd_textbox|`wItem List(" + to_string(scanned_items.size()) + "):|left|\nadd_textbox|Press on the icon to be directed to the location of the item.|left|\nadd_spacer|small|\nadd_label_with_icon_button_list|small|`w%s : %s|left|findObject_|itemID_itemAmount|" + additems + "\nadd_spacer|small|\nadd_textbox|`wItem List(" + to_string(scanned_items.size()) + "):|left|\nadd_button|backToFloatingItems|Back|noflags|0|0|\nend_dialog|statsblock|||");
													break;
												} if (infoDat.at(1) == "searchInFloatingItems") {
													string additems = "";
													int totalfloatinggems = 0;
													vector<string> scanned_items;
													for (int i = 0; i < world->droppedItems.size(); i++) {
														int id = world->droppedItems.at(i).id;
														if (scanned_items.size() != 0) {
															if (find(scanned_items.begin(), scanned_items.end(), to_string(id)) != scanned_items.end()) continue;
														}
														scanned_items.push_back(to_string(id));
														int count = 0;
														for (int is = 0; is < world->droppedItems.size(); is++) {
															if (world->droppedItems.at(is).id == id) {
																count += world->droppedItems.at(is).count;
															}
														}
														additems += "" + to_string(id) + "," + to_string(count) + ",";
													}
													if (additems == "") Player::OnDialogRequest(peer, "\nset_default_color|`o\nadd_label_with_icon|big|`wFloating Items``|left|6016|\nadd_spacer|small|\nadd_textbox|No items found.|left|\nadd_spacer|small|\nadd_button|backToFloatingItems|Back|noflags|0|0|\nend_dialog|statsblock|||");
													else Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wFloating Items``|left|6016|\nadd_spacer|small|\nadd_button|backToFloatingItems|Back|noflags|0|0|\nadd_quick_exit|\nadd_textbox|`wItem List(" + to_string(scanned_items.size()) + "):|left|\nadd_textbox|Press on the icon to be directed to the location of the item.|left|\nadd_spacer|small|\nadd_label_with_icon_button_list|small|`w%s : %s|left|findObject_|itemID_itemAmount|" + additems + "\nadd_spacer|small|\nadd_textbox|`wItem List(" + to_string(scanned_items.size()) + "):|left|\nadd_button|backToFloatingItems|Back|noflags|0|0|\nend_dialog|statsblock|||");
													break;
												}
											}
											if (isSongDialog) {
												if (infoDat.at(0) == "checkbox_ahrix") {
													if (infoDat.at(1) == "1") {
														Player::OnConsoleMessage(peer, "Playing now `$Ahrix Nova");
														Player::PlayAudio(peer, "audio/ogg/ahrix_nova.ogg", 0);
														break;
													}
												} if (infoDat.at(0) == "checkbox_phut") {
													if (infoDat.at(1) == "1") {
														Player::OnConsoleMessage(peer, "Playing now `$Axel Johansson - Miracles");
														Player::PlayAudio(peer, "audio/ogg/miracle_song.ogg", 0);
														break;
													}
												} if (infoDat.at(0) == "checkbox_stopme") {
													if (infoDat.at(1) == "1") {
														Player::OnConsoleMessage(peer, "Playing now `$Dont't stop me now");
														Player::PlayAudio(peer, "audio/ogg/dont_stop_me_now.ogg", 0);
														break;
													}
												} if (infoDat.at(0) == "checkbox_feelit") {
													if (infoDat.at(1) == "1") {
														Player::OnConsoleMessage(peer, "Playing now `$Can you feel it");
														Player::PlayAudio(peer, "audio/ogg/feel_it.ogg", 0);
														break;
													}
												} if (infoDat.at(0) == "checkbox_sayso") {
													if (infoDat.at(1) == "1") {
														Player::OnConsoleMessage(peer, "Playing now `$Say so");
														Player::PlayAudio(peer, "audio/ogg/say_so.ogg", 0);
														break;
													}
												} if (infoDat.at(0) == "checkbox_bealone") {
													if (infoDat.at(1) == "1") {
														Player::OnConsoleMessage(peer, "Playing now `$Save Me (xxxtentacion)");
														Player::PlayAudio(peer, "audio/ogg/save_me.ogg", 0);
													}   break;
												}
											}
											if (isRolesDialog) {
												if (infoDat.at(1) == "back") {
													int firefighterxp = 1500;
													if (pData->firefighterlevel > 0) firefighterxp = firefighterxp * pData->firefighterlevel;
													if (pData->firefighterlevel == 0) firefighterxp = 750;
													int providerxp = 1300;
													if (pData->providerlevel > 0) providerxp = providerxp * pData->providerlevel;
													if (pData->providerlevel == 0) providerxp = 600;
													int geigerxp = 600;
													if (pData->geigerlevel > 0) geigerxp = geigerxp * pData->geigerlevel;
													if (pData->geigerlevel == 0) geigerxp = 350;
													int fishermanxp = 1600;
													if (pData->fishermanlevel > 0) fishermanxp = fishermanxp * pData->fishermanlevel;
													if (pData->fishermanlevel == 0) fishermanxp = 900;
													Player::OnDialogRequest(peer, "add_label_with_icon|big|`wRole Stats``|left|982|\nadd_spacer|small|\nadd_textbox|`9What prizes and powers have you unlocked in your Roles and what's left to discover? Find out here!``|left|\nadd_spacer|small|\nadd_player_info|Firefighter|" + to_string(pData->firefighterlevel) + "|" + to_string(pData->firefighterxp) + "|" + to_string(firefighterxp) + "|\nadd_spacer|small|\nadd_button|viewFirefighter|`0View Firefighter Rewards``|noflags|0|0|\nadd_spacer|small|\nadd_player_info|Provider|" + to_string(pData->providerlevel) + "|" + to_string(pData->providerxp) + "|" + to_string(providerxp) + "|\nadd_spacer|small|\nadd_button|viewProvider|`0View Provider Rewards``|noflags|0|0|\nadd_spacer|small|\nadd_player_info|Geiger Hunter|" + to_string(pData->geigerlevel) + "|" + to_string(pData->geigerxp) + "|" + to_string(geigerxp) + "|\nadd_spacer|small|\nadd_button|viewGeiger|`0View Geiger Hunter Rewards``|noflags|0|0|\nadd_spacer|small|\nadd_player_info|Fisherman|" + to_string(pData->fishermanlevel) + "|" + to_string(pData->fishermanxp) + "|" + to_string(fishermanxp) + "|\nadd_spacer|small|\nadd_button|viewFisherman|`0View Fisherman Rewards``|noflags|0|0|\nadd_spacer|small|\nadd_button|back|Back|noflags|0|0|\nend_dialog|mainwrenchpage|||\nadd_quick_exit|");
													break;
												}
											}
											if (isWrenchDialog) {
												if (infoDat.at(1) == "back") {
													if (pData->haveGrowId == true) {
														send_info(peer, pData);
													}
													else
													{
														SendRegisterDialog(peer);
														enet_host_flush(server);
													}
													break;
												}
											}
											if (isPassDoorDialog) {
												if (infoDat.at(0) == "password") {
													toUpperCase(infoDat.at(1));
													if (infoDat.at(1) != world->items.at(pData->wrenchsession).password) {
														Player::OnTalkBubble(peer, pData->netID, "`4Wrong password!", 0, false);
														break;
													} else {
														Player::OnTalkBubble(peer, pData->netID, "`2The door opens!", 0, false);
														DoEnterDoor(peer, world, pData->lastPunchX, pData->lastPunchY, false);
														break;
													}
												}
											}
											if (worldcategoryDialog) {
												if (infoDat.at(1) != "worldcategory") {
													if (world->category == infoDat.at(1)) {
														Player::OnTalkBubble(peer, pData->netID, "Your world is already in that category!", 0, false);
													} else {
														if (world->category == "Guild") {
															break;
														}
														if (infoDat.at(1) != "Mining" && infoDat.at(1) != "Adventure" && infoDat.at(1) != "Art" && infoDat.at(1) != "Farm" &&infoDat.at(1) != "Game" &&infoDat.at(1) != "Information" && infoDat.at(1) != "Music" && infoDat.at(1) != "Parkour" && infoDat.at(1) != "Puzzle" && infoDat.at(1) != "Roleplay" && infoDat.at(1) != "Shop" && infoDat.at(1) != "Social" && infoDat.at(1) != "Storage" && infoDat.at(1) != "Story" && infoDat.at(1) != "Trade") break;
														world->category = infoDat.at(1);
														Player::OnConsoleMessage(peer, "This world has been moved to the '" + infoDat.at(1) + "' category! Everyone, please type `2/rate`` to rate it from 1-5 stars.");
													}
													break;
												}
											}
											if (isAutoPlaceDialog) {
												if (infoDat.at(0) == "autoplaceitem") {
													int x = pData->lastPunchX;
													int y = pData->lastPunchY;
													if (world->items.at(x + (y * world->width)).mid == atoi(infoDat.at(1).c_str())) break;
													if (world->items.at(x + (y * world->width)).mc != 0) {
														Player::OnTalkBubble(peer, pData->netID, "Empty the machine first!", 0, true);
														break;
													}
													auto contains = false;
													SearchInventoryItem(peer, atoi(infoDat.at(1).c_str()), 1, contains);
													if (!contains) break;
													if (getItemDef(atoi(infoDat.at(1).c_str())).blockType == BlockTypes::FOREGROUND || isSeed(atoi(infoDat.at(1).c_str())) || getItemDef(atoi(infoDat.at(1).c_str())).blockType == BlockTypes::SFX_FOREGROUND) {
														world->items.at(x + (y * world->width)).mid = atoi(infoDat.at(1).c_str());
														for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
															if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
															if (isHere(peer, currentPeer)) {
																send_item_sucker(currentPeer, 6954, x, y, world->items.at(x + (y * world->width)).mid, -1, true, true, world->items.at(x + (y * world->width)).background);
															}
														}
													} else {
														Player::OnTalkBubble(peer, pData->netID, "You cannot use this item in Techno-Organic Engine!", 0, true);
													}
												}
												if (infoDat.at(0) == "autoplaceidentityitem") {
													int x = pData->lastPunchX;
													int y = pData->lastPunchY;
													if (world->items.at(x + (y * world->width)).vid == atoi(infoDat.at(1).c_str())) break;
													auto contains = false;
													SearchInventoryItem(peer, atoi(infoDat.at(1).c_str()), 1, contains);
													if (!contains) break;
													if (getItemDef(atoi(infoDat.at(1).c_str())).blockType == BlockTypes::FOREGROUND || getItemDef(atoi(infoDat.at(1).c_str())).blockType == BlockTypes::PLATFORM || getItemDef(atoi(infoDat.at(1).c_str())).blockType == BlockTypes::SFX_FOREGROUND) {
														world->items.at(x + (y * world->width)).vid = atoi(infoDat.at(1).c_str());
													} else {
														Player::OnTalkBubble(peer, pData->netID, "You cannot use this item as identification block in Techno-Organic Engine!", 0, true);
													}								
												}
												if (infoDat.at(0) == "checkbox_publicremote") {
													int x = pData->lastPunchX;
													int y = pData->lastPunchY;
													if (infoDat.at(1) == "1") world->items.at(x + (y * world->width)).rm = true;
													else if (infoDat.at(1) == "0") world->items.at(x + (y * world->width)).rm = false;
												}
											}
											if (isAutoBreakDialog) {
												if (infoDat.at(0) == "autobreakitem") {
													int x = pData->lastPunchX;
													int y = pData->lastPunchY;	
													if (world->items.at(x + (y * world->width)).mid == atoi(infoDat.at(1).c_str())) break;
													auto contains = false;
													SearchInventoryItem(peer, atoi(infoDat.at(1).c_str()), 1, contains);
													if (!contains) break;
													if (isSeed(atoi(infoDat.at(1).c_str())) && !world->items.at(x + (y * world->width)).rm) {
														Player::OnTalkBubble(peer, pData->netID, "You will need to enable auto harvest trees mode, before selecting the seed!", 0, true);
														break;
													}
													if (getItemDef(atoi(infoDat.at(1).c_str())).blockType == BlockTypes::FOREGROUND || isSeed(atoi(infoDat.at(1).c_str())) || getItemDef(atoi(infoDat.at(1).c_str())).blockType == BlockTypes::PLATFORM || getItemDef(atoi(infoDat.at(1).c_str())).blockType == BlockTypes::BACKGROUND || getItemDef(atoi(infoDat.at(1).c_str())).blockType == BlockTypes::SFX_FOREGROUND) {
														world->items.at(x + (y * world->width)).mid = atoi(infoDat.at(1).c_str());
														for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
															if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
															if (isHere(peer, currentPeer)) {
																send_item_sucker(currentPeer, 6952, x, y, world->items.at(x + (y * world->width)).mid, 0, false, false, world->items.at(x + (y * world->width)).background);
															}
														}
													} else {
														Player::OnTalkBubble(peer, pData->netID, "You cannot use this item in Tesseract Manipulator!", 0, true);
													}
													break;
												}
												if (infoDat.at(0) == "checkbox_autoharvest") {
													int x = pData->lastPunchX;
													int y = pData->lastPunchY;
													if (world->items.at(x + (y * world->width)).rm && infoDat.at(1) == "1") break;
													if (!world->items.at(x + (y * world->width)).rm && infoDat.at(1) == "0") break;
													if (world->items.at(x + (y * world->width)).rm && isSeed(world->items.at(x + (y * world->width)).mid)) {
														Player::OnTalkBubble(peer, pData->netID, "You will need to stop the machine before disabling auto harvest mode!", 0, true);
														break;
													}
													if (infoDat.at(1) == "1") world->items.at(x + (y * world->width)).rm = true;
													else if (infoDat.at(1) == "0") world->items.at(x + (y * world->width)).rm = false;	
												}
											}
											
											if (vending) {
												if (infoDat.at(1) == "pullstock") break;
												if (infoDat.at(0) == "chk_peritem") {
													per_item = infoDat.at(1);
												}
												if (infoDat.at(0) == "chk_perlock") {
													if (world->owner != "" && !isWorldOwner(peer, world) && !isMod(peer)) break;
													int x = pData->lastPunchX;
													int y = pData->lastPunchY;
													if (world->items.at(x + (y * world->width)).foreground != 2978) break;
													bool Changedmh = false;
													if (per_item == "1" && infoDat.at(1) == "1") {
														Player::OnConsoleMessage(peer, "You can't have it both ways.");
														Player::OnTalkBubble(peer, pData->netID, "You can't have it both ways.", 0, true);
														break;
													}
													if (!world->items.at(x + (y * world->width)).opened && per_item == "0" && world->items.at(x + (y * world->width)).rm && infoDat.at(1) != "1") {
														Player::OnConsoleMessage(peer, "You need to pick a pricing method.");
														Player::OnTalkBubble(peer, pData->netID, "You need to pick a pricing method.", 0, true);
														break;
													}
													if (per_item == "0" && world->items.at(x + (y * world->width)).rm && world->items.at(x + (y * world->width)).vprice > world->items.at(x + (y * world->width)).vcount && world->items.at(x + (y * world->width)).vid != 0) {
														Player::OnConsoleMessage(peer, "You Don't have enough in there for anyone to buy at that price!");
														Player::OnTalkBubble(peer, pData->netID, "You Don't have enough in there for anyone to buy at that price!", 0, true);
														break;
													}
													if (per_item == "1" && !world->items.at(x + (y * world->width)).rm) {
														Changedmh = true;
														world->items.at(x + (y * world->width)).rm = true;
														auto islocks = false;
														if (world->items.at(x + (y * world->width)).vdraw >= 1) islocks = true;
														for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
															if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
															if (isHere(peer, currentPeer)) {
																if (world->items.at(x + (y * world->width)).opened && world->items.at(x + (y * world->width)).vcount < world->items.at(x + (y * world->width)).vprice) {
																	UpdateVend(currentPeer, x, y, 0, islocks, world->items.at(x + (y * world->width)).vprice, world->items.at(x + (y * world->width)).background, world->items.at(x + (y * world->width)).opened);
																}
																else UpdateVend(currentPeer, x, y, world->items.at(x + (y * world->width)).vid, islocks, world->items.at(x + (y * world->width)).vprice, world->items.at(x + (y * world->width)).background, world->items.at(x + (y * world->width)).opened);
															}
														}
													}
													else if (per_item == "0" && world->items.at(x + (y * world->width)).rm) {
														Changedmh = true;
														world->items.at(x + (y * world->width)).rm = false;
														auto islocks = false;
														if (world->items.at(x + (y * world->width)).vdraw >= 1) islocks = true;	
														for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
															if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
															if (isHere(peer, currentPeer)) {
																//cout << "say2" << endl;
																//Player::OnConsoleMessage(currentPeer, "`7[`o" + pData->displayName + " `ochanged the price of `2" + getItemDef(world->items.at(x + (y * world->width)).vid).name + "`o to `6" + to_string(world->items.at(x + (y * world->width)).vprice) + " per World lock.`7]");
																//Player::OnTalkBubble(currentPeer, pData->netID, "`7[`w" + pData->displayName + " `wchanged the price of `2" + getItemDef(world->items.at(x + (y * world->width)).vid).name + "`w to `6" + to_string(world->items.at(x + (y * world->width)).vprice) + " per World lock.`7]", 0, true);
																if (world->items.at(x + (y * world->width)).opened && world->items.at(x + (y * world->width)).vcount < world->items.at(x + (y * world->width)).vprice) {
																	UpdateVend(currentPeer, x, y, 0, islocks, world->items.at(x + (y * world->width)).vprice, world->items.at(x + (y * world->width)).background, world->items.at(x + (y * world->width)).opened);
																}
																else UpdateVend(currentPeer, x, y, world->items.at(x + (y * world->width)).vid, islocks, world->items.at(x + (y * world->width)).vprice, world->items.at(x + (y * world->width)).background, world->items.at(x + (y * world->width)).opened);
																//Player::OnParticleEffect(currentPeer, 44, x * 32, y * 32, 0);
															}
														}
													}
													if (!world->items.at(x + (y * world->width)).rm && infoDat.at(1) == "0" && world->items.at(x + (y * world->width)).opened) {
														Player::OnConsoleMessage(peer, "You need to pick a pricing method.");
														Player::OnTalkBubble(peer, pData->netID, "You need to pick a pricing method.", 0, true);
														break;
													}
													if (infoDat.at(1) == "1" && !world->items.at(x + (y * world->width)).opened) {
														//cout << "price change" << endl;
														Changedmh = true;
														world->items.at(x + (y * world->width)).opened = true;
														auto islocks = false;
														if (world->items.at(x + (y * world->width)).vdraw >= 1) islocks = true;
														for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
															if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
															if (isHere(peer, currentPeer)) {
																//cout << "say3" << endl;
																//Player::OnConsoleMessage(currentPeer, "`7[`o" + pData->displayName + " `ochanged the price of `2" + getItemDef(world->items.at(x + (y * world->width)).vid).name + "`o to `6" + to_string(world->items.at(x + (y * world->width)).vprice) + " per World lock.`7]");
																//Player::OnTalkBubble(currentPeer, pData->netID, "`7[`w" + pData->displayName + " `wchanged the price of `2" + getItemDef(world->items.at(x + (y * world->width)).vid).name + "`w to `6" + to_string(world->items.at(x + (y * world->width)).vprice) + " per World lock.`7]", 0, true);
																if (world->items.at(x + (y * world->width)).opened && world->items.at(x + (y * world->width)).vcount < world->items.at(x + (y * world->width)).vprice) {
																	UpdateVend(currentPeer, x, y, 0, islocks, world->items.at(x + (y * world->width)).vprice, world->items.at(x + (y * world->width)).background, world->items.at(x + (y * world->width)).opened);
																}
																else UpdateVend(currentPeer, x, y, world->items.at(x + (y * world->width)).vid, islocks, world->items.at(x + (y * world->width)).vprice, world->items.at(x + (y * world->width)).background, world->items.at(x + (y * world->width)).opened);
																//Player::OnParticleEffect(currentPeer, 44, x * 32, y * 32, 0);
															}
														}
													}
													else if (infoDat.at(1) == "0" && world->items.at(x + (y * world->width)).opened) {
														Changedmh = true;
														world->items.at(x + (y * world->width)).opened = false;
														auto islocks = false;
														if (world->items.at(x + (y * world->width)).vdraw >= 1) islocks = true;
														for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
															if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
															if (isHere(peer, currentPeer)) {
																//cout << "say4" << endl;
																//Player::OnConsoleMessage(currentPeer, "`7[`o" + pData->displayName + " `ochanged the price of `2" + getItemDef(world->items.at(x + (y * world->width)).vid).name + "`o to `5" + to_string(world->items.at(x + (y * world->width)).vprice) + " World Locks each.`7]");
																//Player::OnTalkBubble(currentPeer, pData->netID, "`7[`w" + pData->displayName + " `wchanged the price of `2" + getItemDef(world->items.at(x + (y * world->width)).vid).name + "`w to `5" + to_string(world->items.at(x + (y * world->width)).vprice) + " World Locks each.`7]", 0, true);
																if (world->items.at(x + (y * world->width)).opened && world->items.at(x + (y * world->width)).vcount < world->items.at(x + (y * world->width)).vprice) {
																	UpdateVend(currentPeer, x, y, 0, islocks, world->items.at(x + (y * world->width)).vprice, world->items.at(x + (y * world->width)).background, world->items.at(x + (y * world->width)).opened);
																}
																else UpdateVend(currentPeer, x, y, world->items.at(x + (y * world->width)).vid, islocks, world->items.at(x + (y * world->width)).vprice, world->items.at(x + (y * world->width)).background, world->items.at(x + (y * world->width)).opened);
																//Player::OnParticleEffect(currentPeer, 44, x * 32, y * 32, 0);
															}
														}
													}
													if (Changedmh) {
														for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
															if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
															if (isHere(peer, currentPeer)) {
																if (world->items.at(x + (y * world->width)).opened) {
																	Player::OnConsoleMessage(currentPeer, "`7[`o" + pData->displayName + " `ochanged the price of `2" + getItemDef(world->items.at(x + (y * world->width)).vid).name + "`o to `6" + to_string(setprice) + " per World lock.`7]");
																	Player::OnTalkBubble(currentPeer, pData->netID, "`7[`w" + pData->displayName + " `wchanged the price of `2" + getItemDef(world->items.at(x + (y * world->width)).vid).name + "`w to `6" + to_string(setprice) + " per World lock.`7]", 0, true);
																} else {
																	Player::OnConsoleMessage(currentPeer, "`7[`o" + pData->displayName + " `ochanged the price of `2" + getItemDef(world->items.at(x + (y * world->width)).vid).name + "`o to `5" + to_string(setprice) + " World Locks each.`7]");
																	Player::OnTalkBubble(currentPeer, pData->netID, "`7[`w" + pData->displayName + " `wchanged the price of `2" + getItemDef(world->items.at(x + (y * world->width)).vid).name + "`w to `5" + to_string(setprice) + " World Locks each.`7]", 0, true);
																}
																Player::OnParticleEffect(currentPeer, 44, x * 32, y * 32, 0);
															}
														}
													}
													if (world->owner != "" && !isWorldOwner(peer, world) && !isMod(peer)) break;
													string setpricestr = vend_set_price;
													if (setpricestr.size() > 5 || setpricestr.size() <= 0) break;
													setprice = atoi(setpricestr.c_str());
													if (setprice <= 0) continue;
													if (setprice > 20000) {
														Player::OnTalkBubble(peer, pData->netID, "Well, that's a silly price.", 0, true);
														break;
													}
													//int x = pData->lastPunchX;
													//int y = pData->lastPunchY;
													if (world->items.at(x + (y * world->width)).foreground != 2978) break;
													if (world->items.at(x + (y * world->width)).opened && setprice > world->items.at(x + (y * world->width)).vcount && world->items.at(x + (y * world->width)).vid != 0) {
														Player::OnConsoleMessage(peer, "You Don't have enough in there for anyone to buy at that price!");
														Player::OnTalkBubble(peer, pData->netID, "You Don't have enough in there for anyone to buy at that price!", 0, true);
														break;
													}
													if (world->items.at(x + (y * world->width)).opened && setprice > 250 && world->items.at(x + (y * world->width)).vid != 0) {
														Player::OnConsoleMessage(peer, "That price is so low, nobody can carry a World Lock worth of items!");
														Player::OnTalkBubble(peer, pData->netID, "That price is so low, nobody can carry a World Lock worth of items!", 0, true);
														break;
													}
													if (setprice == world->items.at(x + (y * world->width)).vprice) continue;
													world->items.at(x + (y * world->width)).vprice = setprice;
													auto islocks = false;
													if (world->items.at(x + (y * world->width)).vdraw >= 1) islocks = true;
													if (isMod(peer) && !isWorldOwner(peer, world) && world->items.at(x + (y * world->width)).opened) LogAccountActivity(pData->rawName, pData->rawName, "Changed " + getItemDef(world->items.at(x + (y * world->width)).vid).name + " price to " + to_string(setprice) + " per World Lock in " + getItemDef(world->items.at(x + (y * world->width)).foreground).name + " (" + world->name + ")");
													else if (isMod(peer) && !isWorldOwner(peer, world)) LogAccountActivity(pData->rawName, pData->rawName, "Changed " + getItemDef(world->items.at(x + (y * world->width)).vid).name + " price to " + to_string(setprice) + " World Locks each in " + getItemDef(world->items.at(x + (y * world->width)).foreground).name + " (" + world->name + ")");
													ENetPeer* currentPeer;
													for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
														if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
														if (isHere(peer, currentPeer)) {
															//cout << "say6" << endl;
															if (!Changedmh) {
																if (world->items.at(x + (y * world->width)).opened) {
																	Player::OnConsoleMessage(currentPeer, "`7[`o" + pData->displayName + " `ochanged the price of `2" + getItemDef(world->items.at(x + (y * world->width)).vid).name + "`o to `6" + to_string(setprice) + " per World lock.`7]");
																	Player::OnTalkBubble(currentPeer, pData->netID, "`7[`w" + pData->displayName + " `wchanged the price of `2" + getItemDef(world->items.at(x + (y * world->width)).vid).name + "`w to `6" + to_string(setprice) + " per World lock.`7]", 0, true);
																}
																else {
																	Player::OnConsoleMessage(currentPeer, "`7[`o" + pData->displayName + " `ochanged the price of `2" + getItemDef(world->items.at(x + (y * world->width)).vid).name + "`o to `5" + to_string(setprice) + " World Locks each.`7]");
																	Player::OnTalkBubble(currentPeer, pData->netID, "`7[`w" + pData->displayName + " `wchanged the price of `2" + getItemDef(world->items.at(x + (y * world->width)).vid).name + "`w to `5" + to_string(setprice) + " World Locks each.`7]", 0, true);
																}
																Player::OnParticleEffect(currentPeer, 44, x * 32, y * 32, 0);
															}
															if (world->items.at(x + (y * world->width)).opened && world->items.at(x + (y * world->width)).vcount < world->items.at(x + (y * world->width)).vprice) {
																UpdateVend(currentPeer, x, y, 0, islocks, setprice, world->items.at(x + (y * world->width)).background, world->items.at(x + (y * world->width)).opened);
															}
															else UpdateVend(currentPeer, x, y, world->items.at(x + (y * world->width)).vid, islocks, setprice, world->items.at(x + (y * world->width)).background, world->items.at(x + (y * world->width)).opened);
														}
													}
													break;
												}
												if (infoDat.at(0) == "stockitem") {
													if (world->owner != "" && !isWorldOwner(peer, world) && !isMod(peer)) break;
													string stockitemstr = infoDat.at(1);
													if (stockitemstr.size() > 5 || stockitemstr.size() <= 0) break;
													stockitem = atoi(stockitemstr.c_str());
													if (stockitem < 0 || stockitem > maxItems) break;
													if (stockitem == 18 || stockitem == 32 || stockitem == 1424 || stockitem == 6336 || getItemDef(stockitem).blockType == BlockTypes::LOCK || getItemDef(stockitem).properties & Property_Untradable || getItemDef(stockitem).blockType == BlockTypes::FISH || stockitem == 8552 || stockitem == 9472 || stockitem == 9482 || stockitem == 9356 || stockitem == 9492 || stockitem == 9498 || stockitem == 8774 || stockitem == 1790 || stockitem == 2592 || stockitem == 1784 || stockitem == 1792 || stockitem == 1794 || stockitem == 7734 || stockitem == 8306 || stockitem == 9458) {
														Player::OnConsoleMessage(peer, "`oCan't put that in a Vending Machine.");
														Player::OnTalkBubble(peer, pData->netID, "`wCan't put that in a Vending Machine.", 0, true);
														break;
													}
													int count = 1;
													for (auto i = 0; i < pData->inventory.items.size(); i++) {
														if (pData->inventory.items.at(i).itemID == stockitem) {
															count = pData->inventory.items.at(i).itemCount;
															break;
														}
													}
													if (stockitem == 0 || count == 0) break;
													auto contains = false;
													SearchInventoryItem(peer, stockitem, count, contains);
													if (!contains) break;
													RemoveInventoryItem(stockitem, count, peer, true);
													updateplayerset(peer, stockitem);
													int x = pData->lastPunchX;
													int y = pData->lastPunchY;
													if (world->items.at(x + (y * world->width)).foreground != 2978) break;									
													world->items.at(x + (y * world->width)).vprice = setprice;
													world->items.at(x + (y * world->width)).vid = stockitem;
													world->items.at(x + (y * world->width)).vcount = count;
													auto islocks = false;
													if (world->items.at(x + (y * world->width)).vdraw >= 1) islocks = true;
													ENetPeer* currentPeer;
													for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
														if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
														if (isHere(peer, currentPeer)) {
															//cout << "say5" << endl;
															Player::OnConsoleMessage(currentPeer, "`7[`o" + pData->displayName + " `oput `2" + getItemDef(stockitem).name + " `oin the Vending Machine.`7]");
															Player::OnTalkBubble(currentPeer, pData->netID, "`7[`w" + pData->displayName + " `wput `2" + getItemDef(stockitem).name + "`w in the Vending Machine.`7]", 0, false);
															if (world->items.at(x + (y * world->width)).opened && world->items.at(x + (y * world->width)).vcount < world->items.at(x + (y * world->width)).vprice) {
																UpdateVend(currentPeer, x, y, 0, islocks, setprice, world->items.at(x + (y * world->width)).background, world->items.at(x + (y * world->width)).opened);
															}
															else UpdateVend(currentPeer, x, y, stockitem, islocks, setprice, world->items.at(x + (y * world->width)).background, world->items.at(x + (y * world->width)).opened);
															Player::OnParticleEffect(currentPeer, 44, x * 32, y * 32, 0);
														}
													}
													SendVendDialog(peer, world);
													break;
												}
												if (infoDat.at(0) == "setprice") {
													if (world->owner != "" && !isWorldOwner(peer, world) && !isMod(peer)) break;
													string setpricestr = infoDat.at(1);
													if (setpricestr.size() > 5 || setpricestr.size() <= 0) break;
													setprice = atoi(setpricestr.c_str());
													if (setprice <= 0) continue;
													if (setprice > 20000) {
														Player::OnTalkBubble(peer, pData->netID, "Well, that's a silly price.", 0, true);
														break;
													}
													int x = pData->lastPunchX;
													int y = pData->lastPunchY;
													if (world->items.at(x + (y * world->width)).foreground != 2978) break;
													if (vend_set_price == "0") {
														vend_set_price = to_string(setprice);
														continue;
													}
													if (world->items.at(x + (y * world->width)).opened && setprice > world->items.at(x + (y * world->width)).vcount && world->items.at(x + (y * world->width)).vid != 0) {
														Player::OnConsoleMessage(peer, "You Don't have enough in there for anyone to buy at that price!");
														Player::OnTalkBubble(peer, pData->netID, "You Don't have enough in there for anyone to buy at that price!", 0, true);
														break;
													}
													if (world->items.at(x + (y * world->width)).opened && setprice > 250 && world->items.at(x + (y * world->width)).vid != 0) {
														Player::OnConsoleMessage(peer, "That price is so low, nobody can carry a World Lock worth of items!");
														Player::OnTalkBubble(peer, pData->netID, "That price is so low, nobody can carry a World Lock worth of items!", 0, true);
														break;
													}
													if (setprice == world->items.at(x + (y * world->width)).vprice) continue;
													world->items.at(x + (y * world->width)).vprice = setprice;
													auto islocks = false;
													if (world->items.at(x + (y * world->width)).vdraw >= 1) islocks = true;
													if (isMod(peer) && !isWorldOwner(peer, world) && world->items.at(x + (y * world->width)).opened) LogAccountActivity(pData->rawName, pData->rawName, "Changed " + getItemDef(world->items.at(x + (y * world->width)).vid).name + " price to " + to_string(setprice) + " per World Lock in " + getItemDef(world->items.at(x + (y * world->width)).foreground).name + " (" + world->name + ")");
													else if (isMod(peer) && !isWorldOwner(peer, world)) LogAccountActivity(pData->rawName, pData->rawName, "Changed " + getItemDef(world->items.at(x + (y * world->width)).vid).name + " price to " + to_string(setprice) + " World Locks each in " + getItemDef(world->items.at(x + (y * world->width)).foreground).name + " (" + world->name + ")");
													ENetPeer* currentPeer;
													for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
														if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
														if (isHere(peer, currentPeer)) {
															//cout << "say6" << endl;
															if (world->items.at(x + (y * world->width)).opened) {
																Player::OnConsoleMessage(currentPeer, "`7[`o" + pData->displayName + " `ochanged the price of `2" + getItemDef(world->items.at(x + (y * world->width)).vid).name + "`o to `6" + to_string(setprice) + " per World lock.`7]");
																Player::OnTalkBubble(currentPeer, pData->netID, "`7[`w" + pData->displayName + " `wchanged the price of `2" + getItemDef(world->items.at(x + (y * world->width)).vid).name + "`w to `6" + to_string(setprice) + " per World lock.`7]", 0, true);
															} else {
																Player::OnConsoleMessage(currentPeer, "`7[`o" + pData->displayName + " `ochanged the price of `2" + getItemDef(world->items.at(x + (y * world->width)).vid).name + "`o to `5" + to_string(setprice) + " World Locks each.`7]");
																Player::OnTalkBubble(currentPeer, pData->netID, "`7[`w" + pData->displayName + " `wchanged the price of `2" + getItemDef(world->items.at(x + (y * world->width)).vid).name + "`w to `5" + to_string(setprice) + " World Locks each.`7]", 0, true);
															}
															Player::OnParticleEffect(currentPeer, 44, x * 32, y * 32, 0);
															if (world->items.at(x + (y * world->width)).opened && world->items.at(x + (y * world->width)).vcount < world->items.at(x + (y * world->width)).vprice) {
																UpdateVend(currentPeer, x, y, 0, islocks, setprice, world->items.at(x + (y * world->width)).background, world->items.at(x + (y * world->width)).opened);
															}
															else UpdateVend(currentPeer, x, y, world->items.at(x + (y * world->width)).vid, islocks, setprice, world->items.at(x + (y * world->width)).background, world->items.at(x + (y * world->width)).opened);
														}
													}
													break;
												}
												/*Buyerio Puse*/
												if (infoDat.at(0) == "buycount") {
													string buycountstr = infoDat.at(1);
													if (buycountstr.size() > 3 || buycountstr.size() <= 0) break;
													buyprice = atoi(buycountstr.c_str());
													if (buyprice <= 0) break;
													int x = pData->lastPunchX;
													int y = pData->lastPunchY;
													if (world->items.at(x + (y * world->width)).foreground != 2978) break;
													auto realprice = world->items.at(x + (y * world->width)).vprice;
													auto kiekmoketi = buyprice * realprice; 
													auto worldlocks = 0;
													auto diamondlocks = 0;
													auto locks = 0;
													for (auto i = 0; i < pData->inventory.items.size(); i++) {
														if (pData->inventory.items.at(i).itemID == 242) {
															worldlocks = pData->inventory.items.at(i).itemCount;
														}
														if (pData->inventory.items.at(i).itemID == 1796) {
															diamondlocks = pData->inventory.items.at(i).itemCount;
														}
													}
													if (diamondlocks > 0) locks = diamondlocks * 100;
													locks += worldlocks;
													if (kiekmoketi > locks && !world->items.at(x + (y * world->width)).opened) {
														Player::OnTalkBubble(peer, pData->netID, "You can't afford that many!", 0, true);
														break;
													} 
													if (CheckItemMaxed(peer, world->items.at(x + (y * world->width)).vid, buyprice)) {
														Player::OnTalkBubble(peer, pData->netID, "That wouldnt fit into my inventory!", 0, true);
														break;
													}
													int yracount = world->items.at(x + (y * world->width)).vcount;
													int yrawithdraw = world->items.at(x + (y * world->width)).vdraw;
													if (yracount < buyprice) {
														Player::OnTalkBubble(peer, pData->netID, "Out of order", 0, true);
														break;
													}
													if (world->items.at(x + (y * world->width)).opened) {
														if (buyprice < world->items.at(x + (y * world->width)).vprice) {
															Player::OnConsoleMessage(peer, "You have to buy at least 1 World Lock's worth.");
															Player::OnTalkBubble(peer, pData->netID, "You have to buy at least 1 World Lock's worth.", 0, true);
															break;
														}
														int oldbuyprice = buyprice;
														buyprice = round(((double)buyprice / world->items.at(x + (y * world->width)).vprice));
														kiekmoketi = buyprice;
														buyprice *= world->items.at(x + (y * world->width)).vprice;
														if (buyprice > world->items.at(x + (y * world->width)).vcount) {
															buyprice = round(oldbuyprice / world->items.at(x + (y * world->width)).vprice);
															kiekmoketi = buyprice;
															buyprice *= world->items.at(x + (y * world->width)).vprice;
														} 
													}
													if (kiekmoketi > locks) {
														Player::OnTalkBubble(peer, pData->netID, "You can't afford that many!", 0, true);
														break;
													}
													pData->lastvendbuycount = to_string(buyprice);
													Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wPurchase Confirmation``|left|1366|\nadd_spacer|small|\nadd_spacer|small|\nadd_textbox|`4You'll give:``|left|\nadd_spacer|small|\nadd_label_with_icon|small|(`w" + to_string(kiekmoketi) + "``) `8World Locks``|left|242|\nadd_spacer|small|\nadd_textbox|`2You'll get:``|left|\nadd_spacer|small|\nadd_label_with_icon|small|(`w" + to_string(buyprice) + "``) `2" + getItemDef(world->items.at(x + (y * world->width)).vid).name + "``|left|" + to_string(world->items.at(x + (y * world->width)).vid) + "|\nadd_spacer|small|\nadd_spacer|small|\nadd_textbox|Are you sure you want to make this purchase?|left|\nend_dialog|vending_buy|Cancel|OK|");
													break;
												}
											}
											if (digivending) {
												if (infoDat.at(1) == "pullstock") break;
												if (infoDat.at(0) == "chk_peritem") {
													per_item = infoDat.at(1);
												}
												if (infoDat.at(0) == "chk_perlock") {
													if (world->owner != "" && !isWorldOwner(peer, world) && !isMod(peer)) break;
													int x = pData->lastPunchX;
													int y = pData->lastPunchY;
													if (world->items.at(x + (y * world->width)).foreground != 9268) break;
													bool Changedmh = false;
													if (per_item == "1" && infoDat.at(1) == "1") {
														Player::OnConsoleMessage(peer, "You can't have it both ways.");
														Player::OnTalkBubble(peer, pData->netID, "You can't have it both ways.", 0, true);
														break;
													}
													if (!world->items.at(x + (y * world->width)).opened && per_item == "0" && world->items.at(x + (y * world->width)).rm && infoDat.at(1) != "1") {
														Player::OnConsoleMessage(peer, "You need to pick a pricing method.");
														Player::OnTalkBubble(peer, pData->netID, "You need to pick a pricing method.", 0, true);
														break;
													}
													if (per_item == "0" && world->items.at(x + (y * world->width)).rm && world->items.at(x + (y * world->width)).vprice > world->items.at(x + (y * world->width)).vcount && world->items.at(x + (y * world->width)).vid != 0) {
														Player::OnConsoleMessage(peer, "You Don't have enough in there for anyone to buy at that price!");
														Player::OnTalkBubble(peer, pData->netID, "You Don't have enough in there for anyone to buy at that price!", 0, true);
														break;
													}
													if (per_item == "1" && !world->items.at(x + (y * world->width)).rm) {
														Changedmh = true;
														world->items.at(x + (y * world->width)).rm = true;
														auto islocks = false;
														if (world->items.at(x + (y * world->width)).vdraw >= 1) islocks = true;
														for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
															if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
															if (isHere(peer, currentPeer)) {
																if (world->items.at(x + (y * world->width)).opened && world->items.at(x + (y * world->width)).vcount < world->items.at(x + (y * world->width)).vprice) {
																	UpdateDigiVend(currentPeer, x, y, 0, islocks, world->items.at(x + (y * world->width)).vprice, world->items.at(x + (y * world->width)).background, world->items.at(x + (y * world->width)).opened);
																}
																else UpdateDigiVend(currentPeer, x, y, world->items.at(x + (y * world->width)).vid, islocks, world->items.at(x + (y * world->width)).vprice, world->items.at(x + (y * world->width)).background, world->items.at(x + (y * world->width)).opened);
															}
														}
													}
													else if (per_item == "0" && world->items.at(x + (y * world->width)).rm) {
														Changedmh = true;
														world->items.at(x + (y * world->width)).rm = false;
														auto islocks = false;
														if (world->items.at(x + (y * world->width)).vdraw >= 1) islocks = true;
														for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
															if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
															if (isHere(peer, currentPeer)) {
																//cout << "say2" << endl;
																//Player::OnConsoleMessage(currentPeer, "`7[`o" + pData->displayName + " `ochanged the price of `2" + getItemDef(world->items.at(x + (y * world->width)).vid).name + "`o to `6" + to_string(world->items.at(x + (y * world->width)).vprice) + " per World lock.`7]");
																//Player::OnTalkBubble(currentPeer, pData->netID, "`7[`w" + pData->displayName + " `wchanged the price of `2" + getItemDef(world->items.at(x + (y * world->width)).vid).name + "`w to `6" + to_string(world->items.at(x + (y * world->width)).vprice) + " per World lock.`7]", 0, true);
																if (world->items.at(x + (y * world->width)).opened && world->items.at(x + (y * world->width)).vcount < world->items.at(x + (y * world->width)).vprice) {
																	UpdateDigiVend(currentPeer, x, y, 0, islocks, world->items.at(x + (y * world->width)).vprice, world->items.at(x + (y * world->width)).background, world->items.at(x + (y * world->width)).opened);
																}
																else UpdateDigiVend(currentPeer, x, y, world->items.at(x + (y * world->width)).vid, islocks, world->items.at(x + (y * world->width)).vprice, world->items.at(x + (y * world->width)).background, world->items.at(x + (y * world->width)).opened);
																//Player::OnParticleEffect(currentPeer, 44, x * 32, y * 32, 0);
															}
														}
													}
													if (!world->items.at(x + (y * world->width)).rm && infoDat.at(1) == "0" && world->items.at(x + (y * world->width)).opened) {
														Player::OnConsoleMessage(peer, "You need to pick a pricing method.");
														Player::OnTalkBubble(peer, pData->netID, "You need to pick a pricing method.", 0, true);
														break;
													}
													if (infoDat.at(1) == "1" && !world->items.at(x + (y * world->width)).opened) {
														//cout << "price change" << endl;
														Changedmh = true;
														world->items.at(x + (y * world->width)).opened = true;
														auto islocks = false;
														if (world->items.at(x + (y * world->width)).vdraw >= 1) islocks = true;
														for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
															if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
															if (isHere(peer, currentPeer)) {
																//cout << "say3" << endl;
																//Player::OnConsoleMessage(currentPeer, "`7[`o" + pData->displayName + " `ochanged the price of `2" + getItemDef(world->items.at(x + (y * world->width)).vid).name + "`o to `6" + to_string(world->items.at(x + (y * world->width)).vprice) + " per World lock.`7]");
																//Player::OnTalkBubble(currentPeer, pData->netID, "`7[`w" + pData->displayName + " `wchanged the price of `2" + getItemDef(world->items.at(x + (y * world->width)).vid).name + "`w to `6" + to_string(world->items.at(x + (y * world->width)).vprice) + " per World lock.`7]", 0, true);
																if (world->items.at(x + (y * world->width)).opened && world->items.at(x + (y * world->width)).vcount < world->items.at(x + (y * world->width)).vprice) {
																	UpdateDigiVend(currentPeer, x, y, 0, islocks, world->items.at(x + (y * world->width)).vprice, world->items.at(x + (y * world->width)).background, world->items.at(x + (y * world->width)).opened);
																}
																else UpdateDigiVend(currentPeer, x, y, world->items.at(x + (y * world->width)).vid, islocks, world->items.at(x + (y * world->width)).vprice, world->items.at(x + (y * world->width)).background, world->items.at(x + (y * world->width)).opened);
																//Player::OnParticleEffect(currentPeer, 44, x * 32, y * 32, 0);
															}
														}
													}
													else if (infoDat.at(1) == "0" && world->items.at(x + (y * world->width)).opened) {
														Changedmh = true;
														world->items.at(x + (y * world->width)).opened = false;
														auto islocks = false;
														if (world->items.at(x + (y * world->width)).vdraw >= 1) islocks = true;
														for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
															if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
															if (isHere(peer, currentPeer)) {
																//cout << "say4" << endl;
																//Player::OnConsoleMessage(currentPeer, "`7[`o" + pData->displayName + " `ochanged the price of `2" + getItemDef(world->items.at(x + (y * world->width)).vid).name + "`o to `5" + to_string(world->items.at(x + (y * world->width)).vprice) + " World Locks each.`7]");
																//Player::OnTalkBubble(currentPeer, pData->netID, "`7[`w" + pData->displayName + " `wchanged the price of `2" + getItemDef(world->items.at(x + (y * world->width)).vid).name + "`w to `5" + to_string(world->items.at(x + (y * world->width)).vprice) + " World Locks each.`7]", 0, true);
																if (world->items.at(x + (y * world->width)).opened && world->items.at(x + (y * world->width)).vcount < world->items.at(x + (y * world->width)).vprice) {
																	UpdateDigiVend(currentPeer, x, y, 0, islocks, world->items.at(x + (y * world->width)).vprice, world->items.at(x + (y * world->width)).background, world->items.at(x + (y * world->width)).opened);
																}
																else UpdateDigiVend(currentPeer, x, y, world->items.at(x + (y * world->width)).vid, islocks, world->items.at(x + (y * world->width)).vprice, world->items.at(x + (y * world->width)).background, world->items.at(x + (y * world->width)).opened);
																//Player::OnParticleEffect(currentPeer, 44, x * 32, y * 32, 0);
															}
														}
													}
													if (Changedmh) {
														for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
															if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
															if (isHere(peer, currentPeer)) {
																if (world->items.at(x + (y * world->width)).opened) {
																	Player::OnConsoleMessage(currentPeer, "`7[`o" + pData->displayName + " `ochanged the price of `2" + getItemDef(world->items.at(x + (y * world->width)).vid).name + "`o to `6" + to_string(setprice) + " per World lock.`7]");
																	Player::OnTalkBubble(currentPeer, pData->netID, "`7[`w" + pData->displayName + " `wchanged the price of `2" + getItemDef(world->items.at(x + (y * world->width)).vid).name + "`w to `6" + to_string(setprice) + " per World lock.`7]", 0, true);
																}
																else {
																	Player::OnConsoleMessage(currentPeer, "`7[`o" + pData->displayName + " `ochanged the price of `2" + getItemDef(world->items.at(x + (y * world->width)).vid).name + "`o to `5" + to_string(setprice) + " World Locks each.`7]");
																	Player::OnTalkBubble(currentPeer, pData->netID, "`7[`w" + pData->displayName + " `wchanged the price of `2" + getItemDef(world->items.at(x + (y * world->width)).vid).name + "`w to `5" + to_string(setprice) + " World Locks each.`7]", 0, true);
																}
																Player::OnParticleEffect(currentPeer, 44, x * 32, y * 32, 0);
															}
														}
													}
													if (world->owner != "" && !isWorldOwner(peer, world) && !isMod(peer)) break;
													string setpricestr = vend_set_price;
													if (setpricestr.size() > 5 || setpricestr.size() <= 0) break;
													setprice = atoi(setpricestr.c_str());
													if (setprice <= 0) continue;
													if (setprice > 20000) {
														Player::OnTalkBubble(peer, pData->netID, "Well, that's a silly price.", 0, true);
														break;
													}
													//int x = pData->lastPunchX;
													//int y = pData->lastPunchY;
													if (world->items.at(x + (y * world->width)).foreground != 9268) break;
													if (world->items.at(x + (y * world->width)).opened && setprice > world->items.at(x + (y * world->width)).vcount && world->items.at(x + (y * world->width)).vid != 0) {
														Player::OnConsoleMessage(peer, "You Don't have enough in there for anyone to buy at that price!");
														Player::OnTalkBubble(peer, pData->netID, "You Don't have enough in there for anyone to buy at that price!", 0, true);
														break;
													}
													if (world->items.at(x + (y * world->width)).opened && setprice > 250 && world->items.at(x + (y * world->width)).vid != 0) {
														Player::OnConsoleMessage(peer, "That price is so low, nobody can carry a World Lock worth of items!");
														Player::OnTalkBubble(peer, pData->netID, "That price is so low, nobody can carry a World Lock worth of items!", 0, true);
														break;
													}
													if (setprice == world->items.at(x + (y * world->width)).vprice) continue;
													world->items.at(x + (y * world->width)).vprice = setprice;
													auto islocks = false;
													if (world->items.at(x + (y * world->width)).vdraw >= 1) islocks = true;
													if (isMod(peer) && !isWorldOwner(peer, world) && world->items.at(x + (y * world->width)).opened) LogAccountActivity(pData->rawName, pData->rawName, "Changed " + getItemDef(world->items.at(x + (y * world->width)).vid).name + " price to " + to_string(setprice) + " per World Lock in " + getItemDef(world->items.at(x + (y * world->width)).foreground).name + " (" + world->name + ")");
													else if (isMod(peer) && !isWorldOwner(peer, world)) LogAccountActivity(pData->rawName, pData->rawName, "Changed " + getItemDef(world->items.at(x + (y * world->width)).vid).name + " price to " + to_string(setprice) + " World Locks each in " + getItemDef(world->items.at(x + (y * world->width)).foreground).name + " (" + world->name + ")");
													ENetPeer* currentPeer;
													for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
														if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
														if (isHere(peer, currentPeer)) {
															//cout << "say6" << endl;
															if (!Changedmh) {
																if (world->items.at(x + (y * world->width)).opened) {
																	Player::OnConsoleMessage(currentPeer, "`7[`o" + pData->displayName + " `ochanged the price of `2" + getItemDef(world->items.at(x + (y * world->width)).vid).name + "`o to `6" + to_string(setprice) + " per World lock.`7]");
																	Player::OnTalkBubble(currentPeer, pData->netID, "`7[`w" + pData->displayName + " `wchanged the price of `2" + getItemDef(world->items.at(x + (y * world->width)).vid).name + "`w to `6" + to_string(setprice) + " per World lock.`7]", 0, true);
																}
																else {
																	Player::OnConsoleMessage(currentPeer, "`7[`o" + pData->displayName + " `ochanged the price of `2" + getItemDef(world->items.at(x + (y * world->width)).vid).name + "`o to `5" + to_string(setprice) + " World Locks each.`7]");
																	Player::OnTalkBubble(currentPeer, pData->netID, "`7[`w" + pData->displayName + " `wchanged the price of `2" + getItemDef(world->items.at(x + (y * world->width)).vid).name + "`w to `5" + to_string(setprice) + " World Locks each.`7]", 0, true);
																}
																Player::OnParticleEffect(currentPeer, 44, x * 32, y * 32, 0);
															}
															if (world->items.at(x + (y * world->width)).opened && world->items.at(x + (y * world->width)).vcount < world->items.at(x + (y * world->width)).vprice) {
																UpdateDigiVend(currentPeer, x, y, 0, islocks, setprice, world->items.at(x + (y * world->width)).background, world->items.at(x + (y * world->width)).opened);
															}
															else UpdateDigiVend(currentPeer, x, y, world->items.at(x + (y * world->width)).vid, islocks, setprice, world->items.at(x + (y * world->width)).background, world->items.at(x + (y * world->width)).opened);
														}
													}
													break;
												}
												if (infoDat.at(0) == "stockitem1") {
													if (world->owner != "" && !isWorldOwner(peer, world) && !isMod(peer)) break;
													string stockitemstr = infoDat.at(1);
													if (stockitemstr.size() > 5 || stockitemstr.size() <= 0) break;
													stockitem = atoi(stockitemstr.c_str());
													if (stockitem < 0 || stockitem > maxItems) break;
													if (stockitem == 18 || stockitem == 32 || stockitem == 6336 || getItemDef(stockitem).blockType == BlockTypes::LOCK || getItemDef(stockitem).properties & Property_Untradable || getItemDef(stockitem).blockType == BlockTypes::FISH || stockitem == 8552 || stockitem == 9472 || stockitem == 9482 || stockitem == 9356 || stockitem == 9492 || stockitem == 9498 || stockitem == 8774 || stockitem == 1790 || stockitem == 2592 || stockitem == 1784 || stockitem == 1792 || stockitem == 1794 || stockitem == 7734 || stockitem == 8306 || stockitem == 9458) {
														Player::OnConsoleMessage(peer, "`oCan't put that in a Vending Machine.");
														Player::OnTalkBubble(peer, pData->netID, "`wCan't put that in a Vending Machine.", 0, true);
														break;
													}
													int count = 1;
													for (auto i = 0; i < pData->inventory.items.size(); i++) {
														if (pData->inventory.items.at(i).itemID == stockitem) {
															count = pData->inventory.items.at(i).itemCount;
															break;
														}
													}
													if (stockitem == 0 || count == 0) break;
													auto contains = false;
													SearchInventoryItem(peer, stockitem, count, contains);
													if (!contains) break;
													RemoveInventoryItem(stockitem, count, peer, true);
													updateplayerset(peer, stockitem);
													int x = pData->lastPunchX;
													int y = pData->lastPunchY;
													if (world->items.at(x + (y * world->width)).foreground != 9268) break;
													world->items.at(x + (y * world->width)).vprice = setprice;
													world->items.at(x + (y * world->width)).vid = stockitem;
													world->items.at(x + (y * world->width)).vcount = count;
													auto islocks = false;
													if (world->items.at(x + (y * world->width)).vdraw >= 1) islocks = true;
													ENetPeer* currentPeer;
													for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
														if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
														if (isHere(peer, currentPeer)) {
															//cout << "say5" << endl;
															Player::OnConsoleMessage(currentPeer, "`7[`o" + pData->displayName + " `oput `2" + getItemDef(stockitem).name + " `oin the Vending Machine.`7]");
															Player::OnTalkBubble(currentPeer, pData->netID, "`7[`w" + pData->displayName + " `wput `2" + getItemDef(stockitem).name + "`w in the Vending Machine.`7]", 0, false);
															if (world->items.at(x + (y * world->width)).opened && world->items.at(x + (y * world->width)).vcount < world->items.at(x + (y * world->width)).vprice) {
																UpdateDigiVend(currentPeer, x, y, 0, islocks, setprice, world->items.at(x + (y * world->width)).background, world->items.at(x + (y * world->width)).opened);
															}
															else UpdateDigiVend(currentPeer, x, y, stockitem, islocks, setprice, world->items.at(x + (y * world->width)).background, world->items.at(x + (y * world->width)).opened);
															Player::OnParticleEffect(currentPeer, 44, x * 32, y * 32, 0);
														}
													}
													SendDigiVendDialog(peer, world);
													break;
												}
												if (infoDat.at(0) == "setprice") {
													if (world->owner != "" && !isWorldOwner(peer, world) && !isMod(peer)) break;
													string setpricestr = infoDat.at(1);
													if (setpricestr.size() > 5 || setpricestr.size() <= 0) break;
													setprice = atoi(setpricestr.c_str());
													if (setprice <= 0) continue;
													if (setprice > 20000) {
														Player::OnTalkBubble(peer, pData->netID, "Well, that's a silly price.", 0, true);
														break;
													}
													int x = pData->lastPunchX;
													int y = pData->lastPunchY;
													if (world->items.at(x + (y * world->width)).foreground != 9268) break;
													if (vend_set_price == "0") {
														vend_set_price = to_string(setprice);
														continue;
													}
													if (world->items.at(x + (y * world->width)).opened && setprice > world->items.at(x + (y * world->width)).vcount && world->items.at(x + (y * world->width)).vid != 0) {
														Player::OnConsoleMessage(peer, "You Don't have enough in there for anyone to buy at that price!");
														Player::OnTalkBubble(peer, pData->netID, "You Don't have enough in there for anyone to buy at that price!", 0, true);
														break;
													}
													if (world->items.at(x + (y * world->width)).opened && setprice > 250 && world->items.at(x + (y * world->width)).vid != 0) {
														Player::OnConsoleMessage(peer, "That price is so low, nobody can carry a World Lock worth of items!");
														Player::OnTalkBubble(peer, pData->netID, "That price is so low, nobody can carry a World Lock worth of items!", 0, true);
														break;
													}
													if (setprice == world->items.at(x + (y * world->width)).vprice) continue;
													world->items.at(x + (y * world->width)).vprice = setprice;
													auto islocks = false;
													if (world->items.at(x + (y * world->width)).vdraw >= 1) islocks = true;
													if (isMod(peer) && !isWorldOwner(peer, world) && world->items.at(x + (y * world->width)).opened) LogAccountActivity(pData->rawName, pData->rawName, "Changed " + getItemDef(world->items.at(x + (y * world->width)).vid).name + " price to " + to_string(setprice) + " per World Lock in " + getItemDef(world->items.at(x + (y * world->width)).foreground).name + " (" + world->name + ")");
													else if (isMod(peer) && !isWorldOwner(peer, world)) LogAccountActivity(pData->rawName, pData->rawName, "Changed " + getItemDef(world->items.at(x + (y * world->width)).vid).name + " price to " + to_string(setprice) + " World Locks each in " + getItemDef(world->items.at(x + (y * world->width)).foreground).name + " (" + world->name + ")");
													ENetPeer* currentPeer;
													for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
														if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
														if (isHere(peer, currentPeer)) {
															//cout << "say6" << endl;
															if (world->items.at(x + (y * world->width)).opened) {
																Player::OnConsoleMessage(currentPeer, "`7[`o" + pData->displayName + " `ochanged the price of `2" + getItemDef(world->items.at(x + (y * world->width)).vid).name + "`o to `6" + to_string(setprice) + " per World lock.`7]");
																Player::OnTalkBubble(currentPeer, pData->netID, "`7[`w" + pData->displayName + " `wchanged the price of `2" + getItemDef(world->items.at(x + (y * world->width)).vid).name + "`w to `6" + to_string(setprice) + " per World lock.`7]", 0, true);
															}
															else {
																Player::OnConsoleMessage(currentPeer, "`7[`o" + pData->displayName + " `ochanged the price of `2" + getItemDef(world->items.at(x + (y * world->width)).vid).name + "`o to `5" + to_string(setprice) + " World Locks each.`7]");
																Player::OnTalkBubble(currentPeer, pData->netID, "`7[`w" + pData->displayName + " `wchanged the price of `2" + getItemDef(world->items.at(x + (y * world->width)).vid).name + "`w to `5" + to_string(setprice) + " World Locks each.`7]", 0, true);
															}
															Player::OnParticleEffect(currentPeer, 44, x * 32, y * 32, 0);
															if (world->items.at(x + (y * world->width)).opened && world->items.at(x + (y * world->width)).vcount < world->items.at(x + (y * world->width)).vprice) {
																UpdateDigiVend(currentPeer, x, y, 0, islocks, setprice, world->items.at(x + (y * world->width)).background, world->items.at(x + (y * world->width)).opened);
															}
															else UpdateDigiVend(currentPeer, x, y, world->items.at(x + (y * world->width)).vid, islocks, setprice, world->items.at(x + (y * world->width)).background, world->items.at(x + (y * world->width)).opened);
														}
													}
													break;
												}
												/*Buyerio Puse*/
												if (infoDat.at(0) == "buycount") {
													string buycountstr = infoDat.at(1);
													if (buycountstr.size() > 3 || buycountstr.size() <= 0) break;
													buyprice = atoi(buycountstr.c_str());
													if (buyprice <= 0) break;
													int x = pData->lastPunchX;
													int y = pData->lastPunchY;
													if (world->items.at(x + (y * world->width)).foreground != 9268) break;
													auto realprice = world->items.at(x + (y * world->width)).vprice;
													auto kiekmoketi = buyprice * realprice;
													auto worldlocks = 0;
													auto diamondlocks = 0;
													auto locks = 0;
													for (auto i = 0; i < pData->inventory.items.size(); i++) {
														if (pData->inventory.items.at(i).itemID == 242) {
															worldlocks = pData->inventory.items.at(i).itemCount;
														}
														if (pData->inventory.items.at(i).itemID == 1796) {
															diamondlocks = pData->inventory.items.at(i).itemCount;
														}
													}
													if (diamondlocks > 0) locks = diamondlocks * 100;
													locks += worldlocks;
													if (kiekmoketi > locks && !world->items.at(x + (y * world->width)).opened) {
														Player::OnTalkBubble(peer, pData->netID, "You can't afford that many!", 0, true);
														break;
													}
													if (CheckItemMaxed(peer, world->items.at(x + (y * world->width)).vid, buyprice)) {
														Player::OnTalkBubble(peer, pData->netID, "That wouldnt fit into my inventory!", 0, true);
														break;
													}
													int yracount = world->items.at(x + (y * world->width)).vcount;
													int yrawithdraw = world->items.at(x + (y * world->width)).vdraw;
													if (yracount < buyprice) {
														Player::OnTalkBubble(peer, pData->netID, "Out of order", 0, true);
														break;
													}
													if (world->items.at(x + (y * world->width)).opened) {
														if (buyprice < world->items.at(x + (y * world->width)).vprice) {
															Player::OnConsoleMessage(peer, "You have to buy at least 1 World Lock's worth.");
															Player::OnTalkBubble(peer, pData->netID, "You have to buy at least 1 World Lock's worth.", 0, true);
															break;
														}
														int oldbuyprice = buyprice;
														buyprice = round(((double)buyprice / world->items.at(x + (y * world->width)).vprice));
														kiekmoketi = buyprice;
														buyprice *= world->items.at(x + (y * world->width)).vprice;
														if (buyprice > world->items.at(x + (y * world->width)).vcount) {
															buyprice = round(oldbuyprice / world->items.at(x + (y * world->width)).vprice);
															kiekmoketi = buyprice;
															buyprice *= world->items.at(x + (y * world->width)).vprice;
														}
													}
													if (kiekmoketi > locks) {
														Player::OnTalkBubble(peer, pData->netID, "You can't afford that many!", 0, true);
														break;
													}
													pData->lastvendbuycount = to_string(buyprice);
													Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wPurchase Confirmation``|left|1366|\nadd_spacer|small|\nadd_spacer|small|\nadd_textbox|`4You'll give:``|left|\nadd_spacer|small|\nadd_label_with_icon|small|(`w" + to_string(kiekmoketi) + "``) `8World Locks``|left|242|\nadd_spacer|small|\nadd_textbox|`2You'll get:``|left|\nadd_spacer|small|\nadd_label_with_icon|small|(`w" + to_string(buyprice) + "``) `2" + getItemDef(world->items.at(x + (y * world->width)).vid).name + "``|left|" + to_string(world->items.at(x + (y * world->width)).vid) + "|\nadd_spacer|small|\nadd_spacer|small|\nadd_textbox|Are you sure you want to make this purchase?|left|\nend_dialog|digivending_buy|Cancel|OK|");
													break;
												}
											}
											if (isDropDialog) {
												if (world == nullptr || pData->currentWorld == "EXIT" || serverIsFrozen) break;
												if (infoDat.at(0) == "dropitemcount") {
													if (pData->trade) end_trade(peer);
													dropitemcount = infoDat.at(1);
													if (dropitemcount.size() > 3 || dropitemcount.size() <= 0) break;
													if (world->DisableDrop && pData->rawName != world->owner && !isMod(peer)) {
														Player::OnTextOverlay(peer, "Dropping is disabled here!");
														break;
													}
													auto x = atoi(dropitemcount.c_str());
													short int currentItemCount = 0;
													for (auto i = 0; i < pData->inventory.items.size(); i++) {
														if (pData->inventory.items.at(i).itemID == pData->lastdropitem) {
															currentItemCount = static_cast<unsigned int>(pData->inventory.items.at(i).itemCount);
															break;
														}
													}
													if (x <= 0 || x > currentItemCount) break;
													auto iscontainseas = false;
													SearchInventoryItem(peer, pData->lastdropitem, 1, iscontainseas);
													if (!iscontainseas) break;
													else
													{
														bool found_one = false;
														auto cctv = std::experimental::filesystem::exists("save/cctv/_" + ((PlayerInfo*)(peer->data))->currentWorld + ".json");
														for (int i = 0; i < world->width * world->height; i++) {
															if (world->items.at(i).foreground == 1436 && cctv) {
																found_one = true;
															}
														}
														if (found_one) {
															ifstream ifff("save/cctv/_" + ((PlayerInfo*)(peer->data))->currentWorld + ".json");
															json j;
															ifff >> j;
															ifff.close();
															if (j["ShowItemDrop"] == true && j["DontShowOwner"] == true && j["DontShowAdmin"] == true) {
																if (!isWorldOwner(peer, world) || !isWorldAdmin(peer, world)) {
																	vector<string> currentLogs;
																	for (int i = 0; i < j["logs"].size(); i++) {
																		currentLogs.push_back(j["logs"][i]);
																	}
																	time_t currentTime; struct tm* localTime; char buffer[80]; time(&currentTime); localTime = localtime(&currentTime);
																	int Mon = localTime->tm_mon + 1; int Day = localTime->tm_mday; int Hour = localTime->tm_hour; int Min = localTime->tm_min; int Sec = localTime->tm_sec;
																	string tolog = "`w" + ((PlayerInfo*)(peer->data))->displayName + "`w dropped " + to_string(x) + " " + getItemDef(((PlayerInfo*)(peer->data))->lastdropitem).name + " at " + to_string(Hour) + ":" + to_string(Min) + " on " + to_string(Mon) + "/" + to_string(Day) + "";
																	currentLogs.push_back(tolog);
																	j["logs"] = currentLogs;
																	ofstream fs("save/cctv/_" + ((PlayerInfo*)(peer->data))->currentWorld + ".json");
																	fs << j;
																	fs.close();
																}
															}
															else if (j["ShowItemDrop"] == true && j["DontShowOwner"] == true) {
																if (!isWorldOwner(peer, world)) {
																	vector<string> currentLogs;
																	for (int i = 0; i < j["logs"].size(); i++) {
																		currentLogs.push_back(j["logs"][i]);
																	}
																	time_t currentTime; struct tm* localTime; char buffer[80]; time(&currentTime); localTime = localtime(&currentTime);
																	int Mon = localTime->tm_mon + 1; int Day = localTime->tm_mday; int Hour = localTime->tm_hour; int Min = localTime->tm_min; int Sec = localTime->tm_sec;
																	string tolog = "`w" + ((PlayerInfo*)(peer->data))->displayName + "`w dropped " + to_string(x) + " " + getItemDef(((PlayerInfo*)(peer->data))->lastdropitem).name + " at " + to_string(Hour) + ":" + to_string(Min) + " on " + to_string(Mon) + "/" + to_string(Day) + "";
																	currentLogs.push_back(tolog);
																	j["logs"] = currentLogs;
																	ofstream fs("save/cctv/_" + ((PlayerInfo*)(peer->data))->currentWorld + ".json");
																	fs << j;
																	fs.close();
																}
															}
															else if (j["ShowItemDrop"] == true && j["DontShowAdmin"] == true) {
																if (!isWorldAdmin(peer, world)) {
																	vector<string> currentLogs;
																	for (int i = 0; i < j["logs"].size(); i++) {
																		currentLogs.push_back(j["logs"][i]);
																	}
																	time_t currentTime; struct tm* localTime; char buffer[80]; time(&currentTime); localTime = localtime(&currentTime);
																	int Mon = localTime->tm_mon + 1; int Day = localTime->tm_mday; int Hour = localTime->tm_hour; int Min = localTime->tm_min; int Sec = localTime->tm_sec;
																	string tolog = "`w" + ((PlayerInfo*)(peer->data))->displayName + "`w dropped " + to_string(x) + " " + getItemDef(((PlayerInfo*)(peer->data))->lastdropitem).name + " at " + to_string(Hour) + ":" + to_string(Min) + " on " + to_string(Mon) + "/" + to_string(Day) + "";
																	currentLogs.push_back(tolog);
																	j["logs"] = currentLogs;
																	ofstream fs("save/cctv/_" + ((PlayerInfo*)(peer->data))->currentWorld + ".json");
																	fs << j;
																	fs.close();
																}
															}
															else if (j["ShowItemDrop"] == false && j["DontShowOwner"] == false && j["DontShowAdmin"] == false || j["ShowItemDrop"] == false && j["DontShowOwner"] == false || j["ShowItemDrop"] == false && j["DontShowAdmin"] == false || j["ShowItemDrop"] == false && j["DontShowAdmin"] == true || j["ShowItemDrop"] == false && j["DontShowOwner"] == true || j["ShowItemDrop"] == false && j["DontShowOwner"] == true && j["DontShowAdmin"] == true) {
															}
															else {
																vector<string> currentLogs;
																for (int i = 0; i < j["logs"].size(); i++) {
																	currentLogs.push_back(j["logs"][i]);
																}
																time_t currentTime; struct tm* localTime; char buffer[80]; time(&currentTime); localTime = localtime(&currentTime);
																int Mon = localTime->tm_mon + 1; int Day = localTime->tm_mday; int Hour = localTime->tm_hour; int Min = localTime->tm_min; int Sec = localTime->tm_sec;
																string tolog = "`w" + ((PlayerInfo*)(peer->data))->displayName + "`w dropped " + to_string(x) + " " + getItemDef(((PlayerInfo*)(peer->data))->lastdropitem).name + " at " + to_string(Hour) + ":" + to_string(Min) + " on " + to_string(Mon) + "/" + to_string(Day) + "";
																currentLogs.push_back(tolog);
																j["logs"] = currentLogs;
																ofstream fs("save/cctv/_" + ((PlayerInfo*)(peer->data))->currentWorld + ".json");
																fs << j;
																fs.close();
															}
														}
														if (pData->lastdropitem == 6260 || getItemDef(pData->lastdropitem).properties || pData->lastdropitem == 18 || pData->lastdropitem == 32 || pData->lastdropitem == 6336 || pData->lastdropitem == 1794 || pData->lastdropitem == 5640 || pData->lastdropitem == 1424 || pData->lastdropitem == 6260) {
															if (!isDev(peer) && !isPlayer(peer) && !pData->Subscriber || pData->lastdropitem == 18 || pData->lastdropitem == 5640 || pData->lastdropitem == 32 || pData->lastdropitem == 6336 || pData->lastdropitem == 1486 || pData->lastdropitem == 1794 || pData->lastdropitem == 1424 || pData->lastdropitem == 6260) {
																Player::OnTextOverlay(peer, "You can't drop that.");
																break;
															}
														}
														if (getItemDef(pData->lastdropitem).blockType == BlockTypes::FISH && x != currentItemCount) break;
														if (!isWorldOwner(peer, world) && !isWorldAdmin(peer, world) && isMod(peer) && world->owner != "") {
															LogAccountActivity(pData->rawName, pData->rawName, "Drop " + to_string(x) + " " + getItemDef(pData->lastdropitem).name + " (" + world->name + ")");
														}
														auto xx = pData->x + (32 * (pData->isRotatedLeft ? -1 : 1));
														auto yy = pData->y;
														RemoveInventoryItem(pData->lastdropitem, x, peer, true);
														updateplayerset(peer, pData->lastdropitem);
														if (world->name == "GROWGANOTH" && GrowganothEvent && yy / 32 == 15 && pData->x / 32 >= 48 && pData->x / 32 <= 51) {
															SendSacrifice(world, peer, pData->lastdropitem, x);
															continue;
														}

														if (world->name != "EXIT" && pData->isIn) {
															DropItem(world, peer, -1, xx, yy + (rand() % 16), pData->lastdropitem, x, 0);
														}
													}
													pData->lastdropitem = 0;
												}
											}
											if (isTrashDialog || trashitem2) {
												if (world == nullptr || pData->currentWorld == "EXIT" || serverIsFrozen) break;
												if (infoDat.at(0) == "trashitemcount" || trashitem2) {
													if (pData->trade) end_trade(peer);
													if (!trashitem2) {
														trashitemcount = infoDat.at(1);
													} else {
														trashitemcount = to_string(pData->lasttrashitemcount);
													}
													if (trashitemcount.size() > 3 || trashitemcount.size() <= 0 || pData->lasttrashitem == 0) break;
													if (getItemDef(pData->lasttrashitem).properties & Property_Untradable && pData->lasttrashitemcount == 0) {
														pData->lasttrashitemcount = atoi(trashitemcount.c_str());
														Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`4Recycle`` " + trashitemcount + " `w" + getItemDef(pData->lasttrashitem).name + "``|left|" + to_string(pData->lasttrashitem) + "|\nadd_textbox|You are recycling an `9UNTRADEABLE`` item. Are you absolutely sure you want to do this? There is no way to get the item back if you select yes.|left|\nend_dialog|trash_item2|NO!|Yes, I am sure|");
														break;
													}
													auto gemtrashcount = 0;
													auto x = atoi(trashitemcount.c_str());
													short int currentItemCount = 0;
													for (auto i = 0; i < pData->inventory.items.size(); i++) {
														if (pData->inventory.items.at(i).itemID == pData->lasttrashitem) {
															currentItemCount = static_cast<unsigned int>(pData->inventory.items.at(i).itemCount);
															break;
														}
													}
													if (x <= 0 || x > currentItemCount) break;
													if (!isDev(peer)) {
														auto iscontainseas = false;
														SearchInventoryItem(peer, pData->lasttrashitem, 1, iscontainseas);
														if (!iscontainseas) break;
													}
													if (getItemDef(pData->lasttrashitem).blockType == BlockTypes::FISH && x != currentItemCount) break;
													if (getItemDef(pData->lasttrashitem).blockType == BlockTypes::FISH) {
														gemtrashcount = (rand() % 4 + 1) * x;
													}
													Player::OnConsoleMessage(peer, "`w" + std::to_string(x) + " " + getItemDef(pData->lasttrashitem).name + " `orecycled, `w" + std::to_string(gemtrashcount) + " `ogems earned.");
													RemoveInventoryItem(pData->lasttrashitem, x, peer, true);
													sendSound(peer, "trash.wav");
													updateplayerset(peer, pData->lasttrashitem);
													std::ifstream ifsz("save/gemdb/_" + pData->rawName + ".txt");
													std::string content((std::istreambuf_iterator<char>(ifsz)), (std::istreambuf_iterator<char>()));
													auto gembux = atoi(content.c_str());
													auto fingembux = gembux + gemtrashcount;
													ofstream myfile;
													myfile.open("save/gemdb/_" + pData->rawName + ".txt");
													myfile << fingembux;
													myfile.close();
													int gemcalc = gembux + gemtrashcount;
													Player::OnSetBux(peer, gemcalc, 0);
													pData->lasttrashitem = 0;
													pData->lasttrashitemcount = 0;
												}
											}
											if (SurgeryDialog) {
												if (world == nullptr || pData->currentWorld == "EXIT" || pData->SurgeryCooldown) break;
												bool HardToSeeWork = pData->HardToSee;
												bool PatientLosingBlood = pData->PatientLosingBlood;
												string WorkSee = "";
												string LosingBlood = "";
												if (infoDat.at(1) == "Surgical Anesthetic" || infoDat.at(1) == "Surgical Antiseptic" || infoDat.at(1) == "Surgical Stitches" || infoDat.at(1) == "Surgical Pins" || infoDat.at(1) == "Surgical Transfusion" || infoDat.at(1) == "Surgical Defibrillator" || infoDat.at(1) == "Surgical Clamp")
												{
													Player::OnTextOverlay(peer, "This surgery tool isnt available yet!");
													stringstream Temperaturas;
													Temperaturas << pData->PatientTemperature;
													auto PTemp = Temperaturas.str();
													if (HardToSeeWork) WorkSee = "\nadd_smalltext|`6It is becoming hard to see your work.``|left|";
													if (PatientLosingBlood) LosingBlood = "\nadd_smalltext|Patient is losing blood `3slowly.``|left|";
													if (pData->PerformingSurgery) Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wSurg-E``|left|18|\nadd_smalltext|" + pData->PatientDiagnosis + ".``|left|\nadd_smalltext|Pulse: " + pData->PatientPulse + "``    Status: " + pData->PatientStatus + "``|left|\nadd_smalltext|Temp: " + pData->TempColor + PTemp + "``    Operation site: " + pData->OperationSite + "``|left|" + WorkSee + "\nadd_smalltext|Incisions: " + pData->IncisionsColor + to_string(pData->PatientIncisions) + "``    |left|" + LosingBlood + "\nadd_spacer|small|\nadd_smalltext|`3The patient is prepped for surgery.``|left|\ntext_scaling_string|Defibrillator|\nadd_button_with_icon|" + getItemDef(pData->SurgItem1).name + "||noflags|" + to_string(pData->SurgItem1) + "|" + GetItemCount(peer, pData->SurgItem1) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem2).name + "||noflags|" + to_string(pData->SurgItem2) + "|" + GetItemCount(peer, pData->SurgItem2) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem3).name + "||noflags|" + to_string(pData->SurgItem3) + "|" + GetItemCount(peer, pData->SurgItem3) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem4).name + "||noflags|" + to_string(pData->SurgItem4) + "|" + GetItemCount(peer, pData->SurgItem4) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem5).name + "||noflags|" + to_string(pData->SurgItem5) + "|" + GetItemCount(peer, pData->SurgItem5) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem6).name + "||noflags|" + to_string(pData->SurgItem6) + "|" + GetItemCount(peer, pData->SurgItem6) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem7).name + "||noflags|" + to_string(pData->SurgItem7) + "|" + GetItemCount(peer, pData->SurgItem7) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem8).name + "||noflags|" + to_string(pData->SurgItem8) + "|" + GetItemCount(peer, pData->SurgItem8) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem9).name + "||noflags|" + to_string(pData->SurgItem9) + "|" + GetItemCount(peer, pData->SurgItem9) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem10).name + "||noflags|" + to_string(pData->SurgItem10) + "|" + GetItemCount(peer, pData->SurgItem10) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem11).name + "||noflags|" + to_string(pData->SurgItem11) + "|" + GetItemCount(peer, pData->SurgItem11) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem12).name + "||noflags|" + to_string(pData->SurgItem12) + "|" + GetItemCount(peer, pData->SurgItem12) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem13).name + "||noflags|" + to_string(pData->SurgItem13) + "|" + GetItemCount(peer, pData->SurgItem13) + "|\nadd_button_with_icon|Empty Surgery Tray||noflags|4320||\nadd_button_with_icon|Empty Surgery Tray||noflags|4320||\nadd_button_with_icon||END_LIST|noflags|0||\nadd_button|cancel|Give up!|noflags|0|0|\nend_dialog|surge|||");
													continue;
												}
												if (pData->PatientDiagnosis != "")
												{
													float temperatura2 = pData->PatientTemperature;
													temperatura2 += pData->PatientTemperatureRise;
													if (temperatura2 >= 113)
													{

														end_surgery(peer, true);
														break;
													}
													if (temperatura2 >= 109)
													{
														pData->TempColor = "`4";
													}
													else if (temperatura2 >= 106)
													{
														pData->TempColor = "`3";
													}
													else
													{
														pData->TempColor = "`2";
													}

													float test = temperatura2;
													float value = (int)(test * 100 + .5);
													float newvalue = (float)value / 100;
													pData->PatientTemperature = newvalue;

												}
												if (infoDat.at(1) == "Surgical Lab Kit")
												{
													auto contains = false;
													SearchInventoryItem(peer, 4318, 1, contains);
													if (!contains)
													{
														break;
													}
													RemoveInventoryItem(4318, 1, peer, true);
													auto KiekTuri = 0;
													for (auto i = 0; i < pData->inventory.items.size(); i++)
													{
														if (pData->inventory.items.at(i).itemID == 4318 && pData->inventory.items.at(i).itemCount >= 1)
														{
															KiekTuri = pData->inventory.items.at(i).itemCount;
															break;
														}
													}
													if (KiekTuri <= 0) UpdateSurgeryItems(peer);



													string Notification = "`3The patient is prepped for surgery.";
													if (surgery_skill_fail(peer))
													{
														Notification = "`3[`4Skill Fail`3] `6You contaminated the sample.";
													}
													else
													{
														Notification = "";
														pData->UnlockedAntibiotic = true;
														UpdateSurgeryItems(peer);
													}



													stringstream Temperaturas;
													Temperaturas << pData->PatientTemperature;
													auto PTemp = Temperaturas.str();
													if (HardToSeeWork) WorkSee = "\nadd_smalltext|`6It is becoming hard to see your work.``|left|";
													if (PatientLosingBlood) LosingBlood = "\nadd_smalltext|Patient is losing blood `3slowly.``|left|";
													if (pData->PerformingSurgery) Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wSurg-E``|left|18|\nadd_smalltext|" + pData->PatientDiagnosis + ".``|left|\nadd_smalltext|Pulse: " + pData->PatientPulse + "``    Status: " + pData->PatientStatus + "``|left|\nadd_smalltext|Temp: " + pData->TempColor + PTemp + "``    Operation site: " + pData->OperationSite + "``|left|" + WorkSee + "\nadd_smalltext|Incisions: " + pData->IncisionsColor + to_string(pData->PatientIncisions) + "``    |left|" + LosingBlood + "\nadd_spacer|small|\nadd_smalltext|" + Notification + "``|left|\ntext_scaling_string|Defibrillator|\nadd_button_with_icon|" + getItemDef(pData->SurgItem1).name + "||noflags|" + to_string(pData->SurgItem1) + "|" + GetItemCount(peer, pData->SurgItem1) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem2).name + "||noflags|" + to_string(pData->SurgItem2) + "|" + GetItemCount(peer, pData->SurgItem2) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem3).name + "||noflags|" + to_string(pData->SurgItem3) + "|" + GetItemCount(peer, pData->SurgItem3) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem4).name + "||noflags|" + to_string(pData->SurgItem4) + "|" + GetItemCount(peer, pData->SurgItem4) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem5).name + "||noflags|" + to_string(pData->SurgItem5) + "|" + GetItemCount(peer, pData->SurgItem5) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem6).name + "||noflags|" + to_string(pData->SurgItem6) + "|" + GetItemCount(peer, pData->SurgItem6) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem7).name + "||noflags|" + to_string(pData->SurgItem7) + "|" + GetItemCount(peer, pData->SurgItem7) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem8).name + "||noflags|" + to_string(pData->SurgItem8) + "|" + GetItemCount(peer, pData->SurgItem8) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem9).name + "||noflags|" + to_string(pData->SurgItem9) + "|" + GetItemCount(peer, pData->SurgItem9) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem10).name + "||noflags|" + to_string(pData->SurgItem10) + "|" + GetItemCount(peer, pData->SurgItem10) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem11).name + "||noflags|" + to_string(pData->SurgItem11) + "|" + GetItemCount(peer, pData->SurgItem11) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem12).name + "||noflags|" + to_string(pData->SurgItem12) + "|" + GetItemCount(peer, pData->SurgItem12) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem13).name + "||noflags|" + to_string(pData->SurgItem13) + "|" + GetItemCount(peer, pData->SurgItem13) + "|\nadd_button_with_icon|nulltool||noflags|4320||\nadd_button_with_icon|nulltool||noflags|4320||\nadd_button_with_icon||END_LIST|noflags|0||\nadd_button|cancel|Give up!|noflags|0|0|\nend_dialog|surge|||");

												}
												if (infoDat.at(1) == "Fix it")
												{
													string Notification = "`3The patient is prepped for surgery.";
													if (surgery_skill_fail(peer))
													{
														Notification = "`3[`4Skill Fail`3] `6You screwed it up! Try again.";
														stringstream Temperaturas;
														Temperaturas << pData->PatientTemperature;
														auto PTemp = Temperaturas.str();

														if (HardToSeeWork) WorkSee = "\nadd_smalltext|`6It is becoming hard to see your work.``|left|";
														if (PatientLosingBlood) LosingBlood = "\nadd_smalltext|Patient is losing blood `3slowly.``|left|";
														if (pData->PerformingSurgery) Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wSurg-E``|left|18|\nadd_smalltext|" + pData->PatientDiagnosis + ".``|left|\nadd_smalltext|Pulse: " + pData->PatientPulse + "``    Status: " + pData->PatientStatus + "``|left|\nadd_smalltext|Temp: " + pData->TempColor + PTemp + "``    Operation site: " + pData->OperationSite + "``|left|" + WorkSee + "\nadd_smalltext|Incisions: " + pData->IncisionsColor + to_string(pData->PatientIncisions) + "``    |left|" + LosingBlood + "\nadd_spacer|small|\nadd_smalltext|" + Notification + "``|left|\ntext_scaling_string|Defibrillator|\nadd_button_with_icon|" + getItemDef(pData->SurgItem1).name + "||noflags|" + to_string(pData->SurgItem1) + "|" + GetItemCount(peer, pData->SurgItem1) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem2).name + "||noflags|" + to_string(pData->SurgItem2) + "|" + GetItemCount(peer, pData->SurgItem2) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem3).name + "||noflags|" + to_string(pData->SurgItem3) + "|" + GetItemCount(peer, pData->SurgItem3) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem4).name + "||noflags|" + to_string(pData->SurgItem4) + "|" + GetItemCount(peer, pData->SurgItem4) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem5).name + "||noflags|" + to_string(pData->SurgItem5) + "|" + GetItemCount(peer, pData->SurgItem5) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem6).name + "||noflags|" + to_string(pData->SurgItem6) + "|" + GetItemCount(peer, pData->SurgItem6) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem7).name + "||noflags|" + to_string(pData->SurgItem7) + "|" + GetItemCount(peer, pData->SurgItem7) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem8).name + "||noflags|" + to_string(pData->SurgItem8) + "|" + GetItemCount(peer, pData->SurgItem8) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem9).name + "||noflags|" + to_string(pData->SurgItem9) + "|" + GetItemCount(peer, pData->SurgItem9) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem10).name + "||noflags|" + to_string(pData->SurgItem10) + "|" + GetItemCount(peer, pData->SurgItem10) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem11).name + "||noflags|" + to_string(pData->SurgItem11) + "|" + GetItemCount(peer, pData->SurgItem11) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem12).name + "||noflags|" + to_string(pData->SurgItem12) + "|" + GetItemCount(peer, pData->SurgItem12) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem13).name + "||noflags|" + to_string(pData->SurgItem13) + "|" + GetItemCount(peer, pData->SurgItem13) + "|\nadd_button_with_icon|nulltool||noflags|4320||\nadd_button_with_icon|nulltool||noflags|4320||\nadd_button_with_icon||END_LIST|noflags|0||\nadd_button|cancel|Give up!|noflags|0|0|\nend_dialog|surge|||");
													}
													else
													{

														Notification = "";
														if (pData->PatientRealDiagnosis == "nose job")
														{
															complete_surgery(peer);
															break;
														}
													}
												}
												if (infoDat.at(1) == "Surgical Antibiotics")
												{
													auto contains = false;
													SearchInventoryItem(peer, 1266, 1, contains);
													if (!contains)
													{
														break;
													}
													RemoveInventoryItem(1266, 1, peer, true);
													auto KiekTuri = 0;
													for (auto i = 0; i < pData->inventory.items.size(); i++)
													{
														if (pData->inventory.items.at(i).itemID == 1266 && pData->inventory.items.at(i).itemCount >= 1)
														{
															KiekTuri = pData->inventory.items.at(i).itemCount;
															break;
														}
													}
													if (KiekTuri <= 0) UpdateSurgeryItems(peer);

													string Notification = "`3The patient is prepped for surgery.";
													if (surgery_skill_fail(peer))
													{
														Notification = "`3[`4Skill Fail`3] `6This is the wrong medication! The bacteria like it.";
													}
													else
													{
														Notification = "";

														float temperatura2 = pData->PatientTemperature;
														temperatura2 -= 2.6;
														if (temperatura2 <= 100)
														{

															end_surgery(peer, true);

															break;
														}
														if (temperatura2 >= 109)
														{
															pData->TempColor = "`4";
														}
														else if (temperatura2 >= 106)
														{
															pData->TempColor = "`3";
														}
														else if (temperatura2 < 106)
														{
															pData->TempColor = "`2";
														}
														if (temperatura2 <= 105.5)
														{
															pData->TempColor = "`2";
															if (pData->PatientRealDiagnosis == "monkey flu" || pData->PatientRealDiagnosis == "turtle flu" || pData->PatientRealDiagnosis == "bird flu")
															{
																complete_surgery(peer);
																break;
															}
															else if (temperatura2 <= 105)
															{
																end_surgery(peer, true);
																break;
															}
															pData->TempColor = "`6";
														}

														float test = temperatura2;
														float value = (int)(test * 100 + .5);
														float sss = (float)value / 100;
														pData->PatientTemperature = sss;

													}

													stringstream Temperaturas;
													Temperaturas << pData->PatientTemperature;
													auto PTemp = Temperaturas.str();

													if (HardToSeeWork) WorkSee = "\nadd_smalltext|`6It is becoming hard to see your work.``|left|";
													if (PatientLosingBlood) LosingBlood = "\nadd_smalltext|Patient is losing blood `3slowly.``|left|";
													if (pData->PerformingSurgery) Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wSurg-E``|left|18|\nadd_smalltext|" + pData->PatientDiagnosis + ".``|left|\nadd_smalltext|Pulse: " + pData->PatientPulse + "``    Status: " + pData->PatientStatus + "``|left|\nadd_smalltext|Temp: " + pData->TempColor + PTemp + "``    Operation site: " + pData->OperationSite + "``|left|" + WorkSee + "\nadd_smalltext|Incisions: " + pData->IncisionsColor + to_string(pData->PatientIncisions) + "``    |left|" + LosingBlood + "\nadd_spacer|small|\nadd_smalltext|" + Notification + "``|left|\ntext_scaling_string|Defibrillator|\nadd_button_with_icon|" + getItemDef(pData->SurgItem1).name + "||noflags|" + to_string(pData->SurgItem1) + "|" + GetItemCount(peer, pData->SurgItem1) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem2).name + "||noflags|" + to_string(pData->SurgItem2) + "|" + GetItemCount(peer, pData->SurgItem2) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem3).name + "||noflags|" + to_string(pData->SurgItem3) + "|" + GetItemCount(peer, pData->SurgItem3) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem4).name + "||noflags|" + to_string(pData->SurgItem4) + "|" + GetItemCount(peer, pData->SurgItem4) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem5).name + "||noflags|" + to_string(pData->SurgItem5) + "|" + GetItemCount(peer, pData->SurgItem5) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem6).name + "||noflags|" + to_string(pData->SurgItem6) + "|" + GetItemCount(peer, pData->SurgItem6) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem7).name + "||noflags|" + to_string(pData->SurgItem7) + "|" + GetItemCount(peer, pData->SurgItem7) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem8).name + "||noflags|" + to_string(pData->SurgItem8) + "|" + GetItemCount(peer, pData->SurgItem8) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem9).name + "||noflags|" + to_string(pData->SurgItem9) + "|" + GetItemCount(peer, pData->SurgItem9) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem10).name + "||noflags|" + to_string(pData->SurgItem10) + "|" + GetItemCount(peer, pData->SurgItem10) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem11).name + "||noflags|" + to_string(pData->SurgItem11) + "|" + GetItemCount(peer, pData->SurgItem11) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem12).name + "||noflags|" + to_string(pData->SurgItem12) + "|" + GetItemCount(peer, pData->SurgItem12) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem13).name + "||noflags|" + to_string(pData->SurgItem13) + "|" + GetItemCount(peer, pData->SurgItem13) + "|\nadd_button_with_icon|nulltool||noflags|4320||\nadd_button_with_icon|nulltool||noflags|4320||\nadd_button_with_icon||END_LIST|noflags|0||\nadd_button|cancel|Give up!|noflags|0|0|\nend_dialog|surge|||");
												}
												if (infoDat.at(1) == "Surgical Sponge")
												{
													auto contains = false;
													SearchInventoryItem(peer, 1258, 1, contains);
													if (!contains)
													{
														break;
													}
													RemoveInventoryItem(1258, 1, peer, true);
													auto KiekTuri = 0;
													for (auto i = 0; i < pData->inventory.items.size(); i++)
													{
														if (pData->inventory.items.at(i).itemID == 1258 && pData->inventory.items.at(i).itemCount >= 1)
														{
															KiekTuri = pData->inventory.items.at(i).itemCount;
															break;
														}
													}
													if (KiekTuri <= 0) UpdateSurgeryItems(peer);

													string Notification = "`3The patient is prepped for surgery.";
													if (surgery_skill_fail(peer))
													{
														Notification = "`3[`4Skill Fail`3] `6You somehow managed to eat the sponge.";
													}
													else
													{
														Notification = "";
														if (pData->HardToSee)
														{
															pData->HardToSee = false;
															HardToSeeWork = false;
														}
													}

													stringstream Temperaturas;
													Temperaturas << pData->PatientTemperature;
													auto PTemp = Temperaturas.str();
													if (HardToSeeWork) WorkSee = "\nadd_smalltext|`6It is becoming hard to see your work.``|left|";
													if (PatientLosingBlood) LosingBlood = "\nadd_smalltext|Patient is losing blood `3slowly.``|left|";
													if (pData->PerformingSurgery) Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wSurg-E``|left|18|\nadd_smalltext|" + pData->PatientDiagnosis + ".``|left|\nadd_smalltext|Pulse: " + pData->PatientPulse + "``    Status: " + pData->PatientStatus + "``|left|\nadd_smalltext|Temp: " + pData->TempColor + PTemp + "``    Operation site: " + pData->OperationSite + "``|left|" + WorkSee + "\nadd_smalltext|Incisions: " + pData->IncisionsColor + to_string(pData->PatientIncisions) + "``    |left|" + LosingBlood + "\nadd_spacer|small|\nadd_smalltext|" + Notification + "``|left|\ntext_scaling_string|Defibrillator|\nadd_button_with_icon|" + getItemDef(pData->SurgItem1).name + "||noflags|" + to_string(pData->SurgItem1) + "|" + GetItemCount(peer, pData->SurgItem1) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem2).name + "||noflags|" + to_string(pData->SurgItem2) + "|" + GetItemCount(peer, pData->SurgItem2) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem3).name + "||noflags|" + to_string(pData->SurgItem3) + "|" + GetItemCount(peer, pData->SurgItem3) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem4).name + "||noflags|" + to_string(pData->SurgItem4) + "|" + GetItemCount(peer, pData->SurgItem4) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem5).name + "||noflags|" + to_string(pData->SurgItem5) + "|" + GetItemCount(peer, pData->SurgItem5) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem6).name + "||noflags|" + to_string(pData->SurgItem6) + "|" + GetItemCount(peer, pData->SurgItem6) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem7).name + "||noflags|" + to_string(pData->SurgItem7) + "|" + GetItemCount(peer, pData->SurgItem7) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem8).name + "||noflags|" + to_string(pData->SurgItem8) + "|" + GetItemCount(peer, pData->SurgItem8) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem9).name + "||noflags|" + to_string(pData->SurgItem9) + "|" + GetItemCount(peer, pData->SurgItem9) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem10).name + "||noflags|" + to_string(pData->SurgItem10) + "|" + GetItemCount(peer, pData->SurgItem10) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem11).name + "||noflags|" + to_string(pData->SurgItem11) + "|" + GetItemCount(peer, pData->SurgItem11) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem12).name + "||noflags|" + to_string(pData->SurgItem12) + "|" + GetItemCount(peer, pData->SurgItem12) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem13).name + "||noflags|" + to_string(pData->SurgItem13) + "|" + GetItemCount(peer, pData->SurgItem13) + "|\nadd_button_with_icon|nulltool||noflags|4320||\nadd_button_with_icon|nulltool||noflags|4320||\nadd_button_with_icon||END_LIST|noflags|0||\nadd_button|cancel|Give up!|noflags|0|0|\nend_dialog|surge|||");
												}
												if (infoDat.at(1) == "Surgical Ultrasound")
												{
													auto contains = false;
													SearchInventoryItem(peer, 4316, 1, contains);
													if (!contains)
													{
														break;
													}
													RemoveInventoryItem(4316, 1, peer, true);
													auto KiekTuri = 0;
													for (auto i = 0; i < pData->inventory.items.size(); i++)
													{
														if (pData->inventory.items.at(i).itemID == 4316 && pData->inventory.items.at(i).itemCount >= 1)
														{
															KiekTuri = pData->inventory.items.at(i).itemCount;
															break;
														}
													}
													if (KiekTuri <= 0) UpdateSurgeryItems(peer);

													string Notification = "`3The patient is prepped for surgery.";
													if (surgery_skill_fail(peer))
													{
														Notification = "`3[`4Skill Fail`3] `6You scanned the nurse with your ultrasound!";
													}
													else
													{

														Notification = "";

														pData->Ultrasound++;

														if (pData->Ultrasound >= 2)
														{
															pData->PatientTemperatureRise = 1.3;
														}

														pData->PatientDiagnosis = "Patient has " + pData->PatientRealDiagnosis + "";
													}

													stringstream Temperaturas;
													Temperaturas << pData->PatientTemperature;
													auto PTemp = Temperaturas.str();
													if (HardToSeeWork) WorkSee = "\nadd_smalltext|`6It is becoming hard to see your work.``|left|";
													if (PatientLosingBlood) LosingBlood = "\nadd_smalltext|Patient is losing blood `3slowly.``|left|";
													if (pData->PerformingSurgery) Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wSurg-E``|left|18|\nadd_smalltext|" + pData->PatientDiagnosis + ".``|left|\nadd_smalltext|Pulse: " + pData->PatientPulse + "``    Status: " + pData->PatientStatus + "``|left|\nadd_smalltext|Temp: " + pData->TempColor + PTemp + "``    Operation site: " + pData->OperationSite + "``|left|" + WorkSee + "\nadd_smalltext|Incisions: " + pData->IncisionsColor + to_string(pData->PatientIncisions) + "``    |left|" + LosingBlood + "\nadd_spacer|small|\nadd_smalltext|" + Notification + "``|left|\ntext_scaling_string|Defibrillator|\nadd_button_with_icon|" + getItemDef(pData->SurgItem1).name + "||noflags|" + to_string(pData->SurgItem1) + "|" + GetItemCount(peer, pData->SurgItem1) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem2).name + "||noflags|" + to_string(pData->SurgItem2) + "|" + GetItemCount(peer, pData->SurgItem2) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem3).name + "||noflags|" + to_string(pData->SurgItem3) + "|" + GetItemCount(peer, pData->SurgItem3) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem4).name + "||noflags|" + to_string(pData->SurgItem4) + "|" + GetItemCount(peer, pData->SurgItem4) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem5).name + "||noflags|" + to_string(pData->SurgItem5) + "|" + GetItemCount(peer, pData->SurgItem5) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem6).name + "||noflags|" + to_string(pData->SurgItem6) + "|" + GetItemCount(peer, pData->SurgItem6) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem7).name + "||noflags|" + to_string(pData->SurgItem7) + "|" + GetItemCount(peer, pData->SurgItem7) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem8).name + "||noflags|" + to_string(pData->SurgItem8) + "|" + GetItemCount(peer, pData->SurgItem8) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem9).name + "||noflags|" + to_string(pData->SurgItem9) + "|" + GetItemCount(peer, pData->SurgItem9) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem10).name + "||noflags|" + to_string(pData->SurgItem10) + "|" + GetItemCount(peer, pData->SurgItem10) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem11).name + "||noflags|" + to_string(pData->SurgItem11) + "|" + GetItemCount(peer, pData->SurgItem11) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem12).name + "||noflags|" + to_string(pData->SurgItem12) + "|" + GetItemCount(peer, pData->SurgItem12) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem13).name + "||noflags|" + to_string(pData->SurgItem13) + "|" + GetItemCount(peer, pData->SurgItem13) + "|\nadd_button_with_icon|nulltool||noflags|4320||\nadd_button_with_icon|nulltool||noflags|4320||\nadd_button_with_icon||END_LIST|noflags|0||\nadd_button|cancel|Give up!|noflags|0|0|\nend_dialog|surge|||");
												}
												if (infoDat.at(1) == "Surgical Scalpel")
												{
													auto contains = false;
													SearchInventoryItem(peer, 1260, 1, contains);
													if (!contains)
													{
														break;
													}
													RemoveInventoryItem(1260, 1, peer, true);
													auto KiekTuri = 0;
													for (auto i = 0; i < pData->inventory.items.size(); i++)
													{
														if (pData->inventory.items.at(i).itemID == 1260 && pData->inventory.items.at(i).itemCount >= 1)
														{
															KiekTuri = pData->inventory.items.at(i).itemCount;
															break;
														}
													}
													if (KiekTuri <= 0) UpdateSurgeryItems(peer);



													string Notification = "`3The patient is prepped for surgery.";
													if (surgery_skill_fail(peer))
													{
														Notification = "`3[`4Skill Fail`3] `6This will leave a nasty scar, but you managed to cut the right place.";
													}
													else
													{

														Notification = "";



														pData->PatientIncisions++;

														if (pData->PatientIncisions == 1 && pData->PatientRealDiagnosis == "nose job")
														{
															pData->IncisionsColor = "`2";
														}
														else if (pData->PatientIncisions == 2 && pData->PatientRealDiagnosis == "nose job")
														{
															pData->IncisionsColor = "`2";
															pData->FixIt = true;
															UpdateSurgeryItems(peer);
														}
														else
														{
															pData->IncisionsColor = "`4";
															pData->PatientTemperatureRise = 1.6;
														}

													}

													stringstream Temperaturas;
													Temperaturas << pData->PatientTemperature;
													auto PTemp = Temperaturas.str();
													if (HardToSeeWork) WorkSee = "\nadd_smalltext|`6It is becoming hard to see your work.``|left|";
													if (PatientLosingBlood) LosingBlood = "\nadd_smalltext|Patient is losing blood `3slowly.``|left|";
													if (pData->PerformingSurgery) Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wSurg-E``|left|18|\nadd_smalltext|" + pData->PatientDiagnosis + ".``|left|\nadd_smalltext|Pulse: " + pData->PatientPulse + "``    Status: " + pData->PatientStatus + "``|left|\nadd_smalltext|Temp: " + pData->TempColor + PTemp + "``    Operation site: " + pData->OperationSite + "``|left|" + WorkSee + "\nadd_smalltext|Incisions: " + pData->IncisionsColor + to_string(pData->PatientIncisions) + "``    |left|" + LosingBlood + "\nadd_spacer|small|\nadd_smalltext|" + Notification + "``|left|\ntext_scaling_string|Defibrillator|\nadd_button_with_icon|" + getItemDef(pData->SurgItem1).name + "||noflags|" + to_string(pData->SurgItem1) + "|" + GetItemCount(peer, pData->SurgItem1) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem2).name + "||noflags|" + to_string(pData->SurgItem2) + "|" + GetItemCount(peer, pData->SurgItem2) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem3).name + "||noflags|" + to_string(pData->SurgItem3) + "|" + GetItemCount(peer, pData->SurgItem3) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem4).name + "||noflags|" + to_string(pData->SurgItem4) + "|" + GetItemCount(peer, pData->SurgItem4) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem5).name + "||noflags|" + to_string(pData->SurgItem5) + "|" + GetItemCount(peer, pData->SurgItem5) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem6).name + "||noflags|" + to_string(pData->SurgItem6) + "|" + GetItemCount(peer, pData->SurgItem6) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem7).name + "||noflags|" + to_string(pData->SurgItem7) + "|" + GetItemCount(peer, pData->SurgItem7) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem8).name + "||noflags|" + to_string(pData->SurgItem8) + "|" + GetItemCount(peer, pData->SurgItem8) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem9).name + "||noflags|" + to_string(pData->SurgItem9) + "|" + GetItemCount(peer, pData->SurgItem9) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem10).name + "||noflags|" + to_string(pData->SurgItem10) + "|" + GetItemCount(peer, pData->SurgItem10) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem11).name + "||noflags|" + to_string(pData->SurgItem11) + "|" + GetItemCount(peer, pData->SurgItem11) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem12).name + "||noflags|" + to_string(pData->SurgItem12) + "|" + GetItemCount(peer, pData->SurgItem12) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem13).name + "||noflags|" + to_string(pData->SurgItem13) + "|" + GetItemCount(peer, pData->SurgItem13) + "|\nadd_button_with_icon|nulltool||noflags|4320||\nadd_button_with_icon|nulltool||noflags|4320||\nadd_button_with_icon||END_LIST|noflags|0||\nadd_button|cancel|Give up!|noflags|0|0|\nend_dialog|surge|||");
												}
												if (infoDat.at(1) == "Empty Surgery Tray")
												{

													stringstream Temperaturas;
													Temperaturas << pData->PatientTemperature;
													auto PTemp = Temperaturas.str();
													if (HardToSeeWork) WorkSee = "\nadd_smalltext|`6It is becoming hard to see your work.``|left|";
													if (PatientLosingBlood) LosingBlood = "\nadd_smalltext|Patient is losing blood `3slowly.``|left|";
													if (pData->PerformingSurgery) Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wSurg-E``|left|18|\nadd_smalltext|" + pData->PatientDiagnosis + ".``|left|\nadd_smalltext|Pulse: " + pData->PatientPulse + "``    Status: " + pData->PatientStatus + "``|left|\nadd_smalltext|Temp: " + pData->TempColor + PTemp + "``    Operation site: " + pData->OperationSite + "``|left|" + WorkSee + "\nadd_smalltext|Incisions: " + pData->IncisionsColor + to_string(pData->PatientIncisions) + "``    |left|" + LosingBlood + "\nadd_spacer|small|\nadd_smalltext|`3The patient is prepped for surgery.``|left|\ntext_scaling_string|Defibrillator|\nadd_button_with_icon|" + getItemDef(pData->SurgItem1).name + "||noflags|" + to_string(pData->SurgItem1) + "|" + GetItemCount(peer, pData->SurgItem1) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem2).name + "||noflags|" + to_string(pData->SurgItem2) + "|" + GetItemCount(peer, pData->SurgItem2) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem3).name + "||noflags|" + to_string(pData->SurgItem3) + "|" + GetItemCount(peer, pData->SurgItem3) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem4).name + "||noflags|" + to_string(pData->SurgItem4) + "|" + GetItemCount(peer, pData->SurgItem4) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem5).name + "||noflags|" + to_string(pData->SurgItem5) + "|" + GetItemCount(peer, pData->SurgItem5) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem6).name + "||noflags|" + to_string(pData->SurgItem6) + "|" + GetItemCount(peer, pData->SurgItem6) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem7).name + "||noflags|" + to_string(pData->SurgItem7) + "|" + GetItemCount(peer, pData->SurgItem7) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem8).name + "||noflags|" + to_string(pData->SurgItem8) + "|" + GetItemCount(peer, pData->SurgItem8) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem9).name + "||noflags|" + to_string(pData->SurgItem9) + "|" + GetItemCount(peer, pData->SurgItem9) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem10).name + "||noflags|" + to_string(pData->SurgItem10) + "|" + GetItemCount(peer, pData->SurgItem10) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem11).name + "||noflags|" + to_string(pData->SurgItem11) + "|" + GetItemCount(peer, pData->SurgItem11) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem12).name + "||noflags|" + to_string(pData->SurgItem12) + "|" + GetItemCount(peer, pData->SurgItem12) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem13).name + "||noflags|" + to_string(pData->SurgItem13) + "|" + GetItemCount(peer, pData->SurgItem13) + "|\nadd_button_with_icon|nulltool||noflags|4320||\nadd_button_with_icon|nulltool||noflags|4320||\nadd_button_with_icon||END_LIST|noflags|0||\nadd_button|cancel|Give up!|noflags|0|0|\nend_dialog|surge|||");
												}
												if (infoDat.at(1) == "cancel")
												{
													end_surgery(peer, true);



													break;
												}
												else if (!pData->PerformingSurgery && pData->RequestedSurgery)
												{
													pData->RequestedSurgery = false;
													vector<string> Diagnosis{ "monkey flu", "bird flu", "turtle flu", "nose job", "nose job", "nose job" };
													pData->PatientRealDiagnosis = Diagnosis[rand() % Diagnosis.size()];
													if (pData->PatientRealDiagnosis == "monkey flu" || pData->PatientRealDiagnosis == "bird flu" || pData->PatientRealDiagnosis == "turtle flu")
													{
														pData->PatientDiagnosis = "`4The patient has not been diagnosed";
														pData->PatientPulse = "`2Strong";
														pData->PatientStatus = "`4Awake";
														pData->PatientTemperatureRise = 0.75;
														float test = 107.6;
														float value = (int)(test * 100 + .5);
														float newvalue = (float)value / 100;
														pData->PatientTemperature = newvalue;
														pData->OperationSite = "`3Not sanitized";
														pData->PatientIncisions = 0;
														pData->IncisionsColor = "`3";
														pData->TempColor = "`3";
														pData->HardToSee = true;
														HardToSeeWork = true;

													}
													else if (pData->PatientRealDiagnosis == "nose job")
													{
														pData->PatientDiagnosis = "`4The patient has not been diagnosed";
														pData->PatientPulse = "`2Strong";
														pData->PatientStatus = "`4Awake";
														pData->PatientTemperatureRise = 0.35;
														float test = 106.5;
														float value = (int)(test * 100 + .5);
														float newvalue = (float)value / 100;
														pData->PatientTemperature = newvalue;
														pData->OperationSite = "`3Not sanitized";
														pData->PatientIncisions = 0;
														pData->IncisionsColor = "`3";
														pData->TempColor = "`3";
														pData->HardToSee = true;
														HardToSeeWork = true;
													}



													pData->PerformingSurgery = true;
													ENetPeer* currentPeer;
													for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer)
													{
														if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
														if (isHere(peer, currentPeer))
														{
															Player::OnConsoleMessage(currentPeer, "`7[```2" + pData->displayName + "`o is performing surgery on Surg-E!`7]``");
															Player::OnTalkBubble(currentPeer, pData->netID, "`7[```2" + pData->displayName + "`w is performing surgery on Surg-E!`7]``", 0, true);
														}
													}

													stringstream Temperaturas;
													Temperaturas << pData->PatientTemperature;
													auto PTemp = Temperaturas.str();
													if (HardToSeeWork) WorkSee = "\nadd_smalltext|`6It is becoming hard to see your work.``|left|";
													if (PatientLosingBlood) LosingBlood = "\nadd_smalltext|Patient is losing blood `3slowly.``|left|";
													if (pData->PerformingSurgery) Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wSurg-E``|left|18|\nadd_smalltext|" + pData->PatientDiagnosis + ".``|left|\nadd_smalltext|Pulse: " + pData->PatientPulse + "``    Status: " + pData->PatientStatus + "``|left|\nadd_smalltext|Temp: " + pData->TempColor + PTemp + "``    Operation site: " + pData->OperationSite + "``|left|" + WorkSee + "\nadd_smalltext|Incisions: " + pData->IncisionsColor + to_string(pData->PatientIncisions) + "``    |left|" + LosingBlood + "\nadd_spacer|small|\nadd_smalltext|`3The patient is prepped for surgery.``|left|\ntext_scaling_string|Defibrillator|\nadd_button_with_icon|" + getItemDef(pData->SurgItem1).name + "||noflags|" + to_string(pData->SurgItem1) + "|" + GetItemCount(peer, pData->SurgItem1) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem2).name + "||noflags|" + to_string(pData->SurgItem2) + "|" + GetItemCount(peer, pData->SurgItem2) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem3).name + "||noflags|" + to_string(pData->SurgItem3) + "|" + GetItemCount(peer, pData->SurgItem3) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem4).name + "||noflags|" + to_string(pData->SurgItem4) + "|" + GetItemCount(peer, pData->SurgItem4) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem5).name + "||noflags|" + to_string(pData->SurgItem5) + "|" + GetItemCount(peer, pData->SurgItem5) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem6).name + "||noflags|" + to_string(pData->SurgItem6) + "|" + GetItemCount(peer, pData->SurgItem6) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem7).name + "||noflags|" + to_string(pData->SurgItem7) + "|" + GetItemCount(peer, pData->SurgItem7) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem8).name + "||noflags|" + to_string(pData->SurgItem8) + "|" + GetItemCount(peer, pData->SurgItem8) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem9).name + "||noflags|" + to_string(pData->SurgItem9) + "|" + GetItemCount(peer, pData->SurgItem9) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem10).name + "||noflags|" + to_string(pData->SurgItem10) + "|" + GetItemCount(peer, pData->SurgItem10) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem11).name + "||noflags|" + to_string(pData->SurgItem11) + "|" + GetItemCount(peer, pData->SurgItem11) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem12).name + "||noflags|" + to_string(pData->SurgItem12) + "|" + GetItemCount(peer, pData->SurgItem12) + "|\nadd_button_with_icon|" + getItemDef(pData->SurgItem13).name + "||noflags|" + to_string(pData->SurgItem13) + "|" + GetItemCount(peer, pData->SurgItem13) + "|\nadd_button_with_icon|Empty Surgery Tray||noflags|4320||\nadd_button_with_icon|Empty Surgery Tray||noflags|4320||\nadd_button_with_icon||END_LIST|noflags|0||\nadd_button|cancel|Give up!|noflags|0|0|\nend_dialog|surge|||");
												}



											}
											if (issafewithdrawConfirmDialog) {
												if (infoDat.at(0).substr(0, 13) == "safewithdraw_") {
													safe_withdrawConfirmCount = infoDat.at(1);
													if (safe_withdrawConfirmCount.size() > 5) break;
													string coord_and_apos = infoDat.at(0).erase(0, 13);
													string::size_type pos = coord_and_apos.find('_');
													if (pos != std::string::npos) {
														safe_withdrawConfirmCoord = coord_and_apos.substr(0, pos);
														coord_and_apos.erase(0, pos + 1);
														safe_withdrawConfirmApos = coord_and_apos;
													}
													else break;
													auto isdbox = std::experimental::filesystem::exists("save/safevault/_" + pData->currentWorld + "/X" + safe_withdrawConfirmCoord + ".json");
													if (!isdbox) break;
													bool contains_non_int3 = !std::regex_match(safe_withdrawConfirmApos, std::regex("^[0-9]+$"));
													if (contains_non_int3 == true) break;
													bool contains_non_int4 = !std::regex_match(safe_withdrawConfirmCount, std::regex("^[0-9]+$"));
													if (contains_non_int4 == true) {
														Player::OnTalkBubble(peer, pData->netID, "Invalid input in amount!", 0, false);
														break;
													}
													safe_withdrawConfirmCountInt = atoi(safe_withdrawConfirmCount.c_str());
													safe_withdrawConfirmAposInt = atoi(safe_withdrawConfirmApos.c_str());
													if (safe_withdrawConfirmCountInt < 1 || safe_withdrawConfirmCountInt > 250) {
														Player::OnTalkBubble(peer, pData->netID, "Invalid input in amount!", 0, false);
														break;
													}



													ifstream ifff("save/safevault/_" + pData->currentWorld + "/X" + safe_withdrawConfirmCoord + ".json");
													json j;
													ifff >> j;
													ifff.close();
													int itemid = 0;
													bool success = true;
													for (int i = 0; i < 20; i++)
													{
														if (j["safe"].at(i)["aposition"] == safe_withdrawConfirmAposInt)
														{
															itemid = j["safe"].at(i)["itemid"];

															if (itemid == 0) break;

															if (safe_withdrawConfirmCountInt > j["safe"].at(i)["itemcount"])
															{
																Player::OnTalkBubble(peer, pData->netID, "You Don't have that many stored!", 0, true);
																break;
															}

															if (CheckItemExists(peer, j["safe"].at(i)["itemid"]))
															{
																int currentlyHave = GetQuantityOfItem(peer, j["safe"].at(i)["itemid"]);
																if (safe_withdrawConfirmCountInt + currentlyHave < 251)
																{
																	SaveItemMoreTimes(j["safe"].at(i)["itemid"], safe_withdrawConfirmCountInt, peer, success, pData->rawName + " withdraw from safe vault");
																}
																else
																{
																	Player::OnTextOverlay(peer, "`4You Don't have enought space.");
																	break;
																}
															}
															else
															{
																if (pData->inventory.items.size() == pData->currentInventorySize)
																{
																	Player::OnTextOverlay(peer, "`4Your inventory is full! You can purchase an inventory upgrade in the shop.");
																	break;
																}

																SaveItemMoreTimes(j["safe"].at(i)["itemid"], safe_withdrawConfirmCountInt, peer, success, pData->rawName + " withdraw from safe vault");
															}

															Player::OnTalkBubble(peer, pData->netID, "`wRemoved " + to_string(safe_withdrawConfirmCountInt) + " " + itemDefs[itemid].name + " from the Safe Vault", 0, true);


															if (j["safe"].at(i)["itemcount"] == safe_withdrawConfirmCountInt)
															{
																j["safe"].at(i)["placedby"] = "There was " + to_string(safe_withdrawConfirmCountInt) + " of " + to_string(itemid) + " item, and " + pData->rawName + " withdrawed them.";
																j["safe"].at(i)["itemid"] = 0;
																j["safe"].at(i)["itemcount"] = 0;
																j["insafe"] = j["insafe"].get<double>() - 1;
															}
															else
															{
																j["safe"].at(i)["itemcount"] = j["safe"].at(i)["itemcount"].get<double>() - safe_withdrawConfirmCountInt;
															}

															ofstream of("save/safevault/_" + pData->currentWorld + "/X" + safe_withdrawConfirmCoord + ".json");
															of << j << std::endl;
															of.close();
															break;
														}
													}
												}
											}
											if (isboxlvl2AddItemDialog)
											{
												if (infoDat.at(0).substr(0, 15) == "boxlvl2deposit_") boxlvl2AddItemDialog = infoDat.at(1);
												if (boxlvl1AddItemDialog.size() > 5) break;
												string coord = infoDat.at(0).substr(15, infoDat.at(0).length() - 1).c_str();
												int itemid = atoi(boxlvl2AddItemDialog.c_str());


												if (itemid < 1 || itemid > maxItems)
												{
													break;
												}
												if (itemid == 18 || itemid == 32 || itemid == 6336 || getItemDef(itemid).properties & Property_Untradable || getItemDef(itemid).blockType == BlockTypes::FISH || itemid == 8552 || itemid == 9472 || itemid == 9482 || itemid == 9356 || itemid == 9492 || itemid == 9498 || itemid == 8774 || itemid == 1790 || itemid == 2592 || itemid == 1784 || itemid == 1792 || itemid == 1794 || itemid == 7734 || itemid == 8306 || itemid == 9458)
												{
													Player::OnTextOverlay(peer, "`4You can't place " + getItemDef(itemid).name + ".");
													break;
												}



												auto issafe = std::experimental::filesystem::exists("save/storageboxlvl2/_" + pData->currentWorld + "/X" + coord + ".json");
												if (!issafe)
												{
													Player::OnTalkBubble(peer, pData->netID, "`4An error occured while getting Storage Box Xtreme - Level 2 info", 0, true);
													break;
												}

												int currentlyHave = 0;
												currentlyHave = GetQuantityOfItem(peer, itemid);

												auto contains = false;
												SearchInventoryItem(peer, itemid, currentlyHave, contains);
												if (!contains)
												{
													break;
												}



												ifstream ifff("save/storageboxlvl2/_" + pData->currentWorld + "/X" + coord + ".json");
												json j;
												ifff >> j;
												ifff.close();

												if (j["instorage"] > 19)
												{
													Player::OnTalkBubble(peer, pData->netID, "`4Storage Box Xtreme - Level 2 is full!", 0, true);
													break;
												}

												GTDialog mysafe;
												mysafe.addLabelWithIcon("`wStorage Box Xtreme - Level 2 info", 6288, LABEL_BIG);
												mysafe.addSmallText("You have " + to_string(currentlyHave) + " " + getItemDef(itemid).name + ". How many to store?");
												mysafe.addInputBox("boxlvl2depositcount_" + coord + "_" + to_string(itemid) + "", "", "", 5);
												mysafe.addSpacer(SPACER_SMALL);
												mysafe.addButton("boxlvl2depositconfirm", "Store items");
												mysafe.addSpacer(SPACER_SMALL);
												mysafe.addQuickExit();
												mysafe.endDialog("Close", "", "Exit");
												Player::OnDialogRequest(peer, mysafe.finishDialog());
											}
											if (isboxlvl3AddItemDialog)
											{
												if (infoDat.at(0).substr(0, 15) == "boxlvl3deposit_") boxlvl3AddItemDialog = infoDat.at(1);
												if (boxlvl1AddItemDialog.size() > 5) break;
												string coord = infoDat.at(0).substr(15, infoDat.at(0).length() - 1).c_str();
												int itemid = atoi(boxlvl3AddItemDialog.c_str());


												if (itemid < 1 || itemid > maxItems)
												{
													break;
												}
												if (itemid == 18 || itemid == 32 || itemid == 6336 || getItemDef(itemid).properties & Property_Untradable || getItemDef(itemid).blockType == BlockTypes::FISH || itemid == 8552 || itemid == 9472 || itemid == 9482 || itemid == 9356 || itemid == 9492 || itemid == 9498 || itemid == 8774 || itemid == 1790 || itemid == 2592 || itemid == 1784 || itemid == 1792 || itemid == 1794 || itemid == 7734 || itemid == 8306 || itemid == 9458)
												{
													Player::OnTextOverlay(peer, "`4You can't place " + getItemDef(itemid).name + ".");
													break;
												}

												auto issafe = std::experimental::filesystem::exists("save/storageboxlvl3/_" + pData->currentWorld + "/X" + coord + ".json");
												if (!issafe)
												{
													Player::OnTalkBubble(peer, pData->netID, "`4An error occured while getting Storage Box Xtreme - Level 3 info", 0, true);
													break;
												}

												int currentlyHave = 0;
												currentlyHave = GetQuantityOfItem(peer, itemid);

												auto contains = false;
												SearchInventoryItem(peer, itemid, currentlyHave, contains);
												if (!contains)
												{
													break;
												}



												ifstream ifff("save/storageboxlvl3/_" + pData->currentWorld + "/X" + coord + ".json");
												json j;
												ifff >> j;
												ifff.close();

												if (j["instorage"] > 19)
												{
													Player::OnTalkBubble(peer, pData->netID, "`4Storage Box Xtreme - Level 3 is full!", 0, true);
													break;
												}

												GTDialog mysafe;
												mysafe.addLabelWithIcon("`wStorage Box Xtreme - Level 3 info", 6290, LABEL_BIG);
												mysafe.addSmallText("You have " + to_string(currentlyHave) + " " + getItemDef(itemid).name + ". How many to store?");
												mysafe.addInputBox("boxlvl3depositcount_" + coord + "_" + to_string(itemid) + "", "", "", 5);
												mysafe.addSpacer(SPACER_SMALL);
												mysafe.addButton("boxlvl3depositconfirm", "Store items");
												mysafe.addSpacer(SPACER_SMALL);
												mysafe.addQuickExit();
												mysafe.endDialog("Close", "", "Exit");
												Player::OnDialogRequest(peer, mysafe.finishDialog());
											}
											if (isboxlvl1AddItemDialog)
											{
												if (infoDat.at(0).substr(0, 15) == "boxlvl1deposit_") boxlvl1AddItemDialog = infoDat.at(1);
												if (boxlvl1AddItemDialog.size() > 5) break;
												string coord = infoDat.at(0).substr(15, infoDat.at(0).length() - 1).c_str();
												int itemid = atoi(boxlvl1AddItemDialog.c_str());


												if (itemid < 1 || itemid > maxItems)
												{
													break;
												}
												if (itemid == 18 || itemid == 32 || itemid == 6336 || getItemDef(itemid).properties & Property_Untradable || getItemDef(itemid).blockType == BlockTypes::FISH || itemid == 8552 || itemid == 9472 || itemid == 9482 || itemid == 9356 || itemid == 9492 || itemid == 9498 || itemid == 8774 || itemid == 1790 || itemid == 2592 || itemid == 1784 || itemid == 1792 || itemid == 1794 || itemid == 7734 || itemid == 8306 || itemid == 9458)
												{
													Player::OnTextOverlay(peer, "`4You can't place " + getItemDef(itemid).name + ".");
													break;
												}

												auto issafe = std::experimental::filesystem::exists("save/storageboxlvl1/_" + pData->currentWorld + "/X" + coord + ".json");
												if (!issafe)
												{
													Player::OnTalkBubble(peer, pData->netID, "`4An error occured while getting Storage Box Xtreme - Level 1 info", 0, true);
													break;
												}

												int currentlyHave = 0;
												currentlyHave = GetQuantityOfItem(peer, itemid);

												auto contains = false;
												SearchInventoryItem(peer, itemid, currentlyHave, contains);
												if (!contains)
												{
													break;
												}



												ifstream ifff("save/storageboxlvl1/_" + pData->currentWorld + "/X" + coord + ".json");
												json j;
												ifff >> j;
												ifff.close();

												if (j["instorage"] > 19)
												{
													Player::OnTalkBubble(peer, pData->netID, "`4Storage Box Xtreme - Level 1 is full!", 0, true);
													break;
												}

												GTDialog mysafe;
												mysafe.addLabelWithIcon("`wStorage Box Xtreme - Level 1 info", 6286, LABEL_BIG);
												mysafe.addSmallText("You have " + to_string(currentlyHave) + " " + getItemDef(itemid).name + ". How many to store?");
												mysafe.addInputBox("boxlvl1depositcount_" + coord + "_" + to_string(itemid) + "", "", "", 5);
												mysafe.addSpacer(SPACER_SMALL);
												mysafe.addButton("boxlvl1depositconfirm", "Store items");
												mysafe.addSpacer(SPACER_SMALL);
												mysafe.addQuickExit();
												mysafe.endDialog("Close", "", "Exit");
												Player::OnDialogRequest(peer, mysafe.finishDialog());
											}
											if (isSafeAddItemDialog)
											{
												if (infoDat.at(0).substr(0, 12) == "safedeposit_") SafeAddItemDialog = infoDat.at(1);
												if (SafeAddItemDialog.size() > 5) break;
												string coord = infoDat.at(0).substr(12, infoDat.at(0).length() - 1).c_str();
												int itemid = atoi(SafeAddItemDialog.c_str());


												if (itemid < 1 || itemid > maxItems)
												{
													break;
												}
												if (itemid == 18 || itemid == 32 || itemid == 6336 || getItemDef(itemid).properties & Property_Untradable || getItemDef(itemid).blockType == BlockTypes::FISH || itemid == 8552 || itemid == 9472 || itemid == 9482 || itemid == 9356 || itemid == 9492 || itemid == 9498 || itemid == 8774 || itemid == 1790 || itemid == 2592 || itemid == 1784 || itemid == 1792 || itemid == 1794 || itemid == 7734 || itemid == 8306 || itemid == 9458)
												{
													Player::OnTextOverlay(peer, "`4You can't place " + getItemDef(itemid).name + ".");
													break;
												}

												auto issafe = std::experimental::filesystem::exists("save/safevault/_" + pData->currentWorld + "/X" + coord + ".json");
												if (!issafe)
												{
													Player::OnTalkBubble(peer, pData->netID, "`4An error occured while getting donation box info.", 0, true);
													break;
												}

												int currentlyHave = 0;
												currentlyHave = GetQuantityOfItem(peer, itemid);

												auto contains = false;
												SearchInventoryItem(peer, itemid, currentlyHave, contains);
												if (!contains)
												{
													break;
												}



												ifstream ifff("save/safevault/_" + pData->currentWorld + "/X" + coord + ".json");
												json j;
												ifff >> j;
												ifff.close();

												if (j["insafe"] > 19)
												{
													Player::OnTalkBubble(peer, pData->netID, "`4Safe Vault is full!", 0, true);
													break;
												}

												GTDialog mysafe;
												mysafe.addLabelWithIcon("`wSafe fault", 8878, LABEL_BIG);
												mysafe.addSmallText("You have " + to_string(currentlyHave) + " " + getItemDef(itemid).name + ". How many to store?");
												mysafe.addInputBox("safedepositcount_" + coord + "_" + to_string(itemid) + "", "", "", 5);
												mysafe.addSpacer(SPACER_SMALL);
												mysafe.addQuickExit();
												mysafe.endDialog("safedepositconfirm", "Store items", "Cancel");
												Player::OnDialogRequest(peer, mysafe.finishDialog());
											}
											if (issafedepositconfirmDialog) {
												if (infoDat.at(0).substr(0, 17) == "safedepositcount_") {
													safedepositcount = infoDat.at(1);
													string coord_and_id = infoDat.at(0).erase(0, 17);
													string::size_type pos = coord_and_id.find('_');
													if (pos != std::string::npos) {
														safedepositcoord = coord_and_id.substr(0, pos);
														coord_and_id.erase(0, pos + 1);
														safedeposititemID = coord_and_id;
													}
													else break;
													auto isdbox = std::experimental::filesystem::exists("save/safevault/_" + pData->currentWorld + "/X" + safedepositcoord + ".json");
													if (!isdbox) break;
													bool contains_non_int3 = !std::regex_match(safedeposititemID, std::regex("^[0-9]+$"));
													if (contains_non_int3 == true) break;
													bool contains_non_int4 = !std::regex_match(safedepositcount, std::regex("^[0-9]+$"));
													if (contains_non_int4 == true) {
														Player::OnTalkBubble(peer, pData->netID, "Invalid input in amount!", 0, false);
														break;
													}
													givesafeitemCountInt = atoi(safedepositcount.c_str());
													givesafeitemItemIDInt = atoi(safedeposititemID.c_str());
													if (givesafeitemItemIDInt < 1 || givesafeitemItemIDInt > maxItems) break;
													if (givesafeitemCountInt < 1 || givesafeitemCountInt > 250) {
														Player::OnTalkBubble(peer, pData->netID, "Invalid input in amount!", 0, false);
														break;
													}



													ifstream ifff("save/safevault/_" + pData->currentWorld + "/X" + safedepositcoord + ".json");
													json j;
													ifff >> j;
													ifff.close();
													if (j["insafe"] > 19) {
														Player::OnTalkBubble(peer, pData->netID, "`4Safe fault is full!", 0, true);
														break;
													}
													bool isContains = false;
													SearchInventoryItem(peer, givesafeitemItemIDInt, givesafeitemCountInt, isContains);
													if (isContains == false) {
														Player::OnTextOverlay(peer, "`4You Don't have enough " + itemDefs[givesafeitemItemIDInt].name + " in your inventory.");
														break;
													}
													j["insafe"] = j["insafe"].get<double>() + 1;
													for (int i = 0; i < 20; i++) {
														if (j["safe"].at(i)["itemid"] == 0) {
															j["safe"].at(i)["itemid"] = givesafeitemItemIDInt;
															j["safe"].at(i)["itemcount"] = givesafeitemCountInt;
															j["safe"].at(i)["placedby"] = pData->rawName;
															Player::OnTalkBubble(peer, pData->netID, "`wStored " + to_string(givesafeitemCountInt) + " " + itemDefs[givesafeitemItemIDInt].name + " `win the Safe Vault", 0, true);
															break;
														}
													}
													ofstream of("save/safevault/_" + pData->currentWorld + "/X" + safedepositcoord + ".json");
													of << j << std::endl;
													of.close();
													RemoveInventoryItem(givesafeitemItemIDInt, givesafeitemCountInt, peer, true);
													updateplayerset(peer, givesafeitemItemIDInt);
												}
											}
											if (signEditor) {
												if (world == nullptr || pData->currentWorld == "EXIT" || serverIsFrozen) continue;
												if (infoDat.at(0) == "signtextas") message321 = infoDat.at(1);
											}
											if (isEntranceDialog) {
												if (infoDat.at(0) == "checkbox_public") {
													entranceresult = infoDat.at(1);
													if (entranceresult != "0" && entranceresult != "1") break;
													if (getItemDef(world->items.at(pData->wrenchx + (pData->wrenchy * world->width)).foreground).blockType != BlockTypes::GATEWAY) break;
													if (isWorldOwner(peer, world) || isWorldAdmin(peer, world) || isMod(peer) || !restricted_area(peer, world, pData->wrenchx, pData->wrenchy)) {
														world->items.at(pData->wrenchx + (pData->wrenchy * world->width)).opened = entranceresult == "0" ? 0 : 1;
														for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
															if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
															if (isHere(peer, currentPeer)) {
																if (isDev(currentPeer) || isWorldOwner(currentPeer, world) || isWorldAdmin(currentPeer, world)) {
																	update_entrance(currentPeer, world->items.at(pData->wrenchx + (pData->wrenchy * world->width)).foreground, pData->wrenchx, pData->wrenchy, true, world->items.at(pData->wrenchx + (pData->wrenchy * world->width)).background);
																}
																else {
																	update_entrance(currentPeer, world->items.at(pData->wrenchx + (pData->wrenchy * world->width)).foreground, pData->wrenchx, pData->wrenchy, world->items.at(pData->wrenchx + (pData->wrenchy * world->width)).opened, world->items.at(pData->wrenchx + (pData->wrenchy * world->width)).background);
																}
															}
														}
														break;
													}
												}
											}
											if (MagUpdateDialog) {
												if (world == nullptr || pData->currentWorld == "EXIT" || serverIsFrozen) continue;
												if (infoDat.at(0) == "checkbox_publicremote") {
													publicremote = infoDat.at(1);
													if (publicremote != "1" && publicremote != "0") break;
													if (isWorldOwner(peer, world) || isMod(peer)) {
														int x = pData->lastPunchX;
														int y = pData->lastPunchY;
														if (publicremote == "1") world->items.at(x + (y * world->width)).rm = true;
														else if (publicremote == "0") world->items.at(x + (y * world->width)).rm = false;
														Player::OnTalkBubble(peer, pData->netID, "Finished!", 0, true);
														break;
													}
												}
												if (infoDat.at(0) == "checkbox_gemcollection") {
													if (infoDat.at(1) == "1") {
														int x = pData->lastPunchX;
														int y = pData->lastPunchY;
														world->items.at(x + (y * world->width)).mid = 112;
														ENetPeer* currentPeer;
														for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
															if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
															if (isHere(peer, currentPeer)) {
																send_item_sucker(currentPeer, 5638, x, y, 112, 0, true, true, world->items.at(x + (y * world->width)).background);
															}
														}
													} else {
														int x = pData->lastPunchX;
														int y = pData->lastPunchY;
														world->items.at(x + (y * world->width)).mid = 0;
														ENetPeer* currentPeer;
														for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
															if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
															if (isHere(peer, currentPeer)) {
																send_item_sucker(currentPeer, 5638, x, y, 0, 0, true, true, world->items.at(x + (y * world->width)).background);
															}
														}
													}
													break;
												}
											}
											if (isgivedonationboxitemConfirm)
											{
												if (world == nullptr || pData->currentWorld == "EXIT" || serverIsFrozen) break;
												if (infoDat.at(0).substr(0, 25) == "givedonationboxitemCount_")
												{
													givedonationboxitemCount = infoDat.at(1);
													string coord_and_id = infoDat.at(0).erase(0, 25);
													string::size_type pos = coord_and_id.find('_');
													if (pos != std::string::npos)
													{
														givedonationboxitemCoord = coord_and_id.substr(0, pos);
														coord_and_id.erase(0, pos + 1);
														givedonationboxitemItemID = coord_and_id;
													}
													else
													{
														break;
													}
													auto isdbox = std::experimental::filesystem::exists("save/donationboxes/_" + pData->currentWorld + "/X" + givedonationboxitemCoord + ".json");
													if (!isdbox)
													{
														Player::OnTalkBubble(peer, pData->netID, "`4An error occured while getting donation box info.", 0, true);
														break;
													}
													bool contains_non_int3 = !std::regex_match(givedonationboxitemItemID, std::regex("^[0-9]+$"));
													if (contains_non_int3 == true)
													{
														break;
													}
													bool contains_non_int4 = !std::regex_match(givedonationboxitemCount, std::regex("^[0-9]+$"));
													if (contains_non_int4 == true)
													{
														Player::OnTalkBubble(peer, pData->netID, "Invalid input in amount!", 0, false);
														break;
													}
													givedonationboxitemCountInt = atoi(givedonationboxitemCount.c_str());
													givedonationboxitemItemIDInt = atoi(givedonationboxitemItemID.c_str());
													if (givedonationboxitemItemIDInt < 1 || givedonationboxitemItemIDInt > maxItems)
													{
														break;
													}

													if (getItemDef(givedonationboxitemItemIDInt).rarity < 2)
													{
														Player::OnTalkBubble(peer, pData->netID, "`4You can donate items higher than 2 rarity!", 0, true);
														break;
													}
													if (givedonationboxitemCountInt < 1 || givedonationboxitemCountInt > 250)
													{
														Player::OnTalkBubble(peer, pData->netID, "Invalid input in amount!", 0, false);
														break;
													}
												}
												if (infoDat.at(0) == "givedonationboxitemNote")
												{
													givedonationboxitemNote = infoDat.at(1);
													if (givedonationboxitemNote.size() < 1 || givedonationboxitemNote.size() > 50)
													{
														Player::OnTextOverlay(peer, "`4The note should be at least 1 letter.");
														break;
													}



													ifstream ifff("save/donationboxes/_" + pData->currentWorld + "/X" + givedonationboxitemCoord + ".json");
													json j;
													ifff >> j;
													ifff.close();
													if (j["donated"] > 19) {
														Player::OnTalkBubble(peer, pData->netID, "`4Donation box is full!", 0, true);
														break;
													}
													bool isContains = false;
													SearchInventoryItem(peer, givedonationboxitemItemIDInt, givedonationboxitemCountInt, isContains);
													if (isContains == false) {
														break;
													}
													RemoveInventoryItem(givedonationboxitemItemIDInt, givedonationboxitemCountInt, peer, true);
													updateplayerset(peer, givedonationboxitemItemIDInt);
													j["donated"] = j["donated"].get<double>() + 1;
													for (int i = 0; i < 20; i++) {
														if (j["donatedItems"].at(i)["itemid"] == 0) {
															j["donatedItems"].at(i)["itemid"] = givedonationboxitemItemIDInt;
															j["donatedItems"].at(i)["itemcount"] = givedonationboxitemCountInt;
															j["donatedItems"].at(i)["sentBy"] = pData->displayName;
															j["donatedItems"].at(i)["note"] = givedonationboxitemNote;
															for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
																if (isHere(peer, currentPeer)) {
																	Player::OnTalkBubble(peer, pData->netID, "`w[`5[`w" + pData->displayName + " `wplaces `5" + to_string(givedonationboxitemCountInt) + " `2" + getItemDef(givedonationboxitemItemIDInt).name + " `winto the " + getItemDef(world->items.at(pData->lastPunchX + (pData->lastPunchY * world->width)).foreground).name + "`5]`w]", 0, true);
																	Player::OnConsoleMessage(currentPeer, "`w[`5[`w" + pData->displayName + " `wplaces `5" + to_string(givedonationboxitemCountInt) + " `2" + getItemDef(givedonationboxitemItemIDInt).name + " `winto the " + getItemDef(world->items.at(pData->lastPunchX + (pData->lastPunchY * world->width)).foreground).name + "`5]`w]");
																	if (pData->lastPunchX >= 0 && pData->lastPunchY >= 0)
																	{
																		SendItemPacket(currentPeer, world->items.at(pData->lastPunchX + (pData->lastPunchY * world->width)).foreground, world->items.at(pData->lastPunchX + (pData->lastPunchY * world->width)).background, pData->lastPunchX, pData->lastPunchY, 1);
																	}
																}
															}
															break;
														}
													}
													ofstream of("save/donationboxes/_" + pData->currentWorld + "/X" + givedonationboxitemCoord + ".json");
													of << j << std::endl;
													of.close();
												}
											}
											if (isaddItemToDonationBox)
											{
												if (world == nullptr || pData->currentWorld == "EXIT" || serverIsFrozen) break;
												if (infoDat.at(0).substr(0, 16) == "addDonationItem_") addItemToDonationBox = infoDat.at(1);
												if (addItemToDonationBox.size() > 5) break;
												string coord = infoDat.at(0).substr(16, infoDat.at(0).length() - 1).c_str();
												int itemid = atoi(addItemToDonationBox.c_str());


												if (itemid < 1 || itemid > maxItems)
												{
													break;
												}
												if (itemid == 18 || itemid == 32 || itemid == 6336 || getItemDef(itemid).properties & Property_Untradable || getItemDef(itemid).blockType == BlockTypes::FISH || itemid == 8552 || itemid == 9472 || itemid == 9482 || itemid == 9356 || itemid == 9492 || itemid == 9498 || itemid == 8774 || itemid == 1790 || itemid == 2592 || itemid == 1784 || itemid == 1792 || itemid == 1794 || itemid == 7734 || itemid == 8306 || itemid == 9458)
												{
													Player::OnTextOverlay(peer, "`4You can't donate " + getItemDef(itemid).name + ".");
													break;
												}

												if (getItemDef(itemid).rarity < 2)
												{
													Player::OnTalkBubble(peer, pData->netID, "`4You can donate items higher than 2 rarity!", 0, true);
													break;
												}

												auto isdbox = std::experimental::filesystem::exists("save/donationboxes/_" + pData->currentWorld + "/X" + coord + ".json");
												if (!isdbox)
												{
													Player::OnTalkBubble(peer, pData->netID, "`4An error occured while getting donation box info.", 0, true);
													break;
												}



												ifstream ifff("save/donationboxes/_" + pData->currentWorld + "/X" + coord + ".json");
												json j;
												ifff >> j;
												ifff.close();

												if (j["donated"] > 19)
												{
													Player::OnTalkBubble(peer, pData->netID, "`4Donation box is full!", 0, true);
													break;
												}

												GTDialog myDbox;
												myDbox.addLabelWithIcon(getItemDef(itemid).name, itemid, LABEL_BIG);
												myDbox.addSmallText("`$How many to put in the box as a gift? (Note: you will `4LOSE `$the items you give!)");
												myDbox.addInputBox("givedonationboxitemCount_" + coord + "_" + to_string(itemid) + "", "Count:", "", 5);
												myDbox.addSpacer(SPACER_SMALL);
												myDbox.addInputBox("givedonationboxitemNote", "Optional Note:", "", 50);

												myDbox.addSpacer(SPACER_SMALL);
												myDbox.addQuickExit();
												myDbox.endDialog("givedonationboxitemConfirm", "`4Give the item(s)", "Cancel");
												Player::OnDialogRequest(peer, myDbox.finishDialog());
											}
											if (isEditPathDialog) {
												if (infoDat.at(0) == "door_id") {
													int x = pData->wrenchsession % world->width;
													int y = pData->wrenchsession / world->width;
													door_id = getStrUpper(infoDat.at(1));
													world->items.at(pData->wrenchsession).currId = door_id;
													if (!isWorldOwner(peer, world) || !isWorldAdmin(peer, world)) {
														updateDoor(peer, world->items.at(pData->wrenchsession).foreground, pData->wrenchsession % world->width, pData->wrenchsession / world->width, world->items.at(pData->wrenchsession).background, door_name == "" ? (door_destination_id == "" ? door_destination_world : door_destination_world + "...") : door_name, world->items.at(x + (y * world->width)).DoorLocked, false);
													}
													else
													{
														updateDoor(peer, world->items.at(pData->wrenchsession).foreground, pData->wrenchsession % world->width, pData->wrenchsession / world->width, world->items.at(pData->wrenchsession).background, door_name == "" ? (door_destination_id == "" ? door_destination_world : door_destination_world + "...") : door_name, false, false);
													}
												}
											}
											if (isEditDoorDialog) {
												if (infoDat.at(0) == "door_target") {
													string a = getStrUpper(infoDat.at(1));
													vector<string> b = explode(":", a);
													if (b.size() == 1) {
														door_destination_world = b.at(0);
													} else if (b.size() > 1) {
														door_destination_world = b.at(0);
														door_destination_id = b.at(1);
														if (door_destination_world == "") {
															door_destination_world = pData->currentWorld;
														}
													}
												}
												if (infoDat.at(0) == "checkbox_locked") {
													locked = infoDat.at(1);
													int x = pData->wrenchsession % world->width;
													int y = pData->wrenchsession / world->width;
													if (atoi(locked.c_str()) == 1) {
														world->items.at(x + (y * world->width)).DoorLocked = false;
														updateDoor(peer, world->items.at(pData->wrenchsession).foreground, pData->wrenchsession % world->width, pData->wrenchsession / world->width, world->items.at(pData->wrenchsession).background, door_name == "" ? (door_destination_id == "" ? door_destination_world : door_destination_world + "...") : door_name, false, false);
													}
													else {
														world->items.at(x + (y * world->width)).DoorLocked = true;
														if (!isWorldOwner(peer, world) || !isWorldAdmin(peer, world)) {
															doorlocked(peer, world->items.at(x + (y * world->width)).foreground, x, y, "`4<Locked>");
															updateDoor(peer, world->items.at(pData->wrenchsession).foreground, pData->wrenchsession % world->width, pData->wrenchsession / world->width, world->items.at(pData->wrenchsession).background, door_name == "" ? (door_destination_id == "" ? door_destination_world : door_destination_world + "...") : door_name, world->items.at(x + (y * world->width)).DoorLocked, false);
														}
													}
												}
												if (infoDat.at(0) == "door_name") {
													int x = pData->wrenchsession % world->width;
													int y = pData->wrenchsession / world->width;
													door_name = infoDat.at(1);
													if (!isWorldOwner(peer, world) || !isWorldAdmin(peer, world)) {
														updateDoor(peer, world->items.at(pData->wrenchsession).foreground, pData->wrenchsession % world->width, pData->wrenchsession / world->width, world->items.at(pData->wrenchsession).background, door_name == "" ? (door_destination_id == "" ? door_destination_world : door_destination_world + "...") : door_name, world->items.at(x + (y * world->width)).DoorLocked, false);
													}
													else
													{
														if (world->items.at(x + (y * world->width)).DoorLocked = true) {
															if (!isWorldOwner(peer, world) || !isWorldAdmin(peer, world)) {
																doorlocked(peer, world->items.at(x + (y * world->width)).foreground, x, y, "`4<Locked>");
																updateDoor(peer, world->items.at(pData->wrenchsession).foreground, pData->wrenchsession % world->width, pData->wrenchsession / world->width, world->items.at(pData->wrenchsession).background, door_name == "" ? (door_destination_id == "" ? door_destination_world : door_destination_world + "...") : door_name, world->items.at(x + (y * world->width)).DoorLocked, false);
															}
														}
														else
														{
															updateDoor(peer, world->items.at(pData->wrenchsession).foreground, pData->wrenchsession% world->width, pData->wrenchsession / world->width, world->items.at(pData->wrenchsession).background, door_name == "" ? (door_destination_id == "" ? door_destination_world : door_destination_world + "...") : door_name, false, false);
														}
													}
												}
												if (infoDat.at(0) == "door_id") {
													int x = pData->wrenchsession % world->width;
													int y = pData->wrenchsession / world->width;
													door_id = getStrUpper(infoDat.at(1));
													world->items.at(pData->wrenchsession).destWorld = door_destination_world;
													world->items.at(pData->wrenchsession).destId = door_destination_id;
													world->items.at(pData->wrenchsession).label = door_name;
													if (world->items.at(pData->wrenchsession).foreground == 762) {
														world->items.at(pData->wrenchsession).password = door_id;
													} else {
														world->items.at(pData->wrenchsession).currId = door_id;
													}
													if (!isWorldOwner(peer, world) || !isWorldAdmin(peer, world)) {
														updateDoor(peer, world->items.at(pData->wrenchsession).foreground, pData->wrenchsession % world->width, pData->wrenchsession / world->width, world->items.at(pData->wrenchsession).background, door_name == "" ? (door_destination_id == "" ? door_destination_world : door_destination_world + "...") : door_name, world->items.at(x + (y * world->width)).DoorLocked, false);
													}
													else
													{
														if (world->items.at(x + (y * world->width)).DoorLocked = true) {
															if (!isWorldOwner(peer, world) || !isWorldAdmin(peer, world)) {
																doorlocked(peer, world->items.at(x + (y * world->width)).foreground, x, y, "`4<Locked>");
																updateDoor(peer, world->items.at(pData->wrenchsession).foreground, pData->wrenchsession % world->width, pData->wrenchsession / world->width, world->items.at(pData->wrenchsession).background, door_name == "" ? (door_destination_id == "" ? door_destination_world : door_destination_world + "...") : door_name, world->items.at(x + (y * world->width)).DoorLocked, false);
															}
														}
														else
														{
															updateDoor(peer, world->items.at(pData->wrenchsession).foreground, pData->wrenchsession % world->width, pData->wrenchsession / world->width, world->items.at(pData->wrenchsession).background, door_name == "" ? (door_destination_id == "" ? door_destination_world : door_destination_world + "...") : door_name, false, false);
														}
													}
												}
											}
											if (title_save) {
												if (infoDat.at(0) == "title_name") {
													if (!pData->Subscriber) break;
													title_name = infoDat.at(1);
													if (title_name.size() > 10 || title_name.size() < 0) break;
													if (title_name.find("@") != string::npos) {
														Player::OnTalkBubble(peer, pData->netID, "`oSorry this title cannot be used for security reasons!", 0, true);
														break;
													}
													if (title_name.size() == 0) {
														Player::OnTalkBubble(peer, pData->netID, "`oTitle have been removed!", 0, true);
														pData->NickPrefix = "";
														restoreplayernick(peer);
														Player::OnNameChanged(peer, pData->netID, pData->displayName);
													} else {
														pData->NickPrefix = title_name;
														Player::OnTalkBubble(peer, pData->netID, "`oTitle changed to " + title_name + "!", 0, true);
														restoreplayernick(peer);
														Player::OnNameChanged(peer, pData->netID, pData->displayName);
													}
												}
											}
											if (notebook_edit) {
												if (infoDat.at(0) == "personal_note") {
													personal_note = infoDat.at(1);
													if (personal_note.size() >= 70 || personal_note.size() <= 0) break;
													pData->notebook = personal_note;
													Player::OnTalkBubble(peer, pData->netID, "`2Text saved.", 0, true);
												}
											}
											if (signEditor) {
												int x = pData->wrenchedBlockLocation % world->width;
												int y = pData->wrenchedBlockLocation / world->width;
												if (x < 0 || y < 0) break;
												world->items.at(pData->wrenchedBlockLocation).sign = message321;
												UpdateMessageVisuals(peer, world->items.at(pData->wrenchedBlockLocation).foreground, x, y, message321, world->items.at(pData->wrenchedBlockLocation).background);
											}
											if (UpVend) {
												std::ifstream ifsz("save/gemdb/_" + ((PlayerInfo*)(peer->data))->rawName + ".txt");
												std::string content((std::istreambuf_iterator<char>(ifsz)),
													(std::istreambuf_iterator<char>()));
												int b = atoi(content.c_str());
												if (b > 3999) {
													int gemcalc10k = b - 4000;
													ofstream myfile2;
													myfile2.open("save/gemdb/_" + ((PlayerInfo*)(peer->data))->rawName + ".txt");
													myfile2 << std::to_string(gemcalc10k);
													myfile2.close();
													std::ifstream ifszi("save/gemdb/_" + ((PlayerInfo*)(peer->data))->rawName + ".txt");
													std::string contentx((std::istreambuf_iterator<char>(ifszi)),
														(std::istreambuf_iterator<char>()));
													int updgem = atoi(contentx.c_str());
													GamePacket pp = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), updgem));
													ENetPacket* packetpp = enet_packet_create(pp.data,
														pp.len,
														ENET_PACKET_FLAG_RELIABLE);
													enet_peer_send(peer, 0, packetpp);
													delete pp.data;
													int x = ((PlayerInfo*)(peer->data))->lastPunchX;
													int y = ((PlayerInfo*)(peer->data))->lastPunchY;
													auto dicenr = 0;
													world->items.at(x + (y * world->width)).foreground = 9268;
													PlayerMoving data3;
													data3.packetType = 0x3;
													data3.characterState = 0x0;
													data3.x = x;
													data3.y = y;
													data3.punchX = x;
													data3.punchY = y;
													data3.XSpeed = 0;
													data3.YSpeed = 0;
													data3.netID = -1;
													data3.plantingTree = 9268;
													ENetPeer* currentPeer;
													for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
														if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
														if (isHere(peer, currentPeer)) {
															auto raw = packPlayerMoving(&data3);
															raw[2] = dicenr;
															raw[3] = dicenr;
															SendPacketRaw(4, raw, 56, nullptr, currentPeer, ENET_PACKET_FLAG_RELIABLE);
															auto islocks = false;
															if (world->items.at(x + (y * world->width)).vdraw >= 1) {
																islocks = true;
															}

															if (world->items.at(x + (y * world->width)).opened && world->items.at(x + (y * world->width)).vcount < world->items.at(x + (y * world->width)).vprice) {
																UpdateDigiVend(currentPeer, x, y, 0, islocks, world->items.at(x + (y * world->width)).vprice, world->items.at(x + (y * world->width)).background, world->items.at(x + (y * world->width)).opened);
															}
															else {
																UpdateDigiVend(currentPeer, x, y, world->items.at(x + (y * world->width)).vid, islocks, world->items.at(x + (y * world->width)).vprice, world->items.at(x + (y * world->width)).background, world->items.at(x + (y * world->width)).opened);
															}
														}
													}
													for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
														if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
														Player::OnParticleEffect(currentPeer, 44, x * 32, y * 32, 0);
													}
												}
												else {
													Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`wYou don't have enough gems!", 0, true);
												}
											}
											if (isLockDialog) {
												if (infoDat.at(1) == "clear_mascot") {
													try {
														ifstream read_player("save/players/_" + world->owner + ".json");
														if (!read_player.is_open()) {
															break;
														}
														json j;
														read_player >> j;
														read_player.close();
														string guild_name = j["guild"];
														for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
															if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
															if (static_cast<PlayerInfo*>(currentPeer->data)->guild == guild_name) {
																static_cast<PlayerInfo*>(currentPeer->data)->guildFg = 0;
																static_cast<PlayerInfo*>(currentPeer->data)->guildBg = 0;
																Player::OnTalkBubble(currentPeer, static_cast<PlayerInfo*>(currentPeer->data)->netID, "Your guild mascot have been cleared", 0, true);
																Player::OnConsoleMessage(currentPeer, "`oYour guild mascot have been cleared");
																Player::PlayAudio(currentPeer, "audio/siren.wav", 0);
																for (ENetPeer* currentPeer2 = server->peers; currentPeer2 < &server->peers[server->peerCount]; ++currentPeer2) {
																	if (currentPeer2->state != ENET_PEER_STATE_CONNECTED || currentPeer2->data == NULL) continue;
																	if (isHere(currentPeer, currentPeer2)) {
																		gamepacket_t p(0, static_cast<PlayerInfo*>(currentPeer->data)->netID);
																		p.Insert("OnGuildDataChanged");
																		p.Insert(36095);
																		p.Insert(63158650);
																		p.Insert((65536 * static_cast<PlayerInfo*>(currentPeer->data)->guildBg) + static_cast<PlayerInfo*>(currentPeer->data)->guildFg);
																		p.Insert(static_cast<PlayerInfo*>(currentPeer->data)->guild_rank);
																		p.CreatePacket(currentPeer2);
																	}
																}
															}
														}
														ifstream read_guild("save/guilds/_" + guild_name + ".json");
														if (!read_guild.is_open()) {
															break;
														}
														json js;
														read_guild >> js;
														read_guild.close();
														js["foregroundflag"] = 0;
														js["backgroundflag"] = 0;
														ofstream write_guild("save/guilds/_" + guild_name + ".json");
														write_guild << js << std::endl;
														write_guild.close();
													}
													catch (std::exception& e) {
														std::cout << e.what() << std::endl;
														break;
													}
													break;
												}
												if (infoDat.at(0) == "guild_fg") {
													try {
														auto iscontains = false;
														SearchInventoryItem(peer, atoi(infoDat.at(1).c_str()), 1, iscontains);
														if (!iscontains) break;
														ifstream read_player("save/players/_" + world->owner + ".json");
														if (!read_player.is_open()) {
															break;
														}
														json j;
														read_player >> j;
														read_player.close();
														string guild_name = j["guild"];
														for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
															if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
															if (static_cast<PlayerInfo*>(currentPeer->data)->guild == guild_name) {
																static_cast<PlayerInfo*>(currentPeer->data)->guildFg = atoi(infoDat.at(1).c_str());
																Player::OnTalkBubble(currentPeer, static_cast<PlayerInfo*>(currentPeer->data)->netID, "Your guild foreground have been changed to " + getItemDef(atoi(infoDat.at(1).c_str())).name, 0, true);
																Player::OnConsoleMessage(currentPeer, "`oYour guild foreground have been changed to " + getItemDef(atoi(infoDat.at(1).c_str())).name);
																Player::PlayAudio(currentPeer, "audio/siren.wav", 0);
																for (ENetPeer* currentPeer2 = server->peers; currentPeer2 < &server->peers[server->peerCount]; ++currentPeer2) {
																	if (currentPeer2->state != ENET_PEER_STATE_CONNECTED || currentPeer2->data == NULL) continue;
																	if (isHere(currentPeer, currentPeer2)) {
																		gamepacket_t p(0, static_cast<PlayerInfo*>(currentPeer->data)->netID);
																		p.Insert("OnGuildDataChanged");
																		p.Insert(36095);
																		p.Insert(63158650);
																		p.Insert((65536 * static_cast<PlayerInfo*>(currentPeer->data)->guildBg) + static_cast<PlayerInfo*>(currentPeer->data)->guildFg);
																		p.Insert(static_cast<PlayerInfo*>(currentPeer->data)->guild_rank);
																		p.CreatePacket(currentPeer2);
																	}
																}
															}
														}
														ifstream read_guild("save/guilds/_" + guild_name + ".json");
														if (!read_guild.is_open()) {
															break;
														}
														json js;
														read_guild >> js;
														read_guild.close();
														js["foregroundflag"] = atoi(infoDat.at(1).c_str());
														ofstream write_guild("save/guilds/_" + guild_name + ".json");
														write_guild << js << std::endl;
														write_guild.close();
													}
													catch (std::exception& e) {
														std::cout << e.what() << std::endl;
														break;
													}
													break;
												}
												if (infoDat.at(0) == "guild_bg") {
													try {
														auto iscontains = false;
														SearchInventoryItem(peer, atoi(infoDat.at(1).c_str()), 1, iscontains);
														if (!iscontains) break;
														ifstream read_player("save/players/_" + world->owner + ".json");
														if (!read_player.is_open()) {
															break;
														}
														json j;
														read_player >> j;
														read_player.close();
														string guild_name = j["guild"];
														for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
															if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
															if (static_cast<PlayerInfo*>(currentPeer->data)->guild == guild_name) {
																static_cast<PlayerInfo*>(currentPeer->data)->guildBg = atoi(infoDat.at(1).c_str());
																Player::OnTalkBubble(currentPeer, static_cast<PlayerInfo*>(currentPeer->data)->netID, "Your guild background have been changed to " + getItemDef(atoi(infoDat.at(1).c_str())).name, 0, true);
																Player::OnConsoleMessage(currentPeer, "`oYour guild background have been changed to " + getItemDef(atoi(infoDat.at(1).c_str())).name);
																Player::PlayAudio(currentPeer, "audio/siren.wav", 0);
																for (ENetPeer* currentPeer2 = server->peers; currentPeer2 < &server->peers[server->peerCount]; ++currentPeer2) {
																	if (currentPeer2->state != ENET_PEER_STATE_CONNECTED || currentPeer2->data == NULL) continue;
																	if (isHere(currentPeer, currentPeer2)) {
																		gamepacket_t p(0, static_cast<PlayerInfo*>(currentPeer->data)->netID);
																		p.Insert("OnGuildDataChanged");
																		p.Insert(36095);
																		p.Insert(63158650);
																		p.Insert((65536 * static_cast<PlayerInfo*>(currentPeer->data)->guildBg) + static_cast<PlayerInfo*>(currentPeer->data)->guildFg);
																		p.Insert(static_cast<PlayerInfo*>(currentPeer->data)->guild_rank);
																		p.CreatePacket(currentPeer2);
																	}
																}
															}
														}
														ifstream read_guild("save/guilds/_" + guild_name + ".json");
														if (!read_guild.is_open()) {
															break;
														}
														json js;
														read_guild >> js;
														read_guild.close();
														js["backgroundflag"] = atoi(infoDat.at(1).c_str());
														ofstream write_guild("save/guilds/_" + guild_name + ".json");
														write_guild << js << std::endl;
														write_guild.close();
													}
													catch (std::exception& e) {
														std::cout << e.what() << std::endl;
														break;
													}
													break;
												}
												if (infoDat.at(1) == "changecat") {
													Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wSet World Category``|left|3802|\nadd_textbox|Select a category for your world.|left|\nadd_button|None|None|noflags|0|0|\nadd_button|Mining|Mining|noflags|0|0|\nadd_button|Adventure|Adventure|noflags|0|0|\nadd_button|Art|Art|noflags|0|0|\nadd_button|Farm|Farm|noflags|0|0|\nadd_button|Game|Game|noflags|0|0|\nadd_button|Information|Information|noflags|0|0|\nadd_button|Music|Music|noflags|0|0|\nadd_button|Parkour|Parkour|noflags|0|0|\nadd_button|Puzzle|Puzzle|noflags|0|0|\nadd_button|Roleplay|Roleplay|noflags|0|0|\nadd_button|Shop|Shop|noflags|0|0|\nadd_button|Social|Social|noflags|0|0|\nadd_button|Storage|Storage|noflags|0|0|\nadd_button|Story|Story|noflags|0|0|\nadd_button|Trade|Trade|noflags|0|0|\nadd_smalltext|Worlds in the category 'None' can't be rated by players, and they are only listed on the normal World Select screen.|left|\nadd_smalltext|`4Warning:`` Changing your category will delete all ratings on your world.|left|\nend_dialog|worldcategory|Nevermind||");
													break;
												}
												if (infoDat.at(0) == "checkbox_public") {
													int x = pData->wrenchedBlockLocation % world->width;
													int y = pData->wrenchedBlockLocation / world->width;
													if (world->items.at(x + (y * world->width)).foreground == 202 || world->items.at(x + (y * world->width)).foreground == 204 || world->items.at(x + (y * world->width)).foreground == 206 || world->items.at(x + (y * world->width)).foreground == 4994) {
														if (pData->rawName == world->items.at(x + (y * world->width)).monitorname || isMod(peer) || isWorldOwner(peer, world)) {
															if (!world->items.at(x + (y * world->width)).opened && infoDat.at(1) == "1") world->items.at(x + (y * world->width)).opened = true;
															else if (infoDat.at(1) == "0" && world->items.at(x + (y * world->width)).opened) world->items.at(x + (y * world->width)).opened = false;
														}
														for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
															if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
															if (isHere(peer, currentPeer)) {
																if (world->items.at(x + (y * world->width)).opened) apply_lock_packet(world, currentPeer, x, y, world->items.at(x + (y * world->width)).foreground, -3);
																else if (world->items.at(x + (y * world->width)).monitorname == static_cast<PlayerInfo*>(currentPeer->data)->rawName) apply_lock_packet(world, currentPeer, x, y, world->items.at(x + (y * world->width)).foreground, static_cast<PlayerInfo*>(currentPeer->data)->netID);
																else apply_lock_packet(world, currentPeer, x, y, world->items.at(x + (y * world->width)).foreground, -1);
															}
														}					
													}
												}
												if (infoDat.at(0) == "playerNetID") {
													playerNetId = infoDat.at(1);
												}
												if (infoDat.at(0) == "checkbox_muted") {
													muted = infoDat.at(1);
												}
												if (infoDat.at(0) == "tempo") {
													tempo = infoDat.at(1);
													int x = pData->wrenchedBlockLocation % world->width;
													int y = pData->wrenchedBlockLocation / world->width;
													uint8_t lol = 0x00;
													if (world->tempo != atoi(tempo.c_str())) {
														if (atoi(tempo.c_str()) > 200 || atoi(tempo.c_str()) < 19) {
															Player::OnConsoleMessage(peer, "`oWorld's BPM Cannot be Higher than 200 or lower than 20!");
															continue;
														}
														else world->tempo = atoi(tempo.c_str());
														for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
															if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
															if (isHere(peer, currentPeer)) {
																send_tile_data(currentPeer, x, y, 0x00, world->items.at(x + (y * world->width)).foreground, world->items.at(x + (y * world->width)).background, lock_tile_datas(lol, static_cast<PlayerInfo*>(peer->data)->netID, 0, 0, world->isPublic, atoi(tempo.c_str())));
															}
														}
													}
												}
												if (infoDat.at(0) == "checkbox_disable_music") {
													disable_music = infoDat.at(1);
													uint8_t lol = 0x00;
													world->disable_music = atoi(disable_music.c_str());
													if (disable_music == "1") lol |= 0x10;
													int x = pData->wrenchedBlockLocation % world->width;
													int y = pData->wrenchedBlockLocation / world->width;
													for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
														if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
														if (isHere(peer, currentPeer)) {
															send_tile_data(currentPeer, x, y, 0x00, world->items.at(x + (y * world->width)).foreground, world->items.at(x + (y * world->width)).background, lock_tile_datas(lol, static_cast<PlayerInfo*>(peer->data)->netID, 0, 0, world->isPublic, atoi(tempo.c_str())));
														}
													}
												}
												if (infoDat.at(0) == "checkbox_noclip") {
													if (world) {
														allowNoClip = infoDat.at(1);
														world->AllowNoClip = atoi(allowNoClip.c_str());
														for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
															if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
															if (isHere(peer, currentPeer)) {
																if (allowNoClip == "1") {
																	Player::OnConsoleMessage(currentPeer, "`oThe world owner has allowed no-clipping in this world!");
																	break;
																	;
																}
																else
																{
																	Player::OnConsoleMessage(currentPeer, "`oThe world owner has unallowed no-clipping in this world!");
																	if (static_cast<PlayerInfo*>(currentPeer->data)->canWalkInBlocks == true) {
																		int adminLevel = static_cast<PlayerInfo*>(currentPeer->data)->adminLevel;
																		string plrRole = role_nameko.at(adminLevel);
																		if (plrRole != "owner" || plrRole != "owner" || !isWorldOwner(currentPeer, world)) {
																			if (static_cast<PlayerInfo*>(currentPeer->data)->skinColor == -2450) {
																				static_cast<PlayerInfo*>(currentPeer->data)->skinColor = 0x8295C3FF;
																				sendClothes(currentPeer);
																			}
																			static_cast<PlayerInfo*>(currentPeer->data)->canWalkInBlocks = false;
																			send_state(currentPeer);
																			Player::OnConsoleMessage(currentPeer, "`oYour body stops shimmering and returns to normal. (`$Ghost in the Shell `omod removed)``");
																			Player::PlayAudio(currentPeer, "audio/dialog_confirm.wav", 0);
																		}
																	}
																}
															}
														}
													}
												}
												if (infoDat.at(0) == "checkbox_disable_music_render") {
													disable_music_render = infoDat.at(1);
													uint8_t lol = 0x00;
													world->disable_music_render = atoi(disable_music_render.c_str());
													if (disable_music_render == "1") lol |= 0x20;
													int x = pData->wrenchedBlockLocation % world->width;
													int y = pData->wrenchedBlockLocation / world->width;
													for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
														if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
														if (isHere(peer, currentPeer)) {
															send_tile_data(currentPeer, x, y, 0x00, world->items.at(x + (y * world->width)).foreground, world->items.at(x + (y * world->width)).background, lock_tile_datas(lol, static_cast<PlayerInfo*>(peer->data)->netID, 0, 0, world->isPublic, atoi(tempo.c_str())));
														}
													}
												}
												if (infoDat.at(0) == "checkbox_rainbow") {
													int x = pData->wrenchedBlockLocation % world->width;
													int y = pData->wrenchedBlockLocation / world->width;
													if (infoDat.at(1) == "1" && !world->rainbow) {
														world->rainbow = true;
													}
													else if (infoDat.at(1) == "0" && world->rainbow) {
														world->rainbow = false;
													}
													for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
														if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
														if (isHere(peer, currentPeer)) {
															if (world->rainbow) send_rainbow_shit_data(currentPeer, world->items.at(x + (y * world->width)).foreground, world->items.at(x + (y * world->width)).background, x, y, true, pData->netID);
															else send_rainbow_shit_data(currentPeer, world->items.at(x + (y * world->width)).foreground, world->items.at(x + (y * world->width)).background, x, y, false, pData->netID);
														}
													}
												}
												if (infoDat.at(0).substr(0, 9) == "checkbox_") {
													string name = infoDat.at(0).substr(infoDat.at(0).find("_") + 1);
													try {
														if (isWorldAdmin(name, world) && infoDat.at(1) == "0") {
															ifstream read_player("save/players/_" + name + ".json");
															if (!read_player.is_open()) {
																break;
															}		
															json j;
															read_player >> j;
															read_player.close();
															string username = j["nick"];
															int adminLevel = j["adminLevel"];
															if (username == "") {
																username = role_prefix.at(adminLevel) + name;
															} 
															world->accessed.erase(std::remove(world->accessed.begin(), world->accessed.end(), name), world->accessed.end());
															for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
																if (isHere(peer, currentPeer)) {
																	Player::OnConsoleMessage(peer, "" + username + " `owas removed from a World Lock.");
																}
															}
															string current_peer_nick = "";
															for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
																if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == name) {
																	Player::OnConsoleMessage(currentPeer, "You lost access to World Lock in " + pData->currentWorld);
																	if (static_cast<PlayerInfo*>(currentPeer->data)->currentWorld == pData->currentWorld) {
																		size_t pos;
																		while ((pos = static_cast<PlayerInfo*>(currentPeer->data)->displayName.find("`^")) != string::npos) {
																			static_cast<PlayerInfo*>(currentPeer->data)->displayName.replace(pos, 2, "");
																		}
																		Player::OnNameChanged(peer, static_cast<PlayerInfo*>(currentPeer->data)->netID, static_cast<PlayerInfo*>(currentPeer->data)->displayName);
																		int x = pData->wrenchedBlockLocation % world->width;
																		int y = pData->wrenchedBlockLocation / world->width;
																		PlayerMoving moving{};
																		moving.packetType = 0x3;
																		moving.characterState = 0x0;
																		moving.x = x;
																		moving.y = y;
																		moving.punchX = x;
																		moving.punchY = y;
																		moving.XSpeed = 0;
																		moving.YSpeed = 0;
																		moving.netID = -1;
																		moving.plantingTree = world->items.at(pData->wrenchedBlockLocation).foreground;
																		SendPacketRaw(4, packPlayerMoving(&moving), 56, nullptr, currentPeer, ENET_PACKET_FLAG_RELIABLE);
																	}
																}
															}
														}
													} catch (std::exception& e) {
														std::cout << e.what() << std::endl;
														break;
													}
												}
												if (infoDat.at(0) == "minimum_entry_level") {
													int x = pData->wrenchedBlockLocation % world->width;
													int y = pData->wrenchedBlockLocation / world->width;
													if (x < 0 || y < 0) break;
													for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
														if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
														if (isHere(peer, currentPeer)) {
															if (static_cast<PlayerInfo*>(currentPeer->data)->netID == atoi(playerNetId.c_str())) {
																accessPlayer(peer, static_cast<PlayerInfo*>(currentPeer->data)->rawName, world);
																break;
															}
														}
													}
													if (muted == "1") world->silence = true;
													else world->silence = false;
													if (world->entrylevel != atoi(infoDat.at(1).c_str())) {
														if (atoi(infoDat.at(1).c_str()) >= 125 || infoDat.at(1).size() > 3) {
															Player::OnTalkBubble(peer, pData->netID, "Minimum entry level can't be higher than 124.", 0, 0);
														} else {
															world->entrylevel = atoi(infoDat.at(1).c_str());
															Player::OnTalkBubble(peer, pData->netID, "Minimum entry level for this world is set to `2Level " + infoDat.at(1) + "``.", 0, 0);
														}
													}
													break;
												}
											}
											if (infoDat.at(0) == "VipAccess" && infoDat.at(1) == "0") {
												if (world) {
													int x = ((PlayerInfo*)(peer->data))->lastPunchX;
													int y = ((PlayerInfo*)(peer->data))->lastPunchY;
													string offname = "";
													for (std::vector<string>::const_iterator i = world->items.at(x + (y * world->width)).viplist.begin(); i != world->items.at(x + (y * world->width)).viplist.end(); ++i) {
														offname = *i;
													}
													for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
														if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
														if (((PlayerInfo*)(currentPeer->data))->rawName == offname) {
															WorldInfo info;
															world->items.at(x + (y * world->width)).viplist.erase(std::remove(world->items.at(x + (y * world->width)).viplist.begin(), world->items.at(x + (y * world->width)).viplist.end(), offname), world->items.at(x + (y * world->width)).viplist.end());
															SendConsoleMsgAll(peer, "`o" + offname + " `owas removed from a VIP List.");
															VIP(currentPeer, x, y, world->items.at(x + (y * world->width)).foreground, world->items.at(x + (y * world->width)).background, 0);
														}
													}
												}
											}
											if (turnSpotOff) {
												if (((PlayerInfo*)(peer->data))->rawName == world->owner) {
													int x = ((PlayerInfo*)(peer->data))->lastPunchX;
													int y = ((PlayerInfo*)(peer->data))->lastPunchY;
													ENetPeer* currentPeer;
													for (currentPeer = server->peers;
														currentPeer < &server->peers[server->peerCount];
														++currentPeer)
													{
														if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
															continue;

														if (((PlayerInfo*)(currentPeer->data))->rawName == world->items.at(x + (y * world->width)).spotTo) {
															world->items.at(x + (y * world->width)).spotTo = "";
															((PlayerInfo*)(currentPeer->data))->isShining = false;
															send_state(currentPeer);
														}
													}
												}
											}
											if (shineSpot) {
												if (((PlayerInfo*)(peer->data))->rawName == world->owner) {
													int x = ((PlayerInfo*)(peer->data))->lastPunchX;
													int y = ((PlayerInfo*)(peer->data))->lastPunchY;
													ENetPeer* currentPeer;
													for (currentPeer = server->peers;
														currentPeer < &server->peers[server->peerCount];
														++currentPeer)
													{
														if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
															continue;
														if (((PlayerInfo*)(currentPeer->data))->netID == stoi(spotID)) {
															if (((PlayerInfo*)(currentPeer->data))->isShining == true) {
																Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`w" + ((PlayerInfo*)(currentPeer->data))->tankIDName + " is already shining!", 0, false);
																break;
															}
															else {
																string text = "action|play_sfx\nfile|audio/secret.wav\ndelayMS|0\n";
																BYTE* data = new BYTE[5 + text.length()];
																BYTE zero = 0;
																int type = 3;
																memcpy(data, &type, 4);
																memcpy(data + 4, text.c_str(), text.length());
																memcpy(data + 4 + text.length(), &zero, 1);
																ENetPacket* packet2 = enet_packet_create(data,
																	5 + text.length(),
																	ENET_PACKET_FLAG_RELIABLE);
																enet_peer_send(peer, 0, packet2);
																delete[] data;
																Player::PlayAudio(currentPeer, "audio/secret.wav", 0);
																Player::OnConsoleMessage(currentPeer, "`o" + ((PlayerInfo*)(peer->data))->displayName + " `ohas put the light on you!");
																world->items.at(x + (y * world->width)).spotTo = ((PlayerInfo*)(currentPeer->data))->rawName;
																((PlayerInfo*)(currentPeer->data))->isShining = true;
																send_state(currentPeer);
															}
														}
														else
														{
															((PlayerInfo*)(currentPeer->data))->isShining = false;
															send_state(currentPeer);
														}
													}
												}
											}
											if (VipAccess) {
												if (((PlayerInfo*)(peer->data))->rawName == world->owner) {
													int x = ((PlayerInfo*)(peer->data))->lastPunchX;
													int y = ((PlayerInfo*)(peer->data))->lastPunchY;
													string accessnames = "";
													for (std::vector<string>::const_iterator i = world->items.at(x + (y * world->width)).viplist.begin(); i != world->items.at(x + (y * world->width)).viplist.end(); ++i) {
														accessnames = *i;
													}
													ENetPeer* currentPeer;
													for (currentPeer = server->peers;
														currentPeer < &server->peers[server->peerCount];
														++currentPeer)
													{
														if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
															continue;
														if (((PlayerInfo*)(currentPeer->data))->netID == stoi(vipid)) {
															if (((PlayerInfo*)(peer->data))->rawName == ((PlayerInfo*)(currentPeer->data))->rawName) {
																GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`oYou can't access yourself"));
																ENetPacket* packet = enet_packet_create(p.data,
																	p.len,
																	ENET_PACKET_FLAG_RELIABLE);
																enet_peer_send(peer, 0, packet);
																delete p.data;
															}
															else {
																WorldInfo info;
																if (find(world->items.at(x + (y * world->width)).viplist.begin(), world->items.at(x + (y * world->width)).viplist.end(), ((PlayerInfo*)(currentPeer->data))->rawName) != world->items.at(x + (y * world->width)).viplist.end()) {
																	Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`w" + ((PlayerInfo*)(currentPeer->data))->tankIDName + " is already a VIP!", 0, false);
																	break;
																}
																else {
																	string text = "action|play_sfx\nfile|audio/secret.wav\ndelayMS|0\n";
																	BYTE* data = new BYTE[5 + text.length()];
																	BYTE zero = 0;
																	int type = 3;
																	memcpy(data, &type, 4);
																	memcpy(data + 4, text.c_str(), text.length());
																	memcpy(data + 4 + text.length(), &zero, 1);
																	ENetPacket* packet2 = enet_packet_create(data,
																		5 + text.length(),
																		ENET_PACKET_FLAG_RELIABLE);
																	enet_peer_send(peer, 0, packet2);
																	delete[] data;
																	Player::PlayAudio(currentPeer, "audio/secret.wav", 0);
																	Player::OnConsoleMessage(currentPeer, "`o" + ((PlayerInfo*)(peer->data))->displayName + " `oput you to VIP List.");
																	world->items.at(x + (y * world->width)).viplist.push_back(((PlayerInfo*)(currentPeer->data))->rawName);
																	Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`wPut " + ((PlayerInfo*)(currentPeer->data))->displayName + " `won the VIP List,", 0, true);
																	VIP(currentPeer, x, y, world->items.at(x + (y * world->width)).foreground, world->items.at(x + (y * world->width)).background, ((PlayerInfo*)(currentPeer->data))->netID);
																}
															}
														}
													}
												}
											}
											if (RemoveVipAccess) {
												int x = ((PlayerInfo*)(peer->data))->lastPunchX;
												int y = ((PlayerInfo*)(peer->data))->lastPunchY;
												ENetPeer* currentPeer;
												for (currentPeer = server->peers;
													currentPeer < &server->peers[server->peerCount];
													++currentPeer)
												{
													if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
														continue;
													if (((PlayerInfo*)(currentPeer->data))->rawName == ((PlayerInfo*)(peer->data))->rawName) {
														WorldInfo info;
														world->items.at(x + (y * world->width)).viplist.erase(std::remove(world->items.at(x + (y * world->width)).viplist.begin(), world->items.at(x + (y * world->width)).viplist.end(), ((PlayerInfo*)(currentPeer->data))->rawName), world->items.at(x + (y * world->width)).viplist.end());
														SendConsoleMsgAll(peer, "`o" + ((PlayerInfo*)(currentPeer->data))->tankIDName + " removed their access from a Vip List.");
														Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`wI've removed my access from Vip List", 0, false);
														VIP(currentPeer, x, y, world->items.at(x + (y * world->width)).foreground, world->items.at(x + (y * world->width)).background, 0);
													}
												}
											}
											if (isVipDialog) {
												if (infoDat.at(0) == "vip_public") vipPub = infoDat.at(1);
												if (world) {
													int x = ((PlayerInfo*)(peer->data))->lastPunchX;
													int y = ((PlayerInfo*)(peer->data))->lastPunchY;
													for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
														if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
														if (isHere(peer, currentPeer)) {
															if (world->items.at(x + (y * world->width)).foreground == 3798 && has_only_digits(vipPub)) {
																if (world->items.at(x + (y * world->width)).VipPublic != atoi(vipPub.c_str())) {
																	if (vipPub == "1") {
																		world->items.at(x + (y * world->width)).VipPublic = true;
																		VIP(currentPeer, x, y, world->items.at(x + (y * world->width)).foreground, world->items.at(x + (y * world->width)).background, ((PlayerInfo*)(currentPeer->data))->netID);
																		SendConsoleMsgAll(peer, "" + world->owner + " `ohas set a `$VIP Entrance `oto `$PUBLIC");
																		Player::PlayAudio(peer, "audio/secret.wav", 0);
																		Player::PlayAudio(currentPeer, "audio/secret.wav", 0);
																		break;
																	}
																	else {
																		world->items.at(x + (y * world->width)).VipPublic = false;
																		if (isWorldOwner(currentPeer, world) || isWorldAdmin(currentPeer, world) || (find(world->items.at(x + (y * world->width)).viplist.begin(), world->items.at(x + (y * world->width)).viplist.end(), ((PlayerInfo*)(currentPeer->data))->rawName) != world->items.at(x + (y * world->width)).viplist.end())) {
																			VIP(currentPeer, x, y, world->items.at(x + (y * world->width)).foreground, world->items.at(x + (y * world->width)).background, ((PlayerInfo*)(currentPeer->data))->netID);
																			SendConsoleMsgAll(peer, "" + world->owner + " `ohas set a `$VIP Entrance `oto `4PRIVATE");
																			Player::PlayAudio(peer, "audio/secret.wav", 0);
																			Player::PlayAudio(currentPeer, "audio/secret.wav", 0);
																			break;
																		}
																		VIP(currentPeer, x, y, world->items.at(x + (y * world->width)).foreground, world->items.at(x + (y * world->width)).background, 0);
																		SendConsoleMsgAll(peer, "" + world->owner + " `ohas set a `$VIP Entrance `oto `4PRIVATE");
																		Player::PlayAudio(peer, "audio/secret.wav", 0);
																		Player::PlayAudio(currentPeer, "audio/secret.wav", 0);
																		break;
																	}
																}
																else {
																}
															}
														}
													}
												}
											}
											if (isHeatwaveDialog) {
												if (infoDat.at(0) == "heatwave_red") h_r = infoDat.at(1);
												if (infoDat.at(0) == "heatwave_green") h_g = infoDat.at(1);
												if (infoDat.at(0) == "heatwave_blue") h_b = infoDat.at(1);
											}
											if (isStuffDialog) {
												if (infoDat.at(0) == "choose") stuffITEM = infoDat.at(1);
												if (infoDat.at(0) == "gravity") stuff_gravity = infoDat.at(1);
												if (infoDat.at(0) == "spin") stuff_spin = infoDat.at(1);
												if (infoDat.at(0) == "invert") stuff_invert = infoDat.at(1);
											}
											if (isHeatwaveDialog) {
												if (h_b != "") {
													int x = pData->wrenchedBlockLocation % world->width;
													int y = pData->wrenchedBlockLocation / world->width;
													if (world->isPublic || isWorldAdmin(peer, world) || isWorldOwner(peer, world) || world->owner == "" || isDev(peer) || !restricted_area(peer, world, x, y)) {
														int current_r = world->items.at(x + (y * world->width)).vid;
														int current_g = world->items.at(x + (y * world->width)).vprice;
														int current_b = world->items.at(x + (y * world->width)).vcount;
														if (atoi(h_r.c_str()) == current_r && atoi(h_g.c_str()) == current_g && atoi(h_b.c_str()) == current_b) break;
														world->items.at(x + (y * world->width)).vid = atoi(h_r.c_str());
														world->items.at(x + (y * world->width)).vprice = atoi(h_g.c_str());
														world->items.at(x + (y * world->width)).vcount = atoi(h_b.c_str());
														sendHeatwave(peer, x, y, world->items.at(x + (y * world->width)).vid, world->items.at(x + (y * world->width)).vprice, world->items.at(x + (y * world->width)).vcount);
														if (world->items.at(x + (y * world->width)).activated) {
															for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
																if (isHere(peer, currentPeer)) {
																	Player::OnSetCurrentWeather(currentPeer, 28);
																}
															}
														}
													}
													break;
												}
											}
											if (isBackgroundDialog) {
												if (infoDat.at(0) == "choose") {
													int x = pData->wrenchedBlockLocation % world->width;
													int y = pData->wrenchedBlockLocation / world->width;
													if (world->isPublic || isWorldAdmin(peer, world) || isWorldOwner(peer, world) || world->owner == "" || isDev(peer) || !restricted_area(peer, world, x, y)) {
														int itemid = atoi(infoDat.at(1).c_str());
														if (world->items.at(x + (y * world->width)).intdata == itemid || infoDat.at(1) == "") {
															break;
														}
														if (getItemDef(itemid).blockType != BlockTypes::BACKGROUND) {
															Player::OnTalkBubble(peer, pData->netID, "That's not a background!", 0, true);
															break;
														}
														world->items.at(x + (y * world->width)).intdata = itemid;
														sendBackground(peer, x, y, itemid);
														if (world->items.at(x + (y * world->width)).activated) {
															for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
																if (isHere(peer, currentPeer)) {
																	Player::OnSetCurrentWeather(currentPeer, 34);
																}
															}
														}
													}
													break;
												}
											}
											if (isStuffDialog) {
												if (stuff_gravity != "" && stuff_spin != "" && stuff_invert != "") {
													int x = pData->wrenchedBlockLocation % world->width;
													int y = pData->wrenchedBlockLocation / world->width;
													if (world->isPublic || isWorldAdmin(peer, world) || isWorldOwner(peer, world) || world->owner == "" || isDev(peer) || !restricted_area(peer, world, x, y)) {
														bool invert = false;
														if (stuff_invert == "1") invert = true;
														bool spin = false;
														if (stuff_spin == "1") spin = true;
														if (world->items.at(x + (y * world->width)).mc == atoi(stuff_gravity.c_str()) && world->items.at(x + (y * world->width)).opened == invert && world->items.at(x + (y * world->width)).rm == spin) {
															if (world->items.at(x + (y * world->width)).intdata == atoi(stuffITEM.c_str()) || stuffITEM == "") {
																break;
															}
														}
														if (stuffITEM != "") {
															world->items.at(x + (y * world->width)).intdata = atoi(stuffITEM.c_str());
														}
														world->items.at(x + (y * world->width)).mc = atoi(stuff_gravity.c_str());
														world->items.at(x + (y * world->width)).opened = invert;
														world->items.at(x + (y * world->width)).rm = spin;
														sendStuffweather(peer, x, y, world->items.at(x + (y * world->width)).intdata, world->items.at(x + (y * world->width)).mc, world->items.at(x + (y * world->width)).rm, world->items.at(x + (y * world->width)).opened);
														if (world->items.at(x + (y * world->width)).activated) {
															for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
																if (isHere(peer, currentPeer)) {
																	Player::OnSetCurrentWeather(currentPeer, 29);
																}
															}
														}
													}
													break;
												}
											}
											if (isMagCheckDialog) {
												if (infoDat.at(0) == "checkbox_gemcollection") {
													if (infoDat.at(1) == "1") {
														int x = pData->lastPunchX;
														int y = pData->lastPunchY;
														world->items.at(x + (y * world->width)).mid = 112;
														ENetPeer* currentPeer;
														for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
															if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
															if (isHere(peer, currentPeer)) {
																send_item_sucker(currentPeer, 5638, x, y, 112, 0, true, true, world->items.at(x + (y * world->width)).background);
															}
														}
													} 
													break;
												}
											}
											if (isMagDialog) {
												if (world == nullptr || pData->currentWorld == "EXIT" || serverIsFrozen || pData->rawName != world->owner && !isMod(peer) && world->owner != "") break;
												int magplantitemi = 0;
												int x = pData->lastPunchX;
												int y = pData->lastPunchY;
												int suckerid = pData->suckerid;
												string suckername = pData->suckername;
												if (infoDat.at(0) == "magplantitem") magplantitem = infoDat.at(1);
												magplantitemi = atoi(magplantitem.c_str());
												bool allow = true;
												for (int i = 0; i < world->width * world->height; i++) {
													if (world->items.at(i).foreground == 5638 || world->items.at(i).foreground == 6946 || world->items.at(i).foreground == 6948) {
														string SuckerName3 = "";
														if (world->items.at(i).foreground == 5638) SuckerName3 = "magplant";
														if (world->items.at(i).foreground == 6946) SuckerName3 = "gaiabeacon";
														if (world->items.at(i).foreground == 6948) SuckerName3 = "unstabletesseract";
														if (magplantitemi == world->items.at(i).mid) allow = false;
													}
												}
												if (magplantitemi == 18 || magplantitemi == 32 || magplantitemi == 7188 || magplantitemi == 1796 || magplantitemi == 242 || getItemDef(magplantitemi).properties & Property_Untradable || getItemDef(magplantitemi).blockType == BlockTypes::LOCK) {
													Player::OnTalkBubble(peer, pData->netID, "You cannot use this item in " + getItemDef(suckerid).name + "!", 0, true);
												}
												else if (suckerid == 6946 && !isSeed(magplantitemi)) {
													Player::OnTalkBubble(peer, pData->netID, getItemDef(suckerid).name + " supports only seeds!", 0, true);
												}
												else if (suckerid == 6948 && getItemDef(magplantitemi).blockType != BlockTypes::FOREGROUND && getItemDef(magplantitemi).blockType != BlockTypes::PAIN_BLOCK && getItemDef(magplantitemi).blockType != BlockTypes::GROUND_BLOCK && getItemDef(magplantitemi).blockType != BlockTypes::BACKGROUND) {
													Player::OnTalkBubble(peer, pData->netID, getItemDef(suckerid).name + " supports only foregrounds or backgrounds!", 0, true);
												}
												else if (allow == false) {
													Player::OnTalkBubble(peer, pData->netID, "There is already Item Sucker with such item!", 0, true);
												}
												else {
													auto contains = false;
													SearchInventoryItem(peer, magplantitemi, 1, contains);
													if (!contains) break;
													ENetPeer* currentPeer;
													for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
														if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
														if (isHere(peer, currentPeer)) {
															send_item_sucker(currentPeer, suckerid, x, y, magplantitemi, 0, true, true, world->items.at(x + (y * world->width)).background);
														}
													}
													world->items.at(x + (y * world->width)).mid = magplantitemi;
													world->items.at(x + (y * world->width)).mc = 0;
												}
											}
											if (isTeleDialog)
											{
												if (world == nullptr || pData->currentWorld == "EXIT" || serverIsFrozen) continue;
												if (infoDat.at(0) == "telephonenumber")
												{
													telefonas = infoDat.at(1);
													if (telefonas.size() > 5 || telefonas.size() <= 0 || telefonas.size() < 5)
													{
														continue;
													}

													if (telefonas == "12345")              
													{
														auto quantityinBP = 0;
														auto quantityinBP2 = 0;
														std::ifstream ifsz("save/dailyquest/dailyitem1.txt");
														std::string content((std::istreambuf_iterator<char>(ifsz)),
															(std::istreambuf_iterator<char>()));
														int id = atoi(content.c_str());
														std::ifstream ifsz2("save/dailyquest/dailyitem2.txt");
														std::string content2((std::istreambuf_iterator<char>(ifsz2)),
															(std::istreambuf_iterator<char>()));
														int id2 = atoi(content2.c_str());
														std::ifstream ifszs("save/dailyquest/dailycount1.txt");
														std::string contents((std::istreambuf_iterator<char>(ifszs)),
															(std::istreambuf_iterator<char>()));
														int quantity = atoi(contents.c_str());
														std::ifstream ifszs2("save/dailyquest/dailycount2.txt");
														std::string contents2((std::istreambuf_iterator<char>(ifszs2)),
															(std::istreambuf_iterator<char>()));
														int quantity2 = atoi(contents2.c_str());
														bool iscontain1 = false;
														bool iscontain2 = false;
														for (auto i = 0; i < static_cast<PlayerInfo*>(peer->data)->inventory.items.size(); i++) {
															if (static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemID == id && static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount >= 1) {
																quantityinBP = static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount;
															}

															if (static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemID == id2 && static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount >= 1) {
																quantityinBP2 = static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount;
															}
														}
														bool dq = std::experimental::filesystem::exists("save/dailyquest/completed/_" + ((PlayerInfo*)(peer->data))->rawName + ".txt");
														SearchInventoryItem(peer, id, quantity, iscontain1);
														SearchInventoryItem(peer, id2, quantity2, iscontain2);
														if (dq == true) {
															Player::OnDialogRequest(peer, "add_label_with_icon|big|`wCrazy Jim's Daily Quest``|left|3902|\nadd_textbox|I guess some people call me Crazy Jim because I'm a bit of a hoarder. But I'm very particular about what I want! And today, what I want is this:|left|\nadd_label_with_icon|small|`2" + to_string(quantity) + " " + getItemDef(id).name + "|" + "left" + "|" + to_string(id) + "|\nadd_smalltext|and|left|\nadd_label_with_icon|small|`2" + to_string(quantity2) + " " + getItemDef(id2).name + "|" + "left" + "|" + to_string(id2) + "|\nadd_spacer|small|\nadd_smalltext|You completed the daily quest for today! Welcome back later!|left|\nadd_button|chc0|Back|noflags|0|0|\nend_dialog|phonecall|Hang Up||");
														}

														if (iscontain1 && iscontain2) {
															Player::OnDialogRequest(peer, "add_label_with_icon|big|`wCrazy Jim's Daily Quest``|left|3902|\nadd_textbox|I guess some people call me Crazy Jim because I'm a bit of a hoarder. But I'm very particular about what I want! And today, what I want is this:|left|\nadd_label_with_icon|small|`2" + to_string(quantity) + " " + getItemDef(id).name + "|" + "left" + "|" + to_string(id) + "|\nadd_smalltext|and|left|\nadd_label_with_icon|small|`2" + to_string(quantity2) + " " + getItemDef(id2).name + "|" + "left" + "|" + to_string(id2) + "|\nadd_spacer|small|\nadd_smalltext|You shove all that through the phone (it works, I've tried it), and I will hand you one of the `2Growtokens`` from my personal collection!  But hurry, this offer is only good until midnight, and only one `2Growtoken`` per person!|left|\nadd_smalltext|`6(You have " + to_string(quantityinBP) + " " + getItemDef(id).name + " and " + to_string(quantityinBP2) + " " + getItemDef(id2).name + ")``|left|\nadd_button|getgtokenok|CLAIM!|noflags|0|0|\nend_dialog|phonecall|Hang Up||");
														}

														if (!iscontain1 && !iscontain2)
														{
															Player::OnDialogRequest(peer, "add_label_with_icon|big|`wCrazy Jim's Daily Quest``|left|3902|\nadd_textbox|I guess some people call me Crazy Jim because I'm a bit of a hoarder. But I'm very particular about what I want! And today, what I want is this:|left|\nadd_label_with_icon|small|`2" + to_string(quantity) + " " + getItemDef(id).name + "|" + "left" + "|" + to_string(id) + "|\nadd_smalltext|and|left|\nadd_label_with_icon|small|`2" + to_string(quantity2) + " " + getItemDef(id2).name + "|" + "left" + "|" + to_string(id2) + "|\nadd_spacer|small|\nadd_smalltext|You shove all that through the phone (it works, I've tried it), and I will hand you one of the `2Growtokens`` from my personal collection!  But hurry, this offer is only good until midnight, and only one `2Growtoken`` per person!|left|\nadd_smalltext|`6(You have " + to_string(quantityinBP) + " " + getItemDef(id).name + " and " + to_string(quantityinBP2) + " " + getItemDef(id2).name + ")``|left|\nadd_button|chc0|Back|noflags|0|0|\nend_dialog|phonecall|Hang Up||");
														}

														if (quantityinBP < quantity || quantityinBP2 < quantity2) {
															Player::OnDialogRequest(peer, "add_label_with_icon|big|`wCrazy Jim's Daily Quest``|left|3902|\nadd_textbox|I guess some people call me Crazy Jim because I'm a bit of a hoarder. But I'm very particular about what I want! And today, what I want is this:|left|\nadd_label_with_icon|small|`2" + to_string(quantity) + " " + getItemDef(id).name + "|" + "left" + "|" + to_string(id) + "|\nadd_smalltext|and|left|\nadd_label_with_icon|small|`2" + to_string(quantity2) + " " + getItemDef(id2).name + "|" + "left" + "|" + to_string(id2) + "|\nadd_spacer|small|\nadd_smalltext|You shove all that through the phone (it works, I've tried it), and I will hand you one of the `2Growtokens`` from my personal collection!  But hurry, this offer is only good until midnight, and only one `2Growtoken`` per person!|left|\nadd_smalltext|`6(You have " + to_string(quantityinBP) + " " + getItemDef(id).name + " and " + to_string(quantityinBP2) + " " + getItemDef(id2).name + ")``|left|\nadd_button|chc0|Back|noflags|0|0|\nend_dialog|phonecall|Hang Up||");
														}
													}
													else
													{
														bool okehh = false;
														auto need = 100;
														auto quantityinBP = 0;
														for (auto i = 0; i < static_cast<PlayerInfo*>(peer->data)->inventory.items.size(); i++) {
															if (static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemID == 1796 && static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount >= 1) {
																quantityinBP = static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount;
															}
														}
														SearchInventoryItem(peer, 1796, 100, okehh);
														if (okehh) {
															Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wConvert DL-BGL``|left|7188|\nadd_textbox|You can convert your diamond locks if you have 100 Diamond Locks.|left|\nadd_button|convertdl|`$Convert DL TO BGL|left|\nend_dialog|phonecall|Hang Up||");
														}
														else
														{
															Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wConvert DL-BGL``|left|7188|\nadd_textbox|You can convert your diamond locks if you have 100 Diamond Locks.|left|\nadd_smalltext|`o(You got `9" + to_string(quantityinBP) + "`o Diamond Locks)|left|\nadd_smalltext|`oYou are `9" + to_string(need - quantityinBP) + " `oDiamond Locks short to convert to Blue Gem Lock.|left|\nadd_spacer|small|\nend_dialog|phonecall|Hang Up||");
														}
													}
												}
											}
											if (isCaveDialog) {
												if (infoDat.at(0) == "cavename") {
													string upsd = infoDat.at(1);
													string act = infoDat.at(1);
													std::transform(upsd.begin(), upsd.end(), upsd.begin(), ::toupper);
													if (act == "" || act == "\\" || act.find("\\") != string::npos || act.find(" ") != string::npos || act.find("  ") != string::npos || act.find(".") != string::npos || act.find("?") != string::npos || act.find(",") != string::npos || act.find("@") != string::npos || act.find("[") != string::npos || act.find("]") != string::npos || act.find("#") != string::npos || act.find("<") != string::npos || act.find(">") != string::npos || act.find(":") != string::npos || act.find("\"") != string::npos || act.find("{") != string::npos || act.find("}") != string::npos || act.find("|") != string::npos || act.find("+") != string::npos || act.find("_") != string::npos || act.find("~") != string::npos || act.find("-") != string::npos || act.find("!") != string::npos || act.find("$") != string::npos || act.find("%") != string::npos || act.find("^") != string::npos || act.find("&") != string::npos || act.find("`") != string::npos || act.find("*") != string::npos || act.find("(") != string::npos || act.find(")") != string::npos || act.find("=") != string::npos || act.find("'") != string::npos || act.find(";") != string::npos || act.find("/") != string::npos) {
														Player::OnTalkBubble(peer, pData->netID, "Sorry, a world name can't contain special characters or spaces.", 0, false);
														continue;
													}
													if (!world_exist(upsd)) {
														if (upsd.find_first_not_of("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789") != string::npos) {
															Player::OnTalkBubble(peer, pData->netID, "Sorry, a world name can't contain special characters or spaces.", 0, false);
															continue;
														}
														if (upsd.find(" ") != string::npos) {
															Player::OnTalkBubble(peer, pData->netID, "Sorry, a world name can't contain special characters or spaces.", 0, false);
															continue;
														}
														if (upsd == "EXIT") {
															Player::OnTalkBubble(peer, pData->netID, "That world name already exists.  You'll have to be more original.  Maybe add some numbers after it?", 0, false);
															Player::OnConsoleMessage(peer, "That world name already exists.  You'll have to be more original.  Maybe add some numbers after it?");
															continue;
														}
														if (upsd == pData->currentWorld) {
															Player::OnTalkBubble(peer, pData->netID, "That world name already exists.  You'll have to be more original.  Maybe add some numbers after it?", 0, false);
															Player::OnConsoleMessage(peer, "That world name already exists.  You'll have to be more original.  Maybe add some numbers after it?");
															continue;
														}
														RemoveInventoryItem(3562, 1, peer, true);
														usedcaveblast = true;
														WorldInfo info = worldDB.get(upsd);
														if (info.name == "error") {
															Player::OnConsoleMessage(peer, "An error occured while trying to enter this world, please try again!");
															continue;
														}
														string act = upsd;
														for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
															if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
															if (isHere(peer, currentPeer)) {
																Player::OnTalkBubble(currentPeer, pData->netID, "`5** " + pData->displayName + " `5activates a Cave Blast! `5**", 0, false);
																Player::OnConsoleMessage(currentPeer, "`5** " + pData->displayName + " `5activates a Cave Blast! `5**");
															}
														}
														handle_world(peer, act);
													} else {
														Player::OnTalkBubble(peer, pData->netID, "That world name already exists.  You'll have to be more original.  Maybe add some numbers after it?", 0, false);
														Player::OnConsoleMessage(peer, "That world name already exists.  You'll have to be more original.  Maybe add some numbers after it?");
													}
												}
											}
											if (isTinyDialog) {
												if (infoDat.at(0) == "tinyname") {
													tinynames = infoDat.at(1);
													string upsd = tinynames;
													string act = tinynames;
													std::transform(upsd.begin(), upsd.end(), upsd.begin(), ::toupper);
													if (act == "" || act == "\\" || act.find("\\") != string::npos || act.find(" ") != string::npos || act.find("  ") != string::npos || act.find(".") != string::npos || act.find("?") != string::npos || act.find(",") != string::npos || act.find("@") != string::npos || act.find("[") != string::npos || act.find("]") != string::npos || act.find("#") != string::npos || act.find("<") != string::npos || act.find(">") != string::npos || act.find(":") != string::npos || act.find("\"") != string::npos || act.find("{") != string::npos || act.find("}") != string::npos || act.find("|") != string::npos || act.find("+") != string::npos || act.find("_") != string::npos || act.find("~") != string::npos || act.find("-") != string::npos || act.find("!") != string::npos || act.find("$") != string::npos || act.find("%") != string::npos || act.find("^") != string::npos || act.find("&") != string::npos || act.find("`") != string::npos || act.find("*") != string::npos || act.find("(") != string::npos || act.find(")") != string::npos || act.find("=") != string::npos || act.find("'") != string::npos || act.find(";") != string::npos || act.find("/") != string::npos) {
														Player::OnTalkBubble(peer, pData->netID, "Sorry, a world name can't contain special characters or spaces.", 0, false);
														continue;
													}
													if (!world_exist(upsd)) {
														if (upsd.find_first_not_of("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789") != string::npos) {
															Player::OnTalkBubble(peer, pData->netID, "Sorry, a world name can't contain special characters or spaces.", 0, false);
															continue;
														}
														if (upsd.find(" ") != string::npos) {
															Player::OnTalkBubble(peer, pData->netID, "Sorry, a world name can't contain special characters or spaces.", 0, false);
															continue;
														}
														if (upsd == "EXIT") {
															Player::OnTalkBubble(peer, pData->netID, "That world name already exists.  You'll have to be more original.  Maybe add some numbers after it?", 0, false);
															Player::OnConsoleMessage(peer, "That world name already exists.  You'll have to be more original.  Maybe add some numbers after it?");
															continue;
														}
														if (upsd == pData->currentWorld) {
															Player::OnTalkBubble(peer, pData->netID, "That world name already exists.  You'll have to be more original.  Maybe add some numbers after it?", 0, false);
															Player::OnConsoleMessage(peer, "That world name already exists.  You'll have to be more original.  Maybe add some numbers after it?");
															continue;
														}
														RemoveInventoryItem(7784, 1, peer, true);
														usedtinyblast = true;
														WorldInfo info = worldDB.get(tinynames);
														if (info.name == "error") {
															Player::OnConsoleMessage(peer, "An error occured while trying to enter this world, please try again!");
															continue;
														}
														string act = tinynames;
														for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
															if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
															if (isHere(peer, currentPeer)) {
																Player::OnTalkBubble(currentPeer, pData->netID, "`5** " + pData->displayName + " `5activates a Tiny Blast! `5**", 0, false);
																Player::OnConsoleMessage(currentPeer, "`5** " + pData->displayName + " `5activates a Tiny Blast! `5**");
															}
														}
														handle_world(peer, act);
													} else {
														Player::OnTalkBubble(peer, pData->netID, "That world name already exists.  You'll have to be more original.  Maybe add some numbers after it?", 0, false);
														Player::OnConsoleMessage(peer, "That world name already exists.  You'll have to be more original.  Maybe add some numbers after it?");
													}
												}
											}
											if (isBeachDialog) {
												if (infoDat.at(0) == "beachname") {
													beachnames = infoDat.at(1);
													string upsd = beachnames;
													string act = beachnames;
													std::transform(upsd.begin(), upsd.end(), upsd.begin(), ::toupper);
													if (act == "" || act == "\\" || act.find("\\") != string::npos || act.find(" ") != string::npos || act.find("  ") != string::npos || act.find(".") != string::npos || act.find("?") != string::npos || act.find(",") != string::npos || act.find("@") != string::npos || act.find("[") != string::npos || act.find("]") != string::npos || act.find("#") != string::npos || act.find("<") != string::npos || act.find(">") != string::npos || act.find(":") != string::npos || act.find("\"") != string::npos || act.find("{") != string::npos || act.find("}") != string::npos || act.find("|") != string::npos || act.find("+") != string::npos || act.find("_") != string::npos || act.find("~") != string::npos || act.find("-") != string::npos || act.find("!") != string::npos || act.find("$") != string::npos || act.find("%") != string::npos || act.find("^") != string::npos || act.find("&") != string::npos || act.find("`") != string::npos || act.find("*") != string::npos || act.find("(") != string::npos || act.find(")") != string::npos || act.find("=") != string::npos || act.find("'") != string::npos || act.find(";") != string::npos || act.find("/") != string::npos) {
														Player::OnTalkBubble(peer, pData->netID, "Sorry, a world name can't contain special characters or spaces.", 0, false);
														continue;
													}
													if (!world_exist(upsd)) {
														if (upsd.find_first_not_of("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789") != string::npos) {
															Player::OnTalkBubble(peer, pData->netID, "Sorry, a world name can't contain special characters or spaces.", 0, false);
															continue;
														}
														if (upsd.find(" ") != string::npos) {
															Player::OnTalkBubble(peer, pData->netID, "Sorry, a world name can't contain special characters or spaces.", 0, false);
															continue;
														}
														if (upsd == "EXIT") {
															Player::OnTalkBubble(peer, pData->netID, "That world name already exists.  You'll have to be more original.  Maybe add some numbers after it?", 0, false);
															Player::OnConsoleMessage(peer, "That world name already exists.  You'll have to be more original.  Maybe add some numbers after it?");
															continue;
														}
														if (upsd == pData->currentWorld) {
															Player::OnTalkBubble(peer, pData->netID, "That world name already exists.  You'll have to be more original.  Maybe add some numbers after it?", 0, false);
															Player::OnConsoleMessage(peer, "That world name already exists.  You'll have to be more original.  Maybe add some numbers after it?");
															continue;
														}
														RemoveInventoryItem(830, 1, peer, true);
														usedbeachblast = true;
														WorldInfo info = worldDB.get(beachnames);
														string act = beachnames;
														for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
															if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
															if (isHere(peer, currentPeer)) {
															}
														}
														handle_world(peer, act);
													}
													else {
														Player::OnTalkBubble(peer, pData->netID, "That world name already exists.  You'll have to be more original.  Maybe add some numbers after it?", 0, false);
														Player::OnConsoleMessage(peer, "That world name already exists.  You'll have to be more original.  Maybe add some numbers after it?");
													}
												}
											}
											if (isThermoDialog) {
												if (infoDat.at(0) == "thermoname") {
													thermonames = infoDat.at(1);
													string upsd = thermonames;
													string act = thermonames;
													std::transform(upsd.begin(), upsd.end(), upsd.begin(), ::toupper);
													if (act == "" || act == "\\" || act.find("\\") != string::npos || act.find(" ") != string::npos || act.find("  ") != string::npos || act.find(".") != string::npos || act.find("?") != string::npos || act.find(",") != string::npos || act.find("@") != string::npos || act.find("[") != string::npos || act.find("]") != string::npos || act.find("#") != string::npos || act.find("<") != string::npos || act.find(">") != string::npos || act.find(":") != string::npos || act.find("\"") != string::npos || act.find("{") != string::npos || act.find("}") != string::npos || act.find("|") != string::npos || act.find("+") != string::npos || act.find("_") != string::npos || act.find("~") != string::npos || act.find("-") != string::npos || act.find("!") != string::npos || act.find("$") != string::npos || act.find("%") != string::npos || act.find("^") != string::npos || act.find("&") != string::npos || act.find("`") != string::npos || act.find("*") != string::npos || act.find("(") != string::npos || act.find(")") != string::npos || act.find("=") != string::npos || act.find("'") != string::npos || act.find(";") != string::npos || act.find("/") != string::npos) {
														Player::OnTalkBubble(peer, pData->netID, "Sorry, a world name can't contain special characters or spaces.", 0, false);
														continue;
													}
													if (!world_exist(upsd)) {
														if (upsd.find_first_not_of("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789") != string::npos) {
															Player::OnTalkBubble(peer, pData->netID, "Sorry, a world name can't contain special characters or spaces.", 0, false);
															continue;
														}
														if (upsd.find(" ") != string::npos) {
															Player::OnTalkBubble(peer, pData->netID, "Sorry, a world name can't contain special characters or spaces.", 0, false);
															continue;
														}
														if (upsd == "EXIT") {
															Player::OnTalkBubble(peer, pData->netID, "That world name already exists.  You'll have to be more original.  Maybe add some numbers after it?", 0, false);
															Player::OnConsoleMessage(peer, "That world name already exists.  You'll have to be more original.  Maybe add some numbers after it?");
															continue;
														}
														if (upsd == pData->currentWorld) {
															Player::OnTalkBubble(peer, pData->netID, "That world name already exists.  You'll have to be more original.  Maybe add some numbers after it?", 0, false);
															Player::OnConsoleMessage(peer, "That world name already exists.  You'll have to be more original.  Maybe add some numbers after it?");
															continue;
														}
														RemoveInventoryItem(1402, 1, peer, true);
														usedthermoblast = true;
														WorldInfo info = worldDB.get(thermonames);
														if (info.name == "error") {
															Player::OnConsoleMessage(peer, "An error occured while trying to enter this world, please try again!");
															continue;
														}
														string act = thermonames;
														for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
															if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
															if (isHere(peer, currentPeer)) {
																Player::OnTalkBubble(currentPeer, pData->netID, "`5** " + pData->displayName + " `5activates a Thermonuclear Blast! `5**", 0, false);
																Player::OnConsoleMessage(currentPeer, "`5** " + pData->displayName + " `5activates a Thermonuclear Blast! `5**");
															}
														}
														handle_world(peer, act);
													} else {
														Player::OnTalkBubble(peer, pData->netID, "That world name already exists.  You'll have to be more original.  Maybe add some numbers after it?", 0, false);
														Player::OnConsoleMessage(peer, "That world name already exists.  You'll have to be more original.  Maybe add some numbers after it?");
													}
												}
											}
											if (isLargeDialog) {
												if (infoDat.at(0) == "largename") {
													largenames = infoDat.at(1);
													string upsd = largenames;
													string act = largenames;
													std::transform(upsd.begin(), upsd.end(), upsd.begin(), ::toupper);
													if (act == "" || act == "\\" || act.find("\\") != string::npos || act.find(" ") != string::npos || act.find("  ") != string::npos || act.find(".") != string::npos || act.find("?") != string::npos || act.find(",") != string::npos || act.find("@") != string::npos || act.find("[") != string::npos || act.find("]") != string::npos || act.find("#") != string::npos || act.find("<") != string::npos || act.find(">") != string::npos || act.find(":") != string::npos || act.find("\"") != string::npos || act.find("{") != string::npos || act.find("}") != string::npos || act.find("|") != string::npos || act.find("+") != string::npos || act.find("_") != string::npos || act.find("~") != string::npos || act.find("-") != string::npos || act.find("!") != string::npos || act.find("$") != string::npos || act.find("%") != string::npos || act.find("^") != string::npos || act.find("&") != string::npos || act.find("`") != string::npos || act.find("*") != string::npos || act.find("(") != string::npos || act.find(")") != string::npos || act.find("=") != string::npos || act.find("'") != string::npos || act.find(";") != string::npos || act.find("/") != string::npos) {
														Player::OnTalkBubble(peer, pData->netID, "Sorry, a world name can't contain special characters or spaces.", 0, false);
														continue;
													}
													if (!world_exist(upsd)) {
														if (upsd.find_first_not_of("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789") != string::npos) {
															Player::OnTalkBubble(peer, pData->netID, "Sorry, a world name can't contain special characters or spaces.", 0, false);
															continue;
														}
														if (upsd.find(" ") != string::npos) {
															Player::OnTalkBubble(peer, pData->netID, "Sorry, a world name can't contain special characters or spaces.", 0, false);
															continue;
														}
														if (upsd == "EXIT") {
															Player::OnTalkBubble(peer, pData->netID, "That world name already exists.  You'll have to be more original.  Maybe add some numbers after it?", 0, false);
															Player::OnConsoleMessage(peer, "That world name already exists.  You'll have to be more original.  Maybe add some numbers after it?");
															continue;
														}
														if (upsd == pData->currentWorld) {
															Player::OnTalkBubble(peer, pData->netID, "That world name already exists.  You'll have to be more original.  Maybe add some numbers after it?", 0, false);
															Player::OnConsoleMessage(peer, "That world name already exists.  You'll have to be more original.  Maybe add some numbers after it?");
															continue;
														}
														RemoveInventoryItem(7562, 1, peer, true);
														usedlargeblast = true;
														WorldInfo info = worldDB.get(largenames);
														if (info.name == "error") {
															Player::OnConsoleMessage(peer, "An error occured while trying to enter this world, please try again!");
															continue;
														}
														string act = largenames;
														ENetPeer* currentPeer;
														for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
															if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
															if (isHere(peer, currentPeer)) {
																Player::OnTalkBubble(currentPeer, pData->netID, "`5** " + pData->displayName + " `5activates a Large Blast! `5**", 0, false);
																Player::OnConsoleMessage(currentPeer, "`5** " + pData->displayName + " `5activates a Large Blast! `5**");
															}
														}
														handle_world(peer, act);
													} else {
														Player::OnTalkBubble(peer, pData->netID, "That world name already exists.  You'll have to be more original.  Maybe add some numbers after it?", 0, false);
														Player::OnConsoleMessage(peer, "That world name already exists.  You'll have to be more original.  Maybe add some numbers after it?");
													}
												}
											}
											/*if (isGuildDialog) {
												if (world == nullptr || pData->currentWorld == "EXIT" || serverIsFrozen) continue;
												if (infoDat.at(0) == "gname") guild_name = infoDat.at(1);
												if (infoDat.at(0) == "gstatement") guild_statement = infoDat.at(1);
												if (infoDat.at(0) == "ggcflagbg") guild_mascot_bg = infoDat.at(1);
												if (infoDat.at(0) == "ggcflagfg") {
													guild_mascot_fg = infoDat.at(1);
													int GCState = PlayerDB::guildRegister(peer, guild_name, guild_statement, guild_mascot_bg, guild_mascot_fg);
													switch (GCState) {
														case -1:
														{
															Player::OnConsoleMessage(peer, "");
															break;
														}
														case -2:
														{
															Player::OnConsoleMessage(peer, "");
															break;
														}
														case -3:
														{
															Player::OnConsoleMessage(peer, "");
															break;
														}
														case -4:
														{
															Player::OnConsoleMessage(peer, "");
															break;
														}
														case -5:
														{
															Player::OnConsoleMessage(peer, "");
															break;
														}
														case -6:
														{
															Player::OnConsoleMessage(peer, "");
															break;
														}
														case -7:
														{
															Player::OnConsoleMessage(peer, "");
															break;
														}
														case -8:
														{
															Player::OnConsoleMessage(peer, "");
															break;
														}
														case 1:
														{
															Player::OnConsoleMessage(peer, "");
															break;
														}
														default: break;
													}
												}
											}*/
											if (isRegisterDialog) {
												if (infoDat.at(0) == "username") register_username = infoDat.at(1);
												if (infoDat.at(0) == "password") register_password = infoDat.at(1);
												if (infoDat.at(0) == "password_verify") register_password_verify = infoDat.at(1);
												if (infoDat.at(0) == "email") {
													register_email = infoDat.at(1);
													if (register_password != register_password_verify) {
														Player::OnTalkBubble(peer, pData->netID, "Passwords dont match!", 0, true);
														break;
													}
													auto regState = PlayerDB::playerRegister(peer, register_username, register_password, register_email);
													switch (regState) {
														case 1:
														{
															GamePacket p8 = packetEnd(appendString(appendString(appendInt(appendString(createPacket(), "SetHasGrowID"), 1), register_username), register_password));
															ENetPacket* packet8 = enet_packet_create(p8.data, p8.len, ENET_PACKET_FLAG_RELIABLE);
															enet_peer_send(peer, 0, packet8);
															delete p8.data;
															pData->displayName = register_username;
															pData->tankIDName = register_username;
															pData->tankIDPass = register_password;
															pData->rawName = PlayerDB::getProperName(pData->tankIDName);
															pData->msgName = PlayerDB::getProperName(pData->tankIDName);
															pData->haveGrowId = true;
															pData->HasLogged = true;
															pData->effect = 8421376;
															Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wGrowID GET!``|left|206|\nadd_textbox|A `wGrowID`` with the log on of `w" + pData->displayName + "`` created.  Write it and your password down as they will be required to log on from now on!|left|\nadd_spacer|small|\nadd_button|sendDialogATPS|Continue|");
															Player::PlayAudio(peer, "audio/piano_nice.wav", 150);
															time_t currentTime;
															time(&currentTime);
															const auto localTime = localtime(&currentTime);
															const auto Hour = localTime->tm_hour; const auto Min = localTime->tm_min; const auto Sec = localTime->tm_sec; const auto Year = localTime->tm_year + 1900; const auto Day = localTime->tm_mday; const auto Month = localTime->tm_mon + 1;
															ofstream Dayz("save/registered/_" + ((PlayerInfo*)(peer->data))->rawName + ".txt");
															Dayz << to_string(Year) << endl;
															Dayz << to_string(Month) << endl;
															Dayz << to_string(Day) << endl;
															Dayz.close();
															ofstream myfile;
															myfile.open("save/gemdb/_" + pData->rawName + ".txt");
															myfile << 500000; // change new get here
															myfile.close();
															Player::OnSetBux(peer, 500000, 1);
															Player::OnNameChanged(peer, pData->netID, register_username);
															string textInfo = "`1[Register-Logs] `oFrom: " + pData->displayName + " at " + currentDateTime() + " Name: `2" + pData->displayName + " `oWith IP: `2" + pData->charIP + ".";
															showModLogs(textInfo);
															LoadPlayerData(peer);
															DailyRewardCheck(peer);
															break;
														}
														case -1:
														{
															Player::OnTalkBubble(peer, pData->netID, "This account already exists!", 0, true);
															break;
														}
														case -2:
														{
															Player::OnTalkBubble(peer, pData->netID, "Incorrect email address, make sure to submit real one!", 0, true);
															break;
														}
														case -3:
														{
															Player::OnTalkBubble(peer, pData->netID, "Username or password is too long!", 0, true);
															break;
														}
														case -4:
														{
															Player::OnTalkBubble(peer, pData->netID, "Username or password cannot contain spaces or symbols!", 0, true);
															break;
														}
														case -5:
														{
															Player::OnTalkBubble(peer, pData->netID, "Failed to create new account please try again!", 0, true);
															break;
														}
														case -6:
														{
															Player::OnTalkBubble(peer, pData->netID, "Too much accounts are crated from this device or location!", 0, true);
															break;
														}
													}
												}
											}
										}
									}
								}										
								catch (const std::out_of_range& e) {
									std::cout << e.what() << std::endl;
								}
								int x = static_cast<PlayerMoving*>(peer->data)->punchX;
								int y = static_cast<PlayerMoving*>(peer->data)->punchY;
								int causedBy = static_cast<PlayerMoving*>(peer->data)->netID;
								int tile = static_cast<PlayerMoving*>(peer->data)->plantingTree;
								if (btn.substr(0, 23) == "removeselectedbulletin_")
								{
									if (world == nullptr || pData->currentWorld == "EXIT" || serverIsFrozen) continue;
									if (pData->rawName == world->owner || world->owner == "" || isMod(peer))
									{
										string coord, apos;
										string coord_and_apos = btn.erase(0, 23);
										string::size_type pos = coord_and_apos.find('_');
										if (pos != std::string::npos)
										{
											coord = coord_and_apos.substr(0, pos);
											coord_and_apos.erase(0, pos + 1);
											apos = coord_and_apos;
										}
										else
										{
											break;
										}
										auto isdbox = std::experimental::filesystem::exists("save/bulletinboard/_" + pData->currentWorld + "/X" + coord + ".json");
										if (!isdbox)
										{
											Player::OnTalkBubble(peer, pData->netID, "`4An error occured while getting safe bulletin board.", 0, true);
											break;
										}

										bool contains_non_int3 = !std::regex_match(apos, std::regex("^[0-9]+$"));
										if (contains_non_int3 == true)
										{
											break;
										}
										int apos_int = atoi(apos.c_str());
										if (apos_int < 1 || apos_int > 90)
										{
											break;
										}
										try
										{
											ifstream ifff("save/bulletinboard/_" + pData->currentWorld + "/X" + coord + ".json");
											json j;
											ifff >> j;
											ifff.close();
											string tekstas = j["mails"][static_cast<nlohmann::basic_json<std::map, std::vector, std::string, bool, int64_t, uint64_t, double, std::allocator, nlohmann::adl_serializer>::size_type>(apos_int) - 1]["text"];
											GTDialog myLetterBox;
											myLetterBox.addLabelWithIcon("`oRemove \"" + tekstas + "\" from your board?", 658, LABEL_BIG);
											myLetterBox.addButton("Confirmremoveselectedbulletin_" + coord + "_" + apos, "`wOK");
											myLetterBox.addSpacer(SPACER_SMALL);
											myLetterBox.addQuickExit();
											myLetterBox.endDialog("Close", "", "Cancel");
											Player::OnDialogRequest(peer, myLetterBox.finishDialog());
										}
										catch (std::exception& e) 
										{
											std::cout << e.what() << std::endl;
											break; /*tipo jeigu nera*/
										}
									}
								}
								if (btn.substr(0, 30) == "Confirmremoveselectedbulletin_")
								{
									if (world == nullptr || pData->currentWorld == "EXIT" || serverIsFrozen) continue;
									if (pData->rawName == world->owner || world->owner == "" || isMod(peer))
									{
										string coord, apos;
										string coord_and_apos = btn.erase(0, 30);
										string::size_type pos = coord_and_apos.find('_');
										if (pos != std::string::npos)
										{
											coord = coord_and_apos.substr(0, pos);
											coord_and_apos.erase(0, pos + 1);
											apos = coord_and_apos;
										}
										else
										{
											break;
										}
										auto isdbox = std::experimental::filesystem::exists("save/bulletinboard/_" + pData->currentWorld + "/X" + coord + ".json");
										if (!isdbox)
										{
											Player::OnTalkBubble(peer, pData->netID, "`4An error occured while getting safe bulletin board.", 0, true);
											break;
										}

										bool contains_non_int3 = !std::regex_match(apos, std::regex("^[0-9]+$"));
										if (contains_non_int3 == true)
										{
											break;
										}
										int apos_int = atoi(apos.c_str());
										if (apos_int < 1 || apos_int > 90)
										{
											break;
										}
										try
										{
											ifstream ifff("save/bulletinboard/_" + pData->currentWorld + "/X" + coord + ".json");
											json j;
											ifff >> j;
											ifff.close();
											int inmail = j["inmail"];
											j["inmail"] = inmail - 1;
											j["mails"][static_cast<nlohmann::basic_json<std::map, std::vector, std::string, bool, int64_t, uint64_t, double, std::allocator, nlohmann::adl_serializer>::size_type>(apos_int) - 1]["text"] = "";
											j["mails"][static_cast<nlohmann::basic_json<std::map, std::vector, std::string, bool, int64_t, uint64_t, double, std::allocator, nlohmann::adl_serializer>::size_type>(apos_int) - 1]["growid"] = "";
											Player::OnTalkBubble(peer, pData->netID, "`2Bulletin removed.", 0, true);
											ofstream of("save/bulletinboard/_" + pData->currentWorld + "/X" + coord + ".json");
											of << j << std::endl;
											of.close();
										}
										catch (std::exception& e) 
										{
											std::cout << e.what() << std::endl;
											break; /*tipo jeigu nera*/
										}
									}
								}
								if (btn.substr(0, 18) == "addbulletinletter_")
								{
									if (world == nullptr || pData->currentWorld == "EXIT" || serverIsFrozen) continue;
									string coord = btn.substr(btn.find("_") + 1);
									auto isdbox = std::experimental::filesystem::exists("save/bulletinboard/_" + pData->currentWorld + "/X" + coord + ".json");
									if (!isdbox)
									{
										Player::OnTalkBubble(peer, pData->netID, "`4An error occured while getting bulletin board info.", 0, true);
										continue;
									}
									try {
										std::stringstream bss(cch);
										std::string bto;

										string addtext = "";

										while (std::getline(bss, bto, '\n'))
										{
											vector<string> infoDat = explode("|", bto);
											if (infoDat.at(0) == "addbulletinletterinput")
											{
												addtext = infoDat.at(1);
											}
										}
										if (addtext.length() < 3)
										{
											Player::OnTalkBubble(peer, pData->netID, "`wThat's not interesting enough to post.", 0, true);
											continue;
										}

										ifstream ifff("save/bulletinboard/_" + pData->currentWorld + "/X" + coord + ".json");
										json j;
										ifff >> j;
										ifff.close();
										if (j["inmail"] >= 90)
										{
											Player::OnTalkBubble(peer, pData->netID, "`4Bulletin Board is full!", 0, true);
											continue;
										}
										for (int i = 0; i < 90; i++)
										{
											if (j["mails"].at(i)["growid"] == "")
											{
												j["mails"].at(i)["growid"] = pData->displayName;
												j["mails"].at(i)["text"] = addtext;
												int inmail = j["inmail"];
												j["inmail"] = inmail + 1;
												Player::OnTalkBubble(peer, pData->netID, "`2Bulletin posted.", 0, true);

												ofstream of("save/bulletinboard/_" + pData->currentWorld + "/X" + coord + ".json");
												of << j << std::endl;
												of.close();

												break;
											}
										}
									}
									catch (std::exception& e) 
									{
										std::cout << e.what() << std::endl;
										break; /*tipo jeigu nera*/
									}
								}
								if (btn.substr(0, 17) == "bulletinletterok_")
								{
									if (world == nullptr || pData->currentWorld == "EXIT" || serverIsFrozen) continue;
									string coord = btn.substr(btn.find("_") + 1);
									auto isdbox = std::experimental::filesystem::exists("save/bulletinboard/_" + pData->currentWorld + "/X" + coord + ".json");
									if (!isdbox)
									{
										Player::OnTalkBubble(peer, pData->netID, "`4An error occured while getting bulletin board info.", 0, true);
										continue;
									}
									if (pData->rawName == world->owner || world->owner == "" || isMod(peer))
									{
										try {
											std::stringstream bss(cch);
											std::string bto;

											string publiccanadd = "";
											string hidenames = "";

											while (std::getline(bss, bto, '\n'))
											{
												vector<string> infoDat = explode("|", bto);
												if (infoDat.at(0) == "publiccanaddbulletinboard")
												{
													publiccanadd = infoDat.at(1);
												}
												if (infoDat.at(0) == "hidenamesbulletinboard")
												{
													hidenames = infoDat.at(1);
												}
											}
											if (publiccanadd != "" && hidenames != "")
											{
												int does_pubiccanadd = atoi(publiccanadd.c_str());
												int are_hidenames = atoi(hidenames.c_str());
												if ((does_pubiccanadd != 0 && does_pubiccanadd != 1) || (are_hidenames != 0 && are_hidenames != 1))
												{
													break;
												}
												ifstream ifff("save/bulletinboard/_" + pData->currentWorld + "/X" + coord + ".json");
												json j;
												ifff >> j;
												ifff.close();

												j["hidenames"] = are_hidenames;
												j["publiccanadd"] = does_pubiccanadd;

												ofstream of("save/bulletinboard/_" + pData->currentWorld + "/X" + coord + ".json");
												of << j << std::endl;
												of.close();
											}
										}
										catch (const std::out_of_range& e) {
											std::cout << e.what() << std::endl;
										}
									}
								}
								if (btn.substr(0, 19) == "bulletinboardclear_")
								{
									if (world == nullptr || pData->currentWorld == "EXIT" || serverIsFrozen) continue;
									string coord = btn.substr(btn.find("_") + 1);
									auto isdbox = std::experimental::filesystem::exists("save/bulletinboard/_" + pData->currentWorld + "/X" + coord + ".json");
									if (!isdbox)
									{
										Player::OnTalkBubble(peer, pData->netID, "`4An error occured while getting bulletin board info.", 0, true);
										continue;
									}
									if (pData->rawName == world->owner || world->owner == "" || isMod(peer))
									{
										try {
											ifstream ifff("save/bulletinboard/_" + pData->currentWorld + "/X" + coord + ".json");
											json j;
											ifff >> j;
											ifff.close();
											if (j["inmail"] < 1)
											{
												Player::OnTalkBubble(peer, pData->netID, "`4There is no any mails!", 0, true);
												continue;
											}
											for (int i = 0; i < 90; i++)
											{
												j["mails"].at(i)["growid"] = "";
												j["mails"].at(i)["text"] = "";
											}
											j["inmail"] = 0;
											Player::OnTalkBubble(peer, pData->netID, "`2Bulletin Board emptied.", 0, true);

											ofstream of("save/bulletinboard/_" + pData->currentWorld + "/X" + coord + ".json");
											of << j << std::endl;
											of.close();
										}
										catch (const std::out_of_range& e) {
											std::cout << e.what() << std::endl;
										}
									}
								}
								if (btn.substr(0, 10) == "mailempty_")
								{
									if (world == nullptr || pData->currentWorld == "EXIT" || serverIsFrozen) continue;
									string coord = btn.substr(btn.find("_") + 1);
									auto isdbox = std::experimental::filesystem::exists("save/mailbox/_" + pData->currentWorld + "/X" + coord + ".json");
									if (!isdbox)
									{
										Player::OnTalkBubble(peer, pData->netID, "`4An error occured while getting mailbox info.", 0, true);
										continue;
									}
									if (pData->rawName == world->owner || world->owner == "" || isMod(peer))
									{


										
										try {
											ifstream ifff("save/mailbox/_" + pData->currentWorld + "/X" + coord + ".json");
											json j;
											ifff >> j;
											ifff.close();
											if (j["inmail"] < 1)
											{
												Player::OnTalkBubble(peer, pData->netID, "`4There is no any mails!", 0, true);
												continue;
											}
											for (int i = 0; i < 20; i++)
											{
												j["mails"].at(i)["growid"] = "";
												j["mails"].at(i)["text"] = "";
											}
											j["inmail"] = 0;
											Player::OnTalkBubble(peer, pData->netID, "`2Mailbox emptied.", 0, true);

											int x = j["x"];
											int y = j["y"];
											for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
												if (isHere(peer, currentPeer)) {
													RemoveItemPacket(currentPeer, world->items.at(pData->lastPunchX + (pData->lastPunchY * world->width)).foreground, world->items.at(pData->lastPunchX + (pData->lastPunchY * world->width)).background, x, y, 1);
												}
											}
											ofstream of("save/mailbox/_" + pData->currentWorld + "/X" + coord + ".json");
											of << j << std::endl;
											of.close();
										}
										catch (const std::out_of_range& e) {
											std::cout << e.what() << std::endl;
										}
									}
								}
								if (btn.substr(0, 14) == "bluemailempty_")
								{
									if (world == nullptr || pData->currentWorld == "EXIT" || serverIsFrozen) continue;
									string coord = btn.substr(btn.find("_") + 1);
									auto isdbox = std::experimental::filesystem::exists("save/bluemailbox/_" + pData->currentWorld + "/X" + coord + ".json");
									if (!isdbox)
									{
										Player::OnTalkBubble(peer, pData->netID, "`4An error occured while getting blue mailbox info.", 0, true);
										continue;
									}
									if (pData->rawName == world->owner || world->owner == "" || isMod(peer))
									{



										try {
											ifstream ifff("save/bluemailbox/_" + pData->currentWorld + "/X" + coord + ".json");
											json j;
											ifff >> j;
											ifff.close();
											if (j["inmail"] < 1)
											{
												Player::OnTalkBubble(peer, pData->netID, "`4There is no any mails!", 0, true);
												continue;
											}
											for (int i = 0; i < 20; i++)
											{
												j["mails"].at(i)["growid"] = "";
												j["mails"].at(i)["text"] = "";
											}
											j["inmail"] = 0;
											Player::OnTalkBubble(peer, pData->netID, "`2Mailbox emptied.", 0, true);

											int x = j["x"];
											int y = j["y"];
											ENetPeer* currentPeer;
											for (currentPeer = server->peers;
												currentPeer < &server->peers[server->peerCount];
												++currentPeer)
											{
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
												if (isHere(peer, currentPeer))
												{
													RemoveItemPacket(currentPeer, world->items.at(pData->lastPunchX + (pData->lastPunchY * world->width)).foreground, world->items.at(pData->lastPunchX + (pData->lastPunchY * world->width)).background, x, y, 1);
												}
											}
											ofstream of("save/bluemailbox/_" + pData->currentWorld + "/X" + coord + ".json");
											of << j << std::endl;
											of.close();
										}
										catch (const std::out_of_range& e) {
											std::cout << e.what() << std::endl;
										}
									}
								}
								if (btn.substr(0, 14) == "retrieveGifts_")
								{
									if (world == nullptr || pData->currentWorld == "EXIT" || serverIsFrozen) continue;
									string coord = btn.substr(btn.find("_") + 1);
									auto isdbox = std::experimental::filesystem::exists("save/donationboxes/_" + pData->currentWorld + "/X" + coord + ".json");
									if (!isdbox)
									{
										Player::OnTalkBubble(peer, pData->netID, "`4An error occured while getting donation box info.", 0, true);
										continue;
									}
									if (pData->rawName == world->owner || world->owner == "" || isMod(peer))
									{
										try {
											ifstream ifff("save/donationboxes/_" + pData->currentWorld + "/X" + coord + ".json");
											json j;
											ifff >> j;
											ifff.close();
											if (j["donated"] < 1)
											{
												Player::OnTalkBubble(peer, pData->netID, "`4There is no any donations!", 0, true);
												continue;
											}
											bool success = true;
											for (int i = 0; i < 20; i++)
											{
												if (j["donatedItems"].at(i)["itemid"] != 0)
												{
													int howManyEarnings = j["donatedItems"].at(i)["itemcount"];
													int itemid = j["donatedItems"].at(i)["itemid"];
													string whoSent = j["donatedItems"].at(i)["sentBy"];
													if (j["donatedItems"].at(i)["itemcount"] > 250)
													{
														Player::OnTextOverlay(peer, "You cant receive that!");
														break;
													}
													if (CheckItemExists(peer, j["donatedItems"].at(i)["itemid"]))
													{
														int currentlyHave = GetQuantityOfItem(peer, j["donatedItems"].at(i)["itemid"]);
														if (j["donatedItems"].at(i)["itemcount"].get<double>() + currentlyHave < 251)
														{
															SaveItemMoreTimes(j["donatedItems"].at(i)["itemid"], j["donatedItems"].at(i)["itemcount"], peer, success, pData->rawName + " from donation box");
															j["donatedItems"].at(i)["itemid"] = 0;
															j["donatedItems"].at(i)["itemcount"] = 0;
															j["donatedItems"].at(i)["sentBy"] = "";
															j["donatedItems"].at(i)["note"] = "";
															j["donated"] = j["donated"].get<double>() - 1;
															ENetPeer* currentPeer;
															for (currentPeer = server->peers;
																currentPeer < &server->peers[server->peerCount];
																++currentPeer)
															{
																if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
																if (isHere(peer, currentPeer))
																{
																	Player::OnConsoleMessage(currentPeer, "`w[`o" + pData->displayName + " `oreceives `5" + to_string(howManyEarnings) + " `w" + itemDefs[itemid].name + " `ofrom `w" + whoSent + "`o, how nice!`w]");
																}
															}
															Player::OnTalkBubble(peer, pData->netID, "`2Box emptied.", 0, true);
														}
														else
														{
															int kiekTrukstaIki250 = 250 - currentlyHave;
															SaveItemMoreTimes(j["donatedItems"].at(i)["itemid"], kiekTrukstaIki250, peer, success, pData->rawName + " from " + getItemDef(world->items.at(pData->lastPunchX + (pData->lastPunchY * world->width)).foreground).name + "");
															j["donatedItems"].at(i)["itemcount"] = j["donatedItems"].at(i)["itemcount"].get<double>() - kiekTrukstaIki250;
															howManyEarnings -= kiekTrukstaIki250;
															ENetPeer* currentPeer;
															for (currentPeer = server->peers;
																currentPeer < &server->peers[server->peerCount];
																++currentPeer)
															{
																if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
																if (isHere(peer, currentPeer))
																{
																	Player::OnConsoleMessage(currentPeer, "`w[`o" + pData->rawName + " receives `5" + to_string(kiekTrukstaIki250) + " (`w" + to_string(howManyEarnings) + " `5left) `w" + itemDefs[itemid].name + " `ofrom `w" + whoSent + "`o, how nice!`w]");
																}
															}
															Player::OnTalkBubble(peer, pData->netID, "`2Box emptied.", 0, true);
														}
													}
													else
													{
														if (pData->inventory.items.size() == pData->currentInventorySize)
														{
															Player::OnTextOverlay(peer, "`4Your inventory is full! You can purchase an inventory upgrade in the shop.");
															break;
														}

														SaveItemMoreTimes(j["donatedItems"].at(i)["itemid"], j["donatedItems"].at(i)["itemcount"], peer, success, pData->rawName + " from donation box");
														j["donatedItems"].at(i)["itemid"] = 0;
														j["donatedItems"].at(i)["itemcount"] = 0;
														j["donatedItems"].at(i)["sentBy"] = "";
														j["donatedItems"].at(i)["note"] = "";
														j["donated"] = j["donated"].get<double>() - 1;
														ENetPeer* currentPeer;
														for (currentPeer = server->peers;
															currentPeer < &server->peers[server->peerCount];
															++currentPeer)
														{
															if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
															if (isHere(peer, currentPeer))
															{
																Player::OnConsoleMessage(currentPeer, "`w[`o" + pData->rawName + " receives `5" + to_string(howManyEarnings) + " `w" + itemDefs[itemid].name + " `ofrom `w" + whoSent + "`o, how nice!`w]");
															}
														}
														Player::OnTalkBubble(peer, pData->netID, "`2Box emptied.", 0, true);
													}
												}
											}

											if (j["donated"] <= 0)
											{
												ENetPeer* currentPeer;
												for (currentPeer = server->peers;
													currentPeer < &server->peers[server->peerCount];
													++currentPeer)
												{
													if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
													if (isHere(peer, currentPeer))
													{
														if (pData->lastPunchX >= 0 && pData->lastPunchY >= 0)
														{
															RemoveItemPacket(currentPeer, world->items.at(pData->lastPunchX + (pData->lastPunchY * world->width)).foreground, world->items.at(pData->lastPunchX + (pData->lastPunchY * world->width)).background, pData->lastPunchX, pData->lastPunchY, 1);
														}
													}
												}
											}
											ofstream of("save/donationboxes/_" + pData->currentWorld + "/X" + coord + ".json");
											of << j << std::endl;
											of.close();
										}
										catch (const std::out_of_range& e) {
											std::cout << e.what() << std::endl;
										}
									}
								}
								if (btn.substr(0, 15) == "safeupdatepass_")
								{
									if (world == nullptr || pData->currentWorld == "EXIT" || serverIsFrozen) continue;
									string coord = btn.substr(btn.find("_") + 1);
									auto isdbox = std::experimental::filesystem::exists("save/safevault/_" + pData->currentWorld + "/X" + coord + ".json");
									if (!isdbox)
									{
										Player::OnTalkBubble(peer, pData->netID, "`4An error occured. Break the safe.", 0, true);
									}
									else
									{
										if (pData->rawName == PlayerDB::getProperName(world->owner) || world->owner == "" || isMod(peer))
										{
											GTDialog mySafe;
											mySafe.addLabelWithIcon("`wSafe Vault", 8878, LABEL_BIG);
											ifstream ifff("save/safevault/_" + pData->currentWorld + "/X" + coord + ".json");
											json j;
											ifff >> j;
											if (j["password"] == "")
											{
												mySafe.addSmallText("The ingenious minds at GrowTech bring you the `2Safe Vault`` - a place to store your items safely with its integrated password option!");
												mySafe.addSmallText("How the password works:");
												mySafe.addSmallText("The Safe Vault requires both a `2password`` and a `2recovery answer`` to be entered to use a password.");
												mySafe.addSmallText("Enter your `2password`` and `2recovery answer`` below - keep them safe and `4DO NOT`` share them with anyone you do not trust!");
												mySafe.addSmallText("The password and recovery answer can be no longer than 12 characters in length - number and alphabet only please, no special characters are allowed!");
												mySafe.addSmallText("If you forget your password, enter your recovery answer to access the Safe Vault - The Safe Vault will `4NOT be password protected now``. You will need to enter a new password.");
												mySafe.addSmallText("You can change your password, however you will need to enter the old password before a new one can be used.");
												mySafe.addSmallText("`4WARNING``: DO NOT forget your password and recovery answer or you will not be able to access the Safe Vault!");
												mySafe.addSmallText("`4There is no password currently set on this Safe Vault.``");
												mySafe.addSmallText("Enter a new password.");
												mySafe.addInputBox("safenewpass_" + coord, "", "", 18);
												mySafe.addSmallText("Enter a recovery answer.");
												mySafe.addInputBox("safe_recoverypass", "", "", 12);
												mySafe.addButton("safe_setpassword", "Update Password");
												mySafe.addSpacer(SPACER_SMALL);
												mySafe.addQuickExit();
												mySafe.endDialog("Close", "", "Exit");
												Player::OnDialogRequest(peer, mySafe.finishDialog());
											}
											else
											{
												mySafe.addSmallText("The ingenious minds at GrowTech bring you the `2Safe Vault`` - a place to store your items safely with its integrated password option!");
												mySafe.addSmallText("How the password works:");
												mySafe.addSmallText("The Safe Vault requires both a `2password`` and a `2recovery answer`` to be entered to use a password.");
												mySafe.addSmallText("Enter your `2password`` and `2recovery answer`` below - keep them safe and `4DO NOT`` share them with anyone you do not trust!");
												mySafe.addSmallText("The password and recovery answer can be no longer than 12 characters in length - number and alphabet only please, no special characters are allowed!");
												mySafe.addSmallText("If you forget your password, enter your recovery answer to access the Safe Vault - The Safe Vault will `4NOT be password protected now``. You will need to enter a new password.");
												mySafe.addSmallText("You can change your password, however you will need to enter the old password before a new one can be used.");
												mySafe.addSmallText("`4WARNING``: DO NOT forget your password and recovery answer or you will not be able to access the Safe Vault!");
												mySafe.addSmallText("Enter your old password.");
												mySafe.addInputBox("safeoldpassword_" + coord, "", "", 18);
												mySafe.addSmallText("Enter a new password.");
												mySafe.addInputBox("safe_newpassword", "", "", 18);
												mySafe.addSmallText("Enter a recovery answer.");
												mySafe.addInputBox("storage_recoveryanswer", "", "", 12);
												mySafe.addButton("safe_updatepassword", "Update Password");
												mySafe.addSmallText("Remove the password protection from the `5Safe Vault``.");
												mySafe.addSmallText("You will need to enter the old password to remove the password protection.");
												mySafe.addButton("safe_removepassword", "Remove Password");
												mySafe.addSpacer(SPACER_SMALL);
												mySafe.addQuickExit();
												mySafe.endDialog("Close", "", "Exit");
												Player::OnDialogRequest(peer, mySafe.finishDialog());
											}
										}
									}
								}
								if (btn.substr(0, 21) == "boxlvl2DepositedItem_")
								{
									if (world == nullptr || pData->currentWorld == "EXIT" || serverIsFrozen) continue;
									if (pData->rawName == PlayerDB::getProperName(world->owner) || world->owner == "" || isMod(peer))
									{
										try {
											string apos_and_coord = btn.erase(0, 21);
											string::size_type pos = apos_and_coord.find('_');
											string apos = "";
											string coord = "";

											if (pos != std::string::npos)
											{
												apos = apos_and_coord.substr(0, pos);
												apos_and_coord.erase(0, pos + 1);
												coord = apos_and_coord;
											}
											else
											{
												break;
											}
											auto isdbox = std::experimental::filesystem::exists("save/storageboxlvl2/_" + pData->currentWorld + "/X" + coord + ".json");
											if (!isdbox)
											{
												Player::OnTalkBubble(peer, pData->netID, "`4An error occured while getting box info.", 0, true);
												break;
											}

											bool contains_non_int3 = !std::regex_match(apos, std::regex("^[0-9]+$"));
											if (contains_non_int3 == true)
											{
												break;
											}



											ifstream ifff("save/storageboxlvl2/_" + pData->currentWorld + "/X" + coord + ".json");
											json j;
											ifff >> j;
											ifff.close();

											int itemid = 0;
											int count = 0;
											for (int i = 0; i < 40; i++)
											{
												if (j["storage"].at(i)["aposition"] == atoi(apos.c_str()))
												{
													itemid = j["storage"].at(i)["itemid"];
													count = j["storage"].at(i)["itemcount"];
													GTDialog storagelvl1;
													storagelvl1.addLabelWithIcon("`wStorage Box Xtreme - Level 2", 6288, LABEL_BIG);
													storagelvl1.addSmallText("`oYou have `w" + to_string(count) + " " + itemDefs[itemid].name + " `ostored.");
													storagelvl1.addSmallText("`oWithdraw how many?");
													storagelvl1.addInputBox("boxlvl2withdraw_" + coord + "_" + apos, "", to_string(count), 5);
													storagelvl1.addSpacer(SPACER_SMALL);
													storagelvl1.addButton("boxlvl2_withdrawConfirm", "Remove items");
													storagelvl1.addSpacer(SPACER_SMALL);
													storagelvl1.addQuickExit();
													storagelvl1.endDialog("Close", "", "Exit");
													Player::OnDialogRequest(peer, storagelvl1.finishDialog());
													break;
												}
											}
										}
										catch (const std::out_of_range& e) {
											std::cout << e.what() << std::endl;
										}
									}
								}
								if (btn.substr(0, 21) == "boxlvl3DepositedItem_")
								{
									if (world == nullptr || pData->currentWorld == "EXIT" || serverIsFrozen) continue;
									if (pData->rawName == PlayerDB::getProperName(world->owner) || world->owner == "" || isMod(peer))
									{
										try {
											string apos_and_coord = btn.erase(0, 21);
											string::size_type pos = apos_and_coord.find('_');
											string apos = "";
											string coord = "";

											if (pos != std::string::npos)
											{
												apos = apos_and_coord.substr(0, pos);
												apos_and_coord.erase(0, pos + 1);
												coord = apos_and_coord;
											}
											else
											{
												break;
											}
											auto isdbox = std::experimental::filesystem::exists("save/storageboxlvl3/_" + pData->currentWorld + "/X" + coord + ".json");
											if (!isdbox)
											{
												Player::OnTalkBubble(peer, pData->netID, "`4An error occured while getting box info.", 0, true);
												break;
											}

											bool contains_non_int3 = !std::regex_match(apos, std::regex("^[0-9]+$"));
											if (contains_non_int3 == true)
											{
												break;
											}



											ifstream ifff("save/storageboxlvl3/_" + pData->currentWorld + "/X" + coord + ".json");
											json j;
											ifff >> j;
											ifff.close();

											int itemid = 0;
											int count = 0;
											for (int i = 0; i < 90; i++)
											{
												if (j["storage"].at(i)["aposition"] == atoi(apos.c_str()))
												{
													itemid = j["storage"].at(i)["itemid"];
													count = j["storage"].at(i)["itemcount"];
													GTDialog storagelvl1;
													storagelvl1.addLabelWithIcon("`wStorage Box Xtreme - Level 3", 6290, LABEL_BIG);
													storagelvl1.addSmallText("`oYou have `w" + to_string(count) + " " + itemDefs[itemid].name + " `ostored.");
													storagelvl1.addSmallText("`oWithdraw how many?");
													storagelvl1.addInputBox("boxlvl3withdraw_" + coord + "_" + apos, "", to_string(count), 5);
													storagelvl1.addSpacer(SPACER_SMALL);
													storagelvl1.addButton("boxlvl3_withdrawConfirm", "Remove items");
													storagelvl1.addSpacer(SPACER_SMALL);
													storagelvl1.addQuickExit();
													storagelvl1.endDialog("Close", "", "Exit");
													Player::OnDialogRequest(peer, storagelvl1.finishDialog());
													break;
												}
											}
										}
										catch (const std::out_of_range& e) {
											std::cout << e.what() << std::endl;
										}
									}
								}
								if (btn.substr(0, 21) == "boxlvl1DepositedItem_")
								{
									if (world == nullptr || pData->currentWorld == "EXIT" || serverIsFrozen) continue;
									if (pData->rawName == PlayerDB::getProperName(world->owner) || world->owner == "" || isMod(peer))
									{


										try {
											string apos_and_coord = btn.erase(0, 21);
											string::size_type pos = apos_and_coord.find('_');
											string apos = "";
											string coord = "";

											if (pos != std::string::npos)
											{
												apos = apos_and_coord.substr(0, pos);
												apos_and_coord.erase(0, pos + 1);
												coord = apos_and_coord;
											}
											else
											{
												break;
											}
											auto isdbox = std::experimental::filesystem::exists("save/storageboxlvl1/_" + pData->currentWorld + "/X" + coord + ".json");
											if (!isdbox)
											{
												Player::OnTalkBubble(peer, pData->netID, "`4An error occured while getting box info.", 0, true);
												break;
											}

											bool contains_non_int3 = !std::regex_match(apos, std::regex("^[0-9]+$"));
											if (contains_non_int3 == true)
											{
												break;
											}



											ifstream ifff("save/storageboxlvl1/_" + pData->currentWorld + "/X" + coord + ".json");
											json j;
											ifff >> j;
											ifff.close();

											int itemid = 0;
											int count = 0;
											for (int i = 0; i < 20; i++)
											{
												if (j["storage"].at(i)["aposition"] == atoi(apos.c_str()))
												{
													itemid = j["storage"].at(i)["itemid"];
													count = j["storage"].at(i)["itemcount"];
													GTDialog storagelvl1;
													storagelvl1.addLabelWithIcon("`wStorage Box Xtreme - Level 1", 6286, LABEL_BIG);
													storagelvl1.addSmallText("`oYou have `w" + to_string(count) + " " + itemDefs[itemid].name + " `ostored.");
													storagelvl1.addSmallText("`oWithdraw how many?");
													storagelvl1.addInputBox("boxlvl1withdraw_" + coord + "_" + apos, "", to_string(count), 5);
													storagelvl1.addSpacer(SPACER_SMALL);
													storagelvl1.addButton("boxlvl1_withdrawConfirm", "Remove items");
													storagelvl1.addSpacer(SPACER_SMALL);
													storagelvl1.addQuickExit();
													storagelvl1.endDialog("Close", "", "Exit");
													Player::OnDialogRequest(peer, storagelvl1.finishDialog());
													break;
												}
											}
										}
										catch (const std::out_of_range& e) {
											std::cout << e.what() << std::endl;
										}
									}
								}

								// Mystic Snow Fox
								if (tile == 10456) {
									if (x == ((PlayerInfo*)(peer->data))->x / 32 && y == ((PlayerInfo*)(peer->data))->y / 32) {
										if (((PlayerInfo*)(peer->data))->cloth_back != 10456) {
											((PlayerInfo*)(peer->data))->cloth_back = 10456;
											((PlayerInfo*)(peer->data))->effect = 8421559;
											sendPuncheffectpeer(peer, ((PlayerInfo*)(peer->data))->effect);
											sendClothes(peer);
										}
										else {
											((PlayerInfo*)(peer->data))->cloth_back = 10426;
											((PlayerInfo*)(peer->data))->effect = 8421559;
											sendPuncheffectpeer(peer, ((PlayerInfo*)(peer->data))->effect);
											sendClothes(peer);
										}
									}
									else {
										Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "Must be used on a person.", 0, true);
									}
								}

								// Go-Go-Growformer!
								if (tile == 7480) {
									if (x == ((PlayerInfo*)(peer->data))->x / 32 && y == ((PlayerInfo*)(peer->data))->y / 32) {
										if (((PlayerInfo*)(peer->data))->cloth_back != 7480) {
											((PlayerInfo*)(peer->data))->cloth_back = 7480;
											((PlayerInfo*)(peer->data))->effect = 8421396;
											sendPuncheffectpeer(peer, ((PlayerInfo*)(peer->data))->effect);
											sendClothes(peer);
										}
										else {
											((PlayerInfo*)(peer->data))->cloth_back = 0;
											((PlayerInfo*)(peer->data))->effect = 8421376;
											sendPuncheffectpeer(peer, ((PlayerInfo*)(peer->data))->effect);
											sendClothes(peer);
										}
									}
									else {
										Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "Must be used on a person.", 0, true);
									}
								}
								//alien
								if (btn == "transform_alien") {
									string name = getItemDef(static_cast<PlayerInfo*>(peer->data)->cloth_hand).name;
									Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wAlien Transform|left|11398|\nadd_spacer|small|\nadd_button|transal|`$Transform to " + name + "|\nadd_button|transhum|`$Transform to Human|\nadd_spacer|small|\nadd_button|cl0se|`wClose|\nadd_quick_exit|");
								}
								if (btn == "transal") {
									gamepacket_t p(0, ((PlayerInfo*)(peer->data))->netID);
									p.Insert("OnFlagMay2019");
									p.Insert(262400);

									ENetPeer* currentPeer;
									for (currentPeer = server->peers;
										currentPeer < &server->peers[server->peerCount];
										++currentPeer)
									{
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
											continue;
										if (isHere(peer, currentPeer))
										{
											p.CreatePacket(currentPeer);
										}
									}
								}
								if (btn == "transhum") {
									gamepacket_t p(0, ((PlayerInfo*)(peer->data))->netID);
									p.Insert("OnFlagMay2019");
									p.Insert(256);

									ENetPeer* currentPeer;
									for (currentPeer = server->peers;
										currentPeer < &server->peers[server->peerCount];
										++currentPeer)
									{
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
											continue;
										if (isHere(peer, currentPeer))
										{
											p.CreatePacket(currentPeer);
										}
									}
								}
								// end alien

							    // dragon growpass
								if (btn == "dragonpass") {
									string name = getItemDef(static_cast<PlayerInfo*>(peer->data)->cloth_face).name;
									Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wMask Of The Dragon Transform|left|11508|\nadd_spacer|small|\nadd_button|transaldragon|`$Transform to " + name + "|\nadd_button|transhumdragon|`$Transform to Human|\nadd_spacer|small|\nadd_button|cl0se|`wClose|\nadd_quick_exit|");
								}
								if (btn == "transaldragon") {
									gamepacket_t p(0, ((PlayerInfo*)(peer->data))->netID);
									p.Insert("OnFlagMay2019");
									p.Insert(524544);

									ENetPeer* currentPeer;
									for (currentPeer = server->peers;
										currentPeer < &server->peers[server->peerCount];
										++currentPeer)
									{
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
											continue;
										if (isHere(peer, currentPeer))
										{
											p.CreatePacket(currentPeer);
										}
									}
								}
								if (btn == "transhumdragon") {
									gamepacket_t p(0, ((PlayerInfo*)(peer->data))->netID);
									p.Insert("OnFlagMay2019");
									p.Insert(256);

									ENetPeer* currentPeer;
									for (currentPeer = server->peers;
										currentPeer < &server->peers[server->peerCount];
										++currentPeer)
									{
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
											continue;
										if (isHere(peer, currentPeer))
										{
											p.CreatePacket(currentPeer);
										}
									}
								}
								// end dragon growpass
								if (btn == "ssuback")
								{
									int gij = 0;
									int goo = 0;
									int cp = 0;
									gij = GetQuantityOfItem(peer, 3722);
									goo = GetQuantityOfItem(peer, 6078);
									auto iscontains = false;
									SearchInventoryItem(peer, 3722, 40, iscontains);
									if (!iscontains)
									{
										Player::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`9Spirit Storage Unit|left|3724|\nadd_spacer|small|\nadd_smalltext|`w" + to_string(cp) + "% Capacity|\nadd_textbox|`$Greeting Players, I am The Spirit Storage Unit, which i want 40 Ghost-In-A-Jar to open the Milestones!|\nadd_smalltext|`oYou have " + to_string(gij) + " Ghost-In-A-Jar.|\nend_dialog||Whatever|");
									}
									else
									{
										Player::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`9Spirit Storage Unit|left|3724|\nadd_spacer|small|\nadd_smalltext|`w" + to_string(cp) + "% Capacity|\nadd_textbox|`$Greeting Players, I am The Spirit Storage Unit, which i want 40 Ghost-In-A-Jar to open the Milestones!|\nadd_spacer|small|\nadd_textbox|`$Oh seems you already have 40 Ghost-In-A-Jar. I will tell you something!|\nadd_textbox|`$I want you to give me 40 Ghost-In-A-Jar and, I swear will pay you back with some most cool and usefull stuff maybe some bad!|\nadd_spacer|small|\nadd_smalltext|`oYou have " + to_string(gij) + " Ghost-In-A-Jar.|\nadd_button|gachagij|`wPay 40 Ghost-In-A-Jar!|\nadd_spacer|small|\nadd_textbox|`$I offer you for more good items but, I want something cool and more Ghost-In-A-Jar! What i want is 1 Boss Goo And 50 Ghost-In-A-Jar|\nadd_spacer|small|\nadd_smalltext|`oYou have " + to_string(goo) + " Boss Goo and " + to_string(gij) + " Ghost-In-A-Jar.|\nadd_button|gachagoo|`wPay 1 Boss Goo and 50 Ghost-In-A-Jar!(Cooming Soon)|\nend_dialog||Okay|");
									}
								}
								if (btn == "hadiah1")
								{
									Player::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`9Spirit Storage Unit Prize Branch 1|left|120|\nadd_spacer|small|\nadd_label_with_icon|small|`o1 B.O.O Helmet|left|3712|\nadd_label_with_icon|small|`o1 B.O.O Shirt|left|3706|\nadd_label_with_icon|small|`o1 B.O.O Pants|left|3708|\nadd_label_with_icon|small|`o1 Rubber Boots|left|3718|\nadd_label_with_icon|small|`o1 Ghost Block|left|10056|\nadd_label_with_icon|small|`o1 Crystallized Ghost|left|3730|\nadd_label_with_icon|small|`o1 Gameing Block|left|3732\nadd_label_with_icon|small|`o1 Gameing Background|left|3734|\nadd_label_with_icon|small|`o1 Otherworldy Gameing Light|left|6076|\nadd_label_with_icon|small|`o1 Ghost Charm|left|3750|\nadd_label_with_icon|small|`o1 Bone Spikes|left|3748|\nadd_label_with_icon|small|`o1 Ectoplasm Sample|left|3728|\nadd_spacer|small|\nadd_textbox|`5These items are only avabile in Spirit Storage Unit.|\nadd_spacer|small|\nadd_button|gachagij|`oBack|\nend_dialog||Close|");
								}
								if (btn == "hadiah1s")
								{
									Player::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`9Spirit Storage Unit Prize Branch 1|left|120|\nadd_spacer|small|\nadd_label_with_icon|small|`o1 B.O.O Helmet|left|3712|\nadd_label_with_icon|small|`o1 B.O.O Shirt|left|3706|\nadd_label_with_icon|small|`o1 B.O.O Pants|left|3708|\nadd_label_with_icon|small|`o1 Rubber Boots|left|3718|\nadd_label_with_icon|small|`o1 Ghost Block|left|10056|\nadd_label_with_icon|small|`o1 Crystallized Ghost|left|3730|\nadd_label_with_icon|small|`o1 Gameing Block|left|3732\nadd_label_with_icon|small|`o1 Gameing Background|left|3734|\nadd_label_with_icon|small|`o1 Otherworldy Gameing Light|left|6076|\nadd_label_with_icon|small|`o1 Ghost Charm|left|3750|\nadd_label_with_icon|small|`o1 Bone Spikes|left|3748|\nadd_label_with_icon|small|`o1 Ectoplasm Sample|left|3728|\nadd_spacer|small|\nadd_textbox|`5These items are only avabile in Spirit Storage Unit.|\nadd_spacer|small|\nadd_button|gachagijs|`oBack|\nend_dialog||Close|");
								}
								if (btn == "gachagij")
								{
									int gij = 0;
									int cp = 0;
									gij = GetQuantityOfItem(peer, 3722);
									auto iscontains = false;
									SearchInventoryItem(peer, 3722, 40, iscontains);
									if (!iscontains)
									{
										Player::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`9Spirit Storage Unit|left|3724|\nadd_spacer|small|\nadd_smalltext|`w" + to_string(cp) + "% Capacity|\nadd_textbox|`$Sorry, you don't have too manny Ghost-In-A-Jar!|\nadd_smalltext|`oYou have " + to_string(gij) + " Ghost-In-A-Jar.|\nend_dialog||Okay|");
									}
									else
									{
										Player::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`9Spirit Storage Unit|left|3724|\nadd_spacer|small|\nadd_smalltext|`w" + to_string(cp) + "% Capacity|\nadd_textbox|`$Greetings, now it's your choice Deliver and get Items? Or Hang Out with nothing. If you want to deliver make sure don't exit the Dialog or your proggres 200% will be gone.|\nadd_textbox|`$Sounds so bad huh?.|\nadd_button|hadiah1|`oRewards List!|\nadd_spacer|small|\nadd_smalltext|`oYou have " + to_string(gij) + " Ghost-In-A-Jar.|\nadd_button|gachagijs|`wYes, I Accept!|\nadd_button|ssuback|`wBack|\nend_dialog||Close|");
									}
								}
								if (btn == "gachagijs")
								{
									int gij = 0;
									int cp = 200;
									gij = GetQuantityOfItem(peer, 3722);
									auto iscontains = false;
									SearchInventoryItem(peer, 3722, 40, iscontains);
									if (!iscontains)
									{
										Player::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`9Spirit Storage Unit|left|3724|\nadd_spacer|small|\nadd_smalltext|`4" + to_string(cp) + "% Capacity|\nadd_textbox|`$Sorry, you don't have too manny Ghost-In-A-Jar!|\nadd_smalltext|`oYou have " + to_string(gij) + " Ghost-In-A-Jar.|\nend_dialog||Okay|");
									}
									else
									{
										Player::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`9Spirit Storage Unit|left|3724|\nadd_spacer|small|\nadd_smalltext|`4" + to_string(cp) + "% Capacity|\nadd_smalltext|`4RISK OF EXSPLOSION|\nadd_textbox|`$Are you sure about delivering 40 Ghost-In-A-Jar and got randomly items?|\nadd_button|hadiah1s|`oRewards List!|\nadd_spacer|small|\nadd_smalltext|`oYou have " + to_string(gij) + " Ghost-In-A-Jar.|\nadd_button|gachagijss|`wYes I'm Sure!|\nadd_button|gachagij|`wBack|\nend_dialog||Close|");
									}
								}
								if (btn == "gachagijss")
								{
									RemoveInventoryItem(3722, 40, peer, true);
									vector<int> list{ 3706, 3748, 3750, 3708, 3712, 3718, 3728, 10056, 3734, 3732, 6076, 3730 };
									int itemid = list[rand() % list.size()];
									if (itemid == 3750)
									{
										int target = 7;
										if ((rand() % 10000) <= target) {}
									}
									else
									{
										if (itemid == 3750)
										{
											int target = 5;
											if ((rand() % 10000) <= target) {}
										}
									}
									GamePacket psp = packetEnd(appendFloat(appendIntx(appendString(createPacket(), "OnParticleEffect"), 30), x * 32, y * 32));
									ENetPacket* packetd = enet_packet_create(psp.data,
										psp.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packetd);
									float x = ((PlayerInfo*)(peer->data))->x;
									float y = ((PlayerInfo*)(peer->data))->y;
									ENetPeer* currentPeer;
									for (currentPeer = server->peers;
										currentPeer < &server->peers[server->peerCount];
										++currentPeer)
									{
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
											continue;
										Player::OnParticleEffect(currentPeer, 97, x, y, 0);
									}
									send_item1(peer, itemid, 1, 0);
								}

								if (btn == "cdc")
								{
									Player::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|Edit Dragon Charm|left|10246|\nadd_textbox|Celestial Dragon Charm|left|\nadd_checkbox|eff1|Day|0|\nadd_checkbox|eff2|Sunset|0|\nadd_checkbox|eff3|Night|0|\nend_dialog|dragoncharm_edit|Close|Update|\n");
								}

								if (btn == "trade_history") {
									GTDialog allLog;
									string line;

									ifstream banlog("save/tradelogs/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									allLog.addLabelWithIcon("`wTrade History", 1434, LABEL_SMALL);
									allLog.addSpacer(SPACER_SMALL);
									while (getline(banlog, line))
									{
										allLog.addSmallText(line);
									}
									banlog.close();

									allLog.addSpacer(SPACER_SMALL);
									allLog.addQuickExit();
									allLog.endDialog("Close", "", "Close it");
									Player::OnDialogRequest(peer, allLog.finishDialog());
								}
								if (btn == "uncloth") {
									((PlayerInfo*)(peer->data))->cloth_hair = 0;
									((PlayerInfo*)(peer->data))->cloth_shirt = 0;
									((PlayerInfo*)(peer->data))->cloth_pants = 0;
									((PlayerInfo*)(peer->data))->cloth_feet = 0;
									((PlayerInfo*)(peer->data))->cloth_face = 0;
									((PlayerInfo*)(peer->data))->cloth_hand = 0;
									((PlayerInfo*)(peer->data))->cloth_back = 0;
									((PlayerInfo*)(peer->data))->cloth_mask = 0;
									((PlayerInfo*)(peer->data))->cloth_necklace = 0;
									((PlayerInfo*)(peer->data))->cloth_ances = 0;
									((PlayerInfo*)(peer->data))->effect = 8421376;
									((PlayerInfo*)(peer->data))->canDoubleJump = false;
									send_state(peer);
									sendClothes(peer);
								}
								if (btn == "clearcctvlog") {
									if (world == nullptr || world->name == "EXIT" || serverIsFrozen) continue;
									ifstream ifff("save/cctv/_" + ((PlayerInfo*)(peer->data))->currentWorld + ".json");
									json j;
									ifff >> j;
									ifff.close();
									vector<string> logs;
									j["logs"] = logs;
									ofstream fs("save/cctv/_" + ((PlayerInfo*)(peer->data))->currentWorld + ".json");
									fs << j;
									fs.close();
									Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`2Camera log cleared.", 0, false);
									Player::PlayAudio(peer, "audio/page_turn", 0);
								}
								if (btn == "set_online_status")
								{
									int away = 0;
									int busy = 0;
									int online = 0;
									if (((PlayerInfo*)(peer->data))->Busy == true) busy = 1;
									if (((PlayerInfo*)(peer->data))->Away == true) away = 1;
									if (((PlayerInfo*)(peer->data))->Away == false && ((PlayerInfo*)(peer->data))->Busy == false && ((PlayerInfo*)(peer->data))->Online == false) online = 1;
									else if (((PlayerInfo*)(peer->data))->Online == true) online = 1;
									Player::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big| `wOnline Status`` |left|1366|\nadd_spacer|small|\nadd_checkbox|checkbox_status_online|`oOnline|" + to_string(online) + "|\nadd_checkbox|checkbox_status_busy|`oBusy|" + to_string(busy) + "|\nadd_checkbox|checkbox_status_away|`oAway|" + to_string(away) + "|\nend_dialog|set_status||Ok|");
								}
								if (btn == "DigiVend") {
									Player::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`wVending Machine|left|2978|\nadd_spacer|small|\nadd_textbox|`$Are you sure you want to upgrade to a DigiVend Machine for `44.000 Gems`$?|left|\nadd_spacer|small|\nend_dialog|updigi|Close|Upgrade|");
								}
								if (btn == "sendDialogATPS") {
									Sleep(1000);
									Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wWelcome to " + server_name + "``|left|18|\nadd_spacer|small|\nadd_textbox|`oWelcome to " + server_name + " Growtopia Private Server, " + static_cast<PlayerInfo*>(peer->data)->displayName + ".|left|\nadd_spacer|small|\nadd_textbox|`oThere is " + GetPlayerCountServer() + " players online in " + server_name + "|left|\nadd_spacer|small|\nadd_button|rulesok|`oRules|\nadd_button|featuresok|`oServer Features|\nadd_button|roleprice|`oRole Prices|\nadd_button|aboutserver|about server|\nadd_spacer|small|\nadd_button|sureclose|`wClose|\nadd_quick_exit|");
								}
								if (btn == "rulesok") {
									Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wHelp & Rules``|left|18|\nadd_spacer|small|\nadd_textbox|`wTo keep this place fun we've got some ground rules to check out:``|left|\nadd_spacer|small|\nadd_label_with_icon|small|`wKeep your password secret. Sharing your password will result in stolen items.``|left|24|\nadd_label_with_icon|small|`wUnprotected items are at risk of being stolen. Use doors, locks, and blocks wisely to protect your items.``|left|24|\nadd_label_with_icon|small|`wWe cannot return stolen items, so BE CAREFUL!``|left|24|\nadd_label_with_icon|small|`wBe civil. Bullying, racism, excessive profanity, sexual content, and abusive behavior are not allowed.``|left|24|\nadd_label_with_icon|small|`wPlayers that are harmful to the community may be banned. This includes accounts that use lies, fake games, or trickery to mistreat other players.``|left|24|\nadd_label_with_icon|small|`wPunishments may be applied to alt accounts as well as any devices and IP addresses used by the offender.``|left|24|\nadd_label_with_icon|small|`wTrying to get punished or asking for a punishment can earn you a worse punishment.``|left|24|\nadd_label_with_icon|small|`w'Hacking' the game - including client-side manipulation, auto-clickers, speed hacks, clock manipulation, bots, macroing, and autofarming - will result in a ban.``|left|24|\nadd_label_with_icon|small|`wDon't sell " + server_name + "'s item's or gem's for original growtopia wl. if you caught by an owner you will a worse punishment.``|left|24|\nadd_label_with_icon|small|`wDon't ban or mute or curse people without an obvius reason. breaking this rules will get you a worse punishment.``|left|24|\nadd_label_with_icon|small|`wDon't lie about mods or fake official Growtopia system messages.``|left|24|\nadd_label_with_icon|small|`w'Drop games' are illegal scams. You can be punished for hosting, playing, advertising or even watching.``|left|24|\nadd_label_with_icon|small|`wBetting or gambling (asking players to pay for a chance to win something) is not allowed.``|left|24|\nadd_label_with_icon|small|`wIf you find a world or player name that is in violation of our rules, message a @Mod. Do not /bc or /sb from an inappropriate world.``|left|24|\nadd_label_with_icon|small|`w@Moderators are here to enforce the rules. Abusing, spamming or harassing mods will have consequences.``|left|24|\nadd_label_with_icon|small|`wAccounts, locks, or worlds may be deleted after long periods of inactivity.``|left|24|\nadd_label_with_icon|small|`wOut of game buying/selling of Growtopia accounts, items or worlds is not allowed and may result in a ban.``|left|24|\nadd_label_with_icon|small|`wIAP fraud will result in permanent suspension.``|left|24|\nadd_label_with_icon|small|`wItem function and prices are subject to change without warning.``|left|24|\nadd_label_with_icon|small|`wYour creations and items could be deleted at any time. We do everything in our power to prevent this, but data loss may happen without warning. Lost items cannot be restored.``|left|24|\nadd_spacer|small|\nadd_label_with_icon|small|`wFor technical support, IAP issues, or to report a problem, please email " + server_email + "``|left|24|\nadd_label|with|icon|small|`wThis Rules Isn't applicable for Server-Developer.``|left|24|\nadd_button|sendDialogATPS|`wBack?|");
								}
								if (btn == "sureclose") {
									Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wClose?``|left|18|\nadd_spacer|small|\nadd_textbox|Are You Sure Want To Close This Session?|\nadd_button|sendDialogATPS|`wBack!|\nadd_button|closetolol|`wClose!|");
								}
								if (btn == "featuresok") {
									std::ifstream feature("feature.txt");
									std::stringstream buffer;
									buffer << feature.rdbuf();
									std::string featureString(buffer.str());
									Player::OnDialogRequest(peer, featureString);
								}
								if (btn == "roleprice") {
									std::ifstream roleprice("roleprice.txt");
									std::stringstream buffer;
									buffer << roleprice.rdbuf();
									std::string rolepriceString(buffer.str());
									Player::OnDialogRequest(peer, rolepriceString);
								}
								if (btn == "aboutserver") {
									std::ifstream news("aboutserver.txt");
									std::stringstream buffer;
									buffer << news.rdbuf();
									std::string newsString(buffer.str());
									Player::OnDialogRequest(peer, newsString);
								}
								if (btn == "upwis") {
									bool checkForPlr = std::experimental::filesystem::exists("save/ances/wisdom/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									if (checkForPlr == true) {
										Player::OnDialogRequest(peer, "add_label_with_icon|big|`oUpgrade Ancestral Totem of Wisdom|left|5078|\nadd_spacer|small|\nadd_textbox|`oMy child, it seems like you have upgraded your Ancestral Totem of Wisdom to the maximum level.|\nadd_spacer|small|\nadd_button|cl0se|`wClose|\nadd_quick_exit|");
									}
									else
									{
										ofstream fd("save/ances/currentquest/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										fd << "wisdom";
										fd.close();
										bool iscontains = false;
										SearchInventoryItem(peer, 5078, 1, iscontains);
										if (iscontains) {
											int plrGems = 0;
											ifstream getPlrGems("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
											getPlrGems >> plrGems;
											getPlrGems.close();
											if (plrGems >= 100000000) {
												Player::OnDialogRequest(peer, "add_label_with_icon|big|`oUpgrade Ancestral Totem of Wisdom|left|5078|\nadd_spacer|small|\nadd_textbox|`oWelcome to the Ancient Goddess child|\nadd_smalltext|`oI want you to deliver me 100.000.000 Gems.|left|\nadd_smalltext|`o(You currently have " + to_string(plrGems) + " Gems in your account)|left|\nadd_spacer|small|\nadd_button|claimwis|Upgrade!|\nadd_button|cl0se|`wClose|\nadd_quick_exit|");
											}
											else
											{
												Player::OnDialogRequest(peer, "add_label_with_icon|big|`oUpgrade Ancestral Totem of Wisdom|left|5078|\nadd_spacer|small|\nadd_textbox|`oWelcome to the Ancient Goddess child|\nadd_smalltext|`oI want you to deliver me 100.000.000 Gems.|left|\nadd_smalltext|`o(You currently have " + to_string(plrGems) + " Gems in your account)|left|\nadd_spacer|small|\nadd_button|cl0se|`wClose|\nadd_quick_exit|");
											}
										}
										else
										{
											Player::OnDialogRequest(peer, "add_label_with_icon|big|`oUpgrade Ancestral Totem of Wisdom|left|5078|\nadd_spacer|small|\nadd_textbox|`oYou don't seem to have Ancestral Totem of Wisdom, come back here if you got one child.|\nadd_spacer|small|\nadd_button|cl0se|`wClose|\nadd_quick_exit|");
											ofstream fd("save/ances/currentquest/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
											fd << "";
											fd.close();
										}
									}
								}
								if (btn == "upric") {
									bool checkForPlr = std::experimental::filesystem::exists("save/ances/riches/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									if (checkForPlr == true) {
										Player::OnDialogRequest(peer, "add_label_with_icon|big|`oUpgrade Ancestral Lens of Riches|left|5084|\nadd_spacer|small|\nadd_textbox|`oMy child, it seems like you have upgraded your Ancestral Lens of Riches to the maximum level.|\nadd_spacer|small|\nadd_button|cl0se|`wClose|\nadd_quick_exit|");
									}
									else
									{
										ofstream fd("save/ances/currentquest/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										fd << "riches";
										fd.close();
										bool iscontains = false;
										SearchInventoryItem(peer, 5084, 1, iscontains);
										if (iscontains) {
											int plrGems = 0;
											ifstream getPlrGems("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
											getPlrGems >> plrGems;
											getPlrGems.close();
											if (plrGems >= 100000000) {
												Player::OnDialogRequest(peer, "add_label_with_icon|big|`oUpgrade Ancestral Lens of Riches|left|5084|\nadd_spacer|small|\nadd_textbox|`oWelcome to the Ancient Goddess child|\nadd_smalltext|`oI want you to deliver me 100.000.000 Gems.|left|\nadd_smalltext|`o(You currently have " + to_string(plrGems) + " Gems in your account)|left|\nadd_spacer|small|\nadd_button|claimric|Upgrade!|\nadd_button|cl0se|`wClose|\nadd_quick_exit|");
											}
											else
											{
												Player::OnDialogRequest(peer, "add_label_with_icon|big|`oUpgrade Ancestral Lens of Riches|left|5084|\nadd_spacer|small|\nadd_textbox|`oWelcome to the Ancient Goddess child|\nadd_smalltext|`oI want you to deliver me 100.000.000 Gems.|left|\nadd_smalltext|`o(You currently have " + to_string(plrGems) + " Gems in your account)|left|\nadd_spacer|small|\nadd_button|cl0se|`wClose|\nadd_quick_exit|");
											}
										}
										else
										{
											Player::OnDialogRequest(peer, "add_label_with_icon|big|`oUpgrade Ancestral Lens of Riches|left|5084|\nadd_spacer|small|\nadd_textbox|`oYou don't seem to have Ancestral Totem of Wisdom, come back here if you got one child.|\nadd_spacer|small|\nadd_button|cl0se|`wClose|\nadd_quick_exit|");
											ofstream fd("save/ances/currentquest/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
											fd << "";
											fd.close();
										}
									}
								}
								if (btn == "uplif") {
									bool checkForPlr = std::experimental::filesystem::exists("save/ances/life/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									if (checkForPlr == true) {
										Player::OnDialogRequest(peer, "add_label_with_icon|big|`oUpgrade Ancestral Seed of Life|left|5082|\nadd_spacer|small|\nadd_textbox|`oMy child, it seems like you have upgraded your Ancestral Seed of Life to the maximum level.|\nadd_spacer|small|\nadd_button|cl0se|`wClose|\nadd_quick_exit|");
									}
									else
									{
										ofstream fd("save/ances/currentquest/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										fd << "life";
										fd.close();
										bool iscontains = false;
										SearchInventoryItem(peer, 5082, 1, iscontains);
										if (iscontains) {
											int plrGems = 0;
											ifstream getPlrGems("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
											getPlrGems >> plrGems;
											getPlrGems.close();
											if (plrGems >= 100000000) {
												Player::OnDialogRequest(peer, "add_label_with_icon|big|`oUpgrade Ancestral Seed of Life|left|5082|\nadd_spacer|small|\nadd_textbox|`oWelcome to the Ancient Goddess child|\nadd_smalltext|`oI want you to deliver me 100.000.000 Gems.|left|\nadd_smalltext|`o(You currently have " + to_string(plrGems) + " Gems in your account)|left|\nadd_spacer|small|\nadd_button|claimlif|Upgrade!|\nadd_button|cl0se|`wClose|\nadd_quick_exit|");
											}
											else
											{
												Player::OnDialogRequest(peer, "add_label_with_icon|big|`oUpgrade Ancestral Seed of Life|left|5082|\nadd_spacer|small|\nadd_textbox|`oWelcome to the Ancient Goddess child|\nadd_smalltext|`oI want you to deliver me 100.000.000 Gems.|left|\nadd_smalltext|`o(You currently have " + to_string(plrGems) + " Gems in your account)|left|\nadd_spacer|small|\nadd_button|cl0se|`wClose|\nadd_quick_exit|");
											}
										}
										else
										{
											Player::OnDialogRequest(peer, "add_label_with_icon|big|`oUpgrade Ancestral Seed of Life|left|5082|\nadd_spacer|small|\nadd_textbox|`oYou don't seem to have Ancestral Seed of Life, come back here if you got one child.|\nadd_spacer|small|\nadd_button|cl0se|`wClose|\nadd_quick_exit|");
											ofstream fd("save/ances/currentquest/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
											fd << "";
											fd.close();
										}
									}
								}
								if (btn == "uptim") {
									bool checkForPlr = std::experimental::filesystem::exists("save/ances/time/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									if (checkForPlr == true) {
										Player::OnDialogRequest(peer, "add_label_with_icon|big|`oUpgrade Ancestral Orb of Time|left|7166|\nadd_spacer|small|\nadd_textbox|`oMy child, it seems like you have upgraded your Ancestral Orb of Time to the maximum level.|\nadd_spacer|small|\nadd_button|cl0se|`wClose|\nadd_quick_exit|");
									}
									else
									{
										ofstream fd("save/ances/currentquest/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										fd << "time";
										fd.close();
										bool iscontains = false;
										SearchInventoryItem(peer, 7166, 1, iscontains);
										if (iscontains) {
											int plrGems = 0;
											ifstream getPlrGems("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
											getPlrGems >> plrGems;
											getPlrGems.close();
											if (plrGems >= 100000000) {
												Player::OnDialogRequest(peer, "add_label_with_icon|big|`oUpgrade Ancestral Orb of Time|left|7166|\nadd_spacer|small|\nadd_textbox|`oWelcome to the Ancient Goddess child|\nadd_smalltext|`oI want you to deliver me 100.000.000 Gems.|left|\nadd_smalltext|`o(You currently have " + to_string(plrGems) + " Gems in your account)|left|\nadd_spacer|small|\nadd_button|claimtim|Upgrade!|\nadd_button|cl0se|`wClose|\nadd_quick_exit|");
											}
											else
											{
												Player::OnDialogRequest(peer, "add_label_with_icon|big|`oUpgrade Ancestral Orb of Time|left|7166|\nadd_spacer|small|\nadd_textbox|`oWelcome to the Ancient Goddess child|\nadd_smalltext|`oI want you to deliver me 100.000.000 Gems.|left|\nadd_smalltext|`o(You currently have " + to_string(plrGems) + " Gems in your account)|left|\nadd_spacer|small|\nadd_button|cl0se|`wClose|\nadd_quick_exit|");
											}
										}
										else
										{
											Player::OnDialogRequest(peer, "add_label_with_icon|big|`oUpgrade Ancestral Orb of Time|left|7166|\nadd_spacer|small|\nadd_textbox|`oYou don't seem to have Ancestral Orb of Time, come back here if you got one child.|\nadd_spacer|small|\nadd_button|cl0se|`wClose|\nadd_quick_exit|");
											ofstream fd("save/ances/currentquest/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
											fd << "";
											fd.close();
										}
									}
								}
								if (btn == "updim") {
									bool checkForPlr = std::experimental::filesystem::exists("save/ances/dimension/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									if (checkForPlr == true) {
										Player::OnDialogRequest(peer, "add_label_with_icon|big|`oUpgrade Ancestral Tesseract of Dimensions|left|5080|\nadd_spacer|small|\nadd_textbox|`oMy child, it seems like you have upgraded your Ancestral Tesseract of Dimensions to the maximum level.|\nadd_spacer|small|\nadd_button|cl0se|`wClose|\nadd_quick_exit|");
									}
									else
									{
										ofstream fd("save/ances/currentquest/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										fd << "dimension";
										fd.close();
										bool iscontains = false;
										SearchInventoryItem(peer, 5080, 1, iscontains);
										if (iscontains) {
											int plrGems = 0;
											ifstream getPlrGems("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
											getPlrGems >> plrGems;
											getPlrGems.close();
											if (plrGems >= 100000000) {
												Player::OnDialogRequest(peer, "add_label_with_icon|big|`oUpgrade Ancestral Tesseract of Dimensions|left|5080|\nadd_spacer|small|\nadd_textbox|`oWelcome to the Ancient Goddess child|\nadd_smalltext|`oI want you to deliver me 100.000.000 Gems.|left|\nadd_smalltext|`o(You currently have " + to_string(plrGems) + " Gems in your account)|left|\nadd_spacer|small|\nadd_button|claimdim|Upgrade!|\nadd_button|cl0se|`wClose|\nadd_quick_exit|");
											}
											else
											{
												Player::OnDialogRequest(peer, "add_label_with_icon|big|`oUpgrade Ancestral Tesseract of Dimensions|left|5080|\nadd_spacer|small|\nadd_textbox|`oWelcome to the Ancient Goddess child|\nadd_smalltext|`oI want you to deliver me 100.000.000 Gems.|left|\nadd_smalltext|`o(You currently have " + to_string(plrGems) + " Gems in your account)|left|\nadd_spacer|small|\nadd_button|cl0se|`wClose|\nadd_quick_exit|");
											}
										}
										else
										{
											Player::OnDialogRequest(peer, "add_label_with_icon|big|`oUpgrade Ancestral Tesseract of Dimensions|left|5080|\nadd_spacer|small|\nadd_textbox|`oYou don't seem to have Ancestral Totem of Wisdom, come back here if you got one child.|\nadd_spacer|small|\nadd_button|cl0se|`wClose|\nadd_quick_exit|");
											ofstream fd("save/ances/currentquest/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
											fd << "";
											fd.close();
										}
									}
								}
								if (btn == "claimdim") {
									ofstream fd("save/ances/currentqueststep/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									fd << 2;
									fd.close();
									bool iscontains = false;
									SearchInventoryItem(peer, 5080, 1, iscontains);
									if (iscontains) {
										Player::onMinGems(peer, 100000000);
										RemoveInventoryItem(5080, 1, peer, true);
										bool success = true;
										SaveItemMoreTimes(5144, 1, peer, success);
										static_cast<PlayerInfo*>(peer->data)->cloth_ances = 5144;
										sendClothes(peer);
										Player::OnAddNotification(peer, "`wYou upgraded your Ancestral Tesseract of Dimensions to Level 2!", "audio/hub_open.wav", "interface/atomic_button.rttex");
									}
								}
								if (btn == "claimdim1") {
									ofstream fd("save/ances/currentqueststep/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									fd << 3;
									fd.close();
									bool iscontains = false;
									SearchInventoryItem(peer, 5144, 1, iscontains);
									if (iscontains) {
										RemoveInventoryItem(5144, 1, peer, true);
										RemoveInventoryItem(5070, 50, peer, true);
										RemoveInventoryItem(6156, 100, peer, true);
										bool success = true;
										SaveItemMoreTimes(5146, 1, peer, success);
										static_cast<PlayerInfo*>(peer->data)->cloth_ances = 5146;
										sendClothes(peer);
										Player::OnAddNotification(peer, "`wYou upgraded your Ancestral Tesseract of Dimensions to Level 3!", "audio/hub_open.wav", "interface/atomic_button.rttex");
									}
								}
								if (btn == "claimdim2") {
									ofstream fd("save/ances/currentqueststep/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									fd << 4;
									fd.close();
									bool iscontains = false;
									SearchInventoryItem(peer, 5146, 1, iscontains);
									if (iscontains) {
										RemoveInventoryItem(5146, 1, peer, true);
										bool success = true;
										SaveItemMoreTimes(5148, 1, peer, success);
										static_cast<PlayerInfo*>(peer->data)->cloth_ances = 5148;
										sendClothes(peer);
										Player::OnAddNotification(peer, "`wYou upgraded your Ancestral Tesseract of Dimensions to Level 4!", "audio/hub_open.wav", "interface/atomic_button.rttex");
									}
								}
								if (btn == "claimdim3") {
									ofstream fd("save/ances/currentqueststep/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									fd << 5;
									fd.close();
									bool iscontains = false;
									SearchInventoryItem(peer, 5148, 1, iscontains);
									if (iscontains) {
										RemoveInventoryItem(5148, 1, peer, true);
										bool success = true;
										SaveItemMoreTimes(51450, 1, peer, success);
										static_cast<PlayerInfo*>(peer->data)->cloth_ances = 5150;
										sendClothes(peer);
										Player::OnAddNotification(peer, "`wYou upgraded your Ancestral Tesseract of Dimensions to Level 5!", "audio/hub_open.wav", "interface/atomic_button.rttex");
									}
								}
								if (btn == "claimdim4") {
									ofstream currentStep("save/ances/currentqueststep/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									currentStep << 1;
									currentStep.close();
									ofstream currentQuest("save/ances/currentquest/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									currentQuest << "";
									currentQuest.close();

									bool iscontains = false;
									SearchInventoryItem(peer, 5150, 1, iscontains);
									if (iscontains) {
										Player::onMinGems(peer, 1000000000);
										RemoveInventoryItem(5150, 1, peer, true);
										RemoveInventoryItem(5480, 50, peer, true);
										bool success = true;
										SaveItemMoreTimes(5152, 1, peer, success);
										static_cast<PlayerInfo*>(peer->data)->cloth_ances = 5152;
										sendClothes(peer);
										Player::OnAddNotification(peer, "`wYou upgraded your Ancestral Tesseract of Dimensions to Level 6!", "audio/hub_open.wav", "interface/atomic_button.rttex");
										ofstream addFile("save/ances/dimension/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										addFile.close();
									}
								}
								if (btn == "claimtim") {
									ofstream fd("save/ances/currentqueststep/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									fd << 2;
									fd.close();
									bool iscontains = false;
									SearchInventoryItem(peer, 7166, 1, iscontains);
									if (iscontains) {
										Player::onMinGems(peer, 100000000);
										RemoveInventoryItem(7166, 1, peer, true);
										bool success = true;
										SaveItemMoreTimes(7168, 1, peer, success);
										static_cast<PlayerInfo*>(peer->data)->cloth_ances = 7168;
										sendClothes(peer);
										Player::OnAddNotification(peer, "`wYou upgraded your Ancestral Orb of Time to Level 2!", "audio/hub_open.wav", "interface/atomic_button.rttex");
									}
								}
								if (btn == "claimtim1") {
									ofstream fd("save/ances/currentqueststep/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									fd << 3;
									fd.close();
									bool iscontains = false;
									SearchInventoryItem(peer, 7168, 1, iscontains);
									if (iscontains) {
										RemoveInventoryItem(7168, 1, peer, true);
										RemoveInventoryItem(7186, 50, peer, true);
										RemoveInventoryItem(2252, 100, peer, true);
										bool success = true;
										SaveItemMoreTimes(7170, 1, peer, success);
										static_cast<PlayerInfo*>(peer->data)->cloth_ances = 7170;
										sendClothes(peer);
										Player::OnAddNotification(peer, "`wYou upgraded your Ancestral Orb of Time to Level 3!", "audio/hub_open.wav", "interface/atomic_button.rttex");
									}
								}
								if (btn == "claimtim2") {
									ofstream fd("save/ances/currentqueststep/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									fd << 4;
									fd.close();
									bool iscontains = false;
									SearchInventoryItem(peer, 7170, 1, iscontains);
									if (iscontains) {
										RemoveInventoryItem(7170, 1, peer, true);
										bool success = true;
										SaveItemMoreTimes(7172, 1, peer, success);
										static_cast<PlayerInfo*>(peer->data)->cloth_ances = 7172;
										sendClothes(peer);
										Player::OnAddNotification(peer, "`wYou upgraded your Ancestral Orb of Time to Level 4!", "audio/hub_open.wav", "interface/atomic_button.rttex");
									}
								}
								if (btn == "claimtim3") {
									ofstream fd("save/ances/currentqueststep/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									fd << 5;
									fd.close();
									bool iscontains = false;
									SearchInventoryItem(peer, 7172, 1, iscontains);
									if (iscontains) {
										RemoveInventoryItem(7172, 1, peer, true);
										bool success = true;
										SaveItemMoreTimes(7174, 1, peer, success);
										static_cast<PlayerInfo*>(peer->data)->cloth_ances = 7174;
										sendClothes(peer);
										Player::OnAddNotification(peer, "`wYou upgraded your Ancestral Orb of Time to Level 5!", "audio/hub_open.wav", "interface/atomic_button.rttex");
									}
								}
								if (btn == "claimtim4") {
									ofstream currentStep("save/ances/currentqueststep/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									currentStep << 1;
									currentStep.close();
									ofstream currentQuest("save/ances/currentquest/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									currentQuest << "";
									currentQuest.close();

									bool iscontains = false;
									SearchInventoryItem(peer, 7174, 1, iscontains);
									if (iscontains) {
										Player::onMinGems(peer, 1000000000);
										RemoveInventoryItem(7174, 1, peer, true);
										RemoveInventoryItem(5480, 50, peer, true);
										bool success = true;
										SaveItemMoreTimes(9212, 1, peer, success);
										static_cast<PlayerInfo*>(peer->data)->cloth_ances = 9212;
										sendClothes(peer);
										Player::OnAddNotification(peer, "`wYou upgraded your Ancestral Orb of Time to Level 6!", "audio/hub_open.wav", "interface/atomic_button.rttex");
										ofstream addFile("save/ances/time/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										addFile.close();
									}
								}
								if (btn == "claimlif") {
									ofstream fd("save/ances/currentqueststep/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									fd << 2;
									fd.close();
									bool iscontains = false;
									SearchInventoryItem(peer, 5082, 1, iscontains);
									if (iscontains) {
										Player::onMinGems(peer, 100000000);
										RemoveInventoryItem(5082, 1, peer, true);
										bool success = true;
										SaveItemMoreTimes(5162, 1, peer, success);
										static_cast<PlayerInfo*>(peer->data)->cloth_ances = 5162;
										sendClothes(peer);
										Player::OnAddNotification(peer, "`wYou upgraded your Ancestral Seed of Life to Level 2!", "audio/hub_open.wav", "interface/atomic_button.rttex");
									}
								}
								if (btn == "claimlif1") {
									ofstream fd("save/ances/currentqueststep/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									fd << 3;
									fd.close();
									bool iscontains = false;
									SearchInventoryItem(peer, 5162, 1, iscontains);
									if (iscontains) {
										RemoveInventoryItem(5162, 1, peer, true);
										RemoveInventoryItem(5076, 50, peer, true);
										RemoveInventoryItem(2072, 100, peer, true);
										bool success = true;
										SaveItemMoreTimes(5164, 1, peer, success);
										static_cast<PlayerInfo*>(peer->data)->cloth_ances = 5164;
										sendClothes(peer);
										Player::OnAddNotification(peer, "`wYou upgraded your Ancestral Seed of Life to Level 3!", "audio/hub_open.wav", "interface/atomic_button.rttex");
									}
								}
								if (btn == "claimlif2") {
									ofstream fd("save/ances/currentqueststep/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									fd << 4;
									fd.close();
									bool iscontains = false;
									SearchInventoryItem(peer, 5164, 1, iscontains);
									if (iscontains) {
										RemoveInventoryItem(5164, 1, peer, true);
										bool success = true;
										SaveItemMoreTimes(5166, 1, peer, success);
										static_cast<PlayerInfo*>(peer->data)->cloth_ances = 5166;
										sendClothes(peer);
										Player::OnAddNotification(peer, "`wYou upgraded your Ancestral Seed of Life to Level 4!", "audio/hub_open.wav", "interface/atomic_button.rttex");
									}
								}
								if (btn == "claimlif3") {
									ofstream fd("save/ances/currentqueststep/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									fd << 5;
									fd.close();
									bool iscontains = false;
									SearchInventoryItem(peer, 5166, 1, iscontains);
									if (iscontains) {
										RemoveInventoryItem(5166, 1, peer, true);
										bool success = true;
										SaveItemMoreTimes(5168, 1, peer, success);
										static_cast<PlayerInfo*>(peer->data)->cloth_ances = 5168;
										sendClothes(peer);
										Player::OnAddNotification(peer, "`wYou upgraded your Ancestral Seed of Life to Level 5!", "audio/hub_open.wav", "interface/atomic_button.rttex");
									}
								}
								if (btn == "claimlif4") {
									ofstream currentStep("save/ances/currentqueststep/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									currentStep << 1;
									currentStep.close();
									ofstream currentQuest("save/ances/currentquest/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									currentQuest << "";
									currentQuest.close();

									bool iscontains = false;
									SearchInventoryItem(peer, 5168, 1, iscontains);
									if (iscontains) {
										Player::onMinGems(peer, 1000000000);
										RemoveInventoryItem(5168, 1, peer, true);
										RemoveInventoryItem(5480, 50, peer, true);
										bool success = true;
										SaveItemMoreTimes(5170, 1, peer, success);
										static_cast<PlayerInfo*>(peer->data)->cloth_ances = 5170;
										sendClothes(peer);
										Player::OnAddNotification(peer, "`wYou upgraded your Ancestral Seed of Life to Level 6!", "audio/hub_open.wav", "interface/atomic_button.rttex");
										ofstream addFile("save/ances/life/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										addFile.close();
									}
								}
								if (btn == "claimric") {
									ofstream fd("save/ances/currentqueststep/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									fd << 2;
									fd.close();
									bool iscontains = false;
									SearchInventoryItem(peer, 5084, 1, iscontains);
									if (iscontains) {
										Player::onMinGems(peer, 100000000);
										RemoveInventoryItem(5084, 1, peer, true);
										bool success = true;
										SaveItemMoreTimes(5180, 1, peer, success);
										static_cast<PlayerInfo*>(peer->data)->cloth_ances = 5180;
										sendClothes(peer);
										Player::OnAddNotification(peer, "`wYou upgraded your Ancestral Lens of Riches to Level 2!", "audio/hub_open.wav", "interface/atomic_button.rttex");
									}
								}
								if (btn == "claimric1") {
									ofstream fd("save/ances/currentqueststep/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									fd << 3;
									fd.close();
									bool iscontains = false;
									SearchInventoryItem(peer, 5180, 1, iscontains);
									if (iscontains) {
										RemoveInventoryItem(5180, 1, peer, true);
										RemoveInventoryItem(5072, 50, peer, true);
										RemoveInventoryItem(2250, 100, peer, true);
										bool success = true;
										SaveItemMoreTimes(5182, 1, peer, success);
										static_cast<PlayerInfo*>(peer->data)->cloth_ances = 5182;
										sendClothes(peer);
										Player::OnAddNotification(peer, "`wYou upgraded your Ancestral Lens of Riches to Level 3!", "audio/hub_open.wav", "interface/atomic_button.rttex");
									}
								}
								if (btn == "claimric2") {
									ofstream fd("save/ances/currentqueststep/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									fd << 4;
									fd.close();
									bool iscontains = false;
									SearchInventoryItem(peer, 5182, 1, iscontains);
									if (iscontains) {
										RemoveInventoryItem(5182, 1, peer, true);
										bool success = true;
										SaveItemMoreTimes(5184, 1, peer, success);
										static_cast<PlayerInfo*>(peer->data)->cloth_ances = 5184;
										sendClothes(peer);
										Player::OnAddNotification(peer, "`wYou upgraded your Ancestral Lens of Riches to Level 4!", "audio/hub_open.wav", "interface/atomic_button.rttex");
									}
								}
								if (btn == "claimric3") {
									ofstream fd("save/ances/currentqueststep/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									fd << 5;
									fd.close();
									bool iscontains = false;
									SearchInventoryItem(peer, 5184, 1, iscontains);
									if (iscontains) {
										RemoveInventoryItem(5184, 1, peer, true);
										bool success = true;
										SaveItemMoreTimes(5186, 1, peer, success);
										static_cast<PlayerInfo*>(peer->data)->cloth_ances = 5186;
										sendClothes(peer);
										Player::OnAddNotification(peer, "`wYou upgraded your Ancestral Lens of Riches to Level 5!", "audio/hub_open.wav", "interface/atomic_button.rttex");
									}
								}
								if (btn == "claimric4") {
									ofstream currentStep("save/ances/currentqueststep/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									currentStep << 1;
									currentStep.close();
									ofstream currentQuest("save/ances/currentquest/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									currentQuest << "";
									currentQuest.close();

									bool iscontains = false;
									SearchInventoryItem(peer, 5186, 1, iscontains);
									if (iscontains) {
										Player::onMinGems(peer, 1000000000);
										RemoveInventoryItem(5186, 1, peer, true);
										RemoveInventoryItem(5480, 50, peer, true);
										bool success = true;
										SaveItemMoreTimes(5188, 1, peer, success);
										static_cast<PlayerInfo*>(peer->data)->cloth_ances = 5188;
										sendClothes(peer);
										Player::OnAddNotification(peer, "`wYou upgraded your Ancestral Lens of Riches to Level 6!", "audio/hub_open.wav", "interface/atomic_button.rttex");
										ofstream addFile("save/ances/riches/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										addFile.close();
									}
								}
								if (btn == "claimwis") {
									ofstream fd("save/ances/currentqueststep/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									fd << 2;
									fd.close();
									bool iscontains = false;
									SearchInventoryItem(peer, 5078, 1, iscontains);
									if (iscontains) {
										Player::onMinGems(peer, 100000000);
										RemoveInventoryItem(5078, 1, peer, true);
										bool success = true;
										SaveItemMoreTimes(5126, 1, peer, success);
										static_cast<PlayerInfo*>(peer->data)->cloth_ances = 5126;
										sendClothes(peer);
										Player::OnAddNotification(peer, "`wYou upgraded your Ancestral Totem of Wisdom to Level 2!", "audio/hub_open.wav", "interface/atomic_button.rttex");
									}
								}
								if (btn == "claimwis1") {
									ofstream fd("save/ances/currentqueststep/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									fd << 3;
									fd.close();
									bool iscontains = false;
									SearchInventoryItem(peer, 5126, 1, iscontains);
									if (iscontains) {
										RemoveInventoryItem(5126, 1, peer, true);
										RemoveInventoryItem(5074, 50, peer, true);
										RemoveInventoryItem(2248, 100, peer, true);
										bool success = true;
										SaveItemMoreTimes(5128, 1, peer, success);
										static_cast<PlayerInfo*>(peer->data)->cloth_ances = 5128;
										sendClothes(peer);
										Player::OnAddNotification(peer, "`wYou upgraded your Ancestral Totem of Wisdom to Level 3!", "audio/hub_open.wav", "interface/atomic_button.rttex");
									}
								}
								if (btn == "claimwis2") {
									ofstream fd("save/ances/currentqueststep/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									fd << 4;
									fd.close();
									bool iscontains = false;
									SearchInventoryItem(peer, 5128, 1, iscontains);
									if (iscontains) {
										RemoveInventoryItem(5128, 1, peer, true);
										bool success = true;
										SaveItemMoreTimes(5130, 1, peer, success);
										static_cast<PlayerInfo*>(peer->data)->cloth_ances = 5130;
										sendClothes(peer);
										Player::OnAddNotification(peer, "`wYou upgraded your Ancestral Totem of Wisdom to Level 4!", "audio/hub_open.wav", "interface/atomic_button.rttex");
									}
								}
								if (btn == "claimwis3") {
									ofstream fd("save/ances/currentqueststep/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									fd << 5;
									fd.close();
									bool iscontains = false;
									SearchInventoryItem(peer, 5130, 1, iscontains);
									if (iscontains) {
										RemoveInventoryItem(5130, 1, peer, true);
										bool success = true;
										SaveItemMoreTimes(5132, 1, peer, success);
										static_cast<PlayerInfo*>(peer->data)->cloth_ances = 5132;
										sendClothes(peer);
										Player::OnAddNotification(peer, "`wYou upgraded your Ancestral Totem of Wisdom to Level 5!", "audio/hub_open.wav", "interface/atomic_button.rttex");
									}
								}
								if (btn == "claimwis4") {
									ofstream currentStep("save/ances/currentqueststep/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									currentStep << 1;
									currentStep.close();
									ofstream currentQuest("save/ances/currentquest/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									currentQuest << "";
									currentQuest.close();

									bool iscontains = false;
									SearchInventoryItem(peer, 5132, 1, iscontains);
									if (iscontains) {
										Player::onMinGems(peer, 1000000000);
										RemoveInventoryItem(5132, 1, peer, true);
										RemoveInventoryItem(5480, 50, peer, true);
										bool success = true;
										SaveItemMoreTimes(5134, 1, peer, success);
										static_cast<PlayerInfo*>(peer->data)->cloth_ances = 5134;
										sendClothes(peer);
										Player::OnAddNotification(peer, "`wYou upgraded your Ancestral Totem of Wisdom to Level 6!", "audio/hub_open.wav", "interface/atomic_button.rttex");
										ofstream addFile("save/ances/wisdom/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										addFile.close();
									}
								}
								if (btn == "getgtokenok") {
									std::ifstream ifsz("save/dailyquest/dailyitem1.txt");
									std::string content((std::istreambuf_iterator<char>(ifsz)),
										(std::istreambuf_iterator<char>()));
									int id = atoi(content.c_str());
									std::ifstream ifsz2("save/dailyquest/dailyitem2.txt");
									std::string content2((std::istreambuf_iterator<char>(ifsz2)),
										(std::istreambuf_iterator<char>()));
									int id2 = atoi(content2.c_str());
									std::ifstream ifszs("save/dailyquest/dailycount1.txt");
									std::string contents((std::istreambuf_iterator<char>(ifszs)),
										(std::istreambuf_iterator<char>()));
									int quantity = atoi(contents.c_str());
									std::ifstream ifszs2("save/dailyquest/dailycount2.txt");
									std::string contents2((std::istreambuf_iterator<char>(ifszs2)),
										(std::istreambuf_iterator<char>()));
									int quantity2 = atoi(contents2.c_str());
									bool success = true;
									SaveItemMoreTimes(1486, 1, peer, success);
									RemoveInventoryItem(id, quantity, peer, true);
									RemoveInventoryItem(id2, quantity2, peer, true);
									Player::OnAddNotification(peer, "`wYou claimed `21 Growtoken!", "audio/hub_open.wav", "interface/cash_icon_overlay.rttex");
									ofstream pGems("save/dailyquest/completed/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									pGems.close();
								}
								if (btn == "convertdl")
								{
									RemoveInventoryItem(1796, 100, peer, true);
									Player::OnAddNotification(peer, "`wYou got `21 Blue Gem Lock!", "audio/hub_open.wav", "interface/cash_icon_overlay.rttex");
									bool success = true;
									SaveItemMoreTimes(7188, 1, peer, success);
									Player::PlayAudio(peer, "audio/getpoint.wav", 0);
									SendTradeEffect(peer, 7188, static_cast<PlayerInfo*>(peer->data)->netID, static_cast<PlayerInfo*>(peer->data)->netID, 500);
								}
								if (btn == "confirmcreateguild") {
									int plrGems = 0;
									ifstream getPlrGems("save/gemdb/_" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									getPlrGems >> plrGems;
									getPlrGems.close();
									if (plrGems >= 250000) {
										Player::onMinGems(peer, 250000);
										string guildName = ((PlayerInfo*)(peer->data))->createGuildName;
										string guildStatement = ((PlayerInfo*)(peer->data))->createGuildStatement;
										string fixedguildName = PlayerDB::getProperName(guildName);
										string guildFlagbg = ((PlayerInfo*)(peer->data))->createGuildFlagBg;
										string guildFlagfg = ((PlayerInfo*)(peer->data))->createGuildFlagFg;
										world->category = "Guild";
										world->worldGuild = guildName;
										Player::OnAddNotification(peer, "`w" + guildName + " guild have been created!", "audio/gong.wav", "interface/large/gd_prom.rttex");
										std::ofstream o("save/guilds/_" + fixedguildName + ".json");
										if (!o.is_open()) {
											cout << GetLastError() << endl;
											_getch();
										}
										json j;
										vector<string> test1s;
										vector<string>test2s;
										((PlayerInfo*)(peer->data))->guildMembers.push_back(((PlayerInfo*)(peer->data))->rawName);
										j["GuildName"] = ((PlayerInfo*)(peer->data))->createGuildName;
										j["GuildRawName"] = fixedguildName;
										j["GuildStatement"] = ((PlayerInfo*)(peer->data))->createGuildStatement;
										j["Leader"] = ((PlayerInfo*)(peer->data))->rawName;
										j["Co-Leader"] = ((PlayerInfo*)(peer->data))->guildGC;
										j["Elder-Leader"] = ((PlayerInfo*)(peer->data))->guildGE;
										j["Member"] = ((PlayerInfo*)(peer->data))->guildMembers;
										j["GuildLevel"] = 1;
										j["GuildExp"] = 0;
										j["GuildWorld"] = ((PlayerInfo*)(peer->data))->currentWorld;
										j["backgroundflag"] = stoi(((PlayerInfo*)(peer->data))->createGuildFlagBg);
										j["foregroundflag"] = stoi(((PlayerInfo*)(peer->data))->createGuildFlagFg);
										o << j << std::endl;
										ifstream fg("save/players/_" + ((PlayerInfo*)(peer->data))->rawName + ".json");
										json x;
										fg >> x;
										fg.close();
										x["guild"] = guildName;
										x["joinguild"] = true;
										ofstream fs("save/players/_" + ((PlayerInfo*)(peer->data))->rawName + ".json");
										fs << x;
										fs.close();
										((PlayerInfo*)(peer->data))->guild = guildName;
										((PlayerInfo*)(peer->data))->joinguild = true;
										((PlayerInfo*)(peer->data))->guildFg = atoi(((PlayerInfo*)(peer->data))->createGuildFlagFg.c_str());
										((PlayerInfo*)(peer->data))->guildBg = atoi(((PlayerInfo*)(peer->data))->createGuildFlagBg.c_str());
										// GAY
										string name2;
										string namemsg = ((PlayerInfo*)(peer->data))->rawName;
										if (static_cast<PlayerInfo*>(peer->data)->adminLevel != 0) {
											name2 = role_prefix.at(static_cast<PlayerInfo*>(peer->data)->adminLevel) + static_cast<PlayerInfo*>(peer->data)->tankIDName + " `e(GL)``";
										}
										else
										{
											name2 = "`w" + ((PlayerInfo*)(peer->data))->tankIDName + " `e(GL)";
										}
										((PlayerInfo*)(peer->data))->displayName = name2;
										((PlayerInfo*)(peer->data))->msgName = namemsg;
										ENetPeer* currentPeer;
										for (currentPeer = server->peers;
											currentPeer < &server->peers[server->peerCount];
											++currentPeer)
										{
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
												continue;
											if (isHere(peer, currentPeer)) {
												Player::OnNameChanged(currentPeer, ((PlayerInfo*)(peer->data))->netID, name2);
											}
										}
										updateInvis(peer);
									}
									else
									{
										Player::OnConsoleMessage(peer, "`oYou don't have enough gems to create a guild!");
										continue;
									}
								}
								if (btn == "goguildhome") {
									string gworld;
									string guildName = ((PlayerInfo*)(peer->data))->guild;
									std::ifstream ifs("save/guilds/_" + PlayerDB::getProperName(((PlayerInfo*)(peer->data))->guild) + ".json");
									if (ifs.is_open()) {
										json j;
										ifs >> j;
										gworld = j["GuildWorld"].get<string>();
									}
									sendPlayerLeave(peer);
									handle_world(peer, gworld);
								}
								if (btn == "removegmoffline") {
									if (((PlayerInfo*)(peer->data))->currentWorld == "EXIT") continue;
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
										if (((PlayerInfo*)(currentPeer->data))->guild == ((PlayerInfo*)(peer->data))->guild) {
											try {
												std::ifstream ifff("save/guilds/_" + PlayerDB::getProperName(((PlayerInfo*)(peer->data))->guild) + ".json");
												if (ifff.fail()) {
													ifff.close();
													Player::OnConsoleMessage(peer, "`4Error: `oGuild does not exist! If you are seeing this message, please take a screenshot and send it to a developer!");
													continue;
												}
												if (ifff.is_open()) {
												}
												json j;
												ifff >> j; //load
												vector<string> gmlist;
												for (int i = 0; i < j["Member"].size(); i++) {
													gmlist.push_back(j["Member"][i]);
												}
												gmlist.erase(std::remove(gmlist.begin(), gmlist.end(), ((PlayerInfo*)(peer->data))->lastgm), gmlist.end());
												j["Member"] = gmlist; //edit
												std::ofstream o("save/guilds/_" + PlayerDB::getProperName(((PlayerInfo*)(peer->data))->guild) + ".json"); //save
												if (!o.is_open()) continue;
												o << j << std::endl;
												ifstream fg("save/players/_" + PlayerDB::getProperName(((PlayerInfo*)(peer->data))->lastgm) + ".json");
												json j2;
												fg >> j2;
												fg.close();
												j2["guild"] = "";
												j2["joinguild"] = false;
												ofstream fs("save/players/_" + PlayerDB::getProperName(((PlayerInfo*)(peer->data))->lastgm) + ".json");
												fs << j2;
												fs.close();
												Player::OnConsoleMessage(peer, "`5[GUILD ALERT] `2" + ((PlayerInfo*)(peer->data))->lastgm + "`o has been kicked from the guild!");
											}
											catch (std::exception&) {
												SendConsole("removegmoffline Critical error details: rawName(" + ((PlayerInfo*)(peer->data))->rawName + ")", "ERROR");
												enet_peer_disconnect_now(peer, 0);
											}
											catch (std::runtime_error&) {
												SendConsole("removegmoffline Critical error details: name(" + ((PlayerInfo*)(peer->data))->rawName + ")", "ERROR");
												enet_peer_disconnect_now(peer, 0);
											}
											catch (...) {
												SendConsole("removegmoffline Critical error details: name(" + ((PlayerInfo*)(peer->data))->rawName + ")", "ERROR");
												enet_peer_disconnect_now(peer, 0);
											}
										}
									}
									Player::OnDialogRequest(peer, "set_default_color|`o\n\nadd_label_with_icon|big|`4Guild Member removed``|left|1366|\n\nadd_spacer|small|\nadd_textbox|`o" + ((PlayerInfo*)(peer->data))->lastgm + " is no longer in the guild.``|\n\nadd_spacer|small|\nadd_button|guildportalbutton|`oOK``|0|0|\nadd_quick_exit|");
								}
								if (btn == "removegmonline") {
									if (((PlayerInfo*)(peer->data))->currentWorld == "EXIT") continue;
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
										if (((PlayerInfo*)(currentPeer->data))->rawName == ((PlayerInfo*)(peer->data))->lastgm) {
											try {
												std::ifstream ifff("save/guilds/_" + PlayerDB::getProperName(((PlayerInfo*)(peer->data))->guild) + ".json");
												if (ifff.fail()) {
													ifff.close();
													Player::OnConsoleMessage(peer, "`4Error: `oGuild does not exist! If you are seeing this message, please take a screenshot and send it to a developer!");
													continue;
												}
												if (ifff.is_open()) {
												}
												json j;
												ifff >> j;
												vector<string> gmlist;
												for (int i = 0; i < j["Member"].size(); i++) {
													gmlist.push_back(j["Member"][i]);
												}
												gmlist.erase(std::remove(gmlist.begin(), gmlist.end(), ((PlayerInfo*)(peer->data))->lastgm), gmlist.end());
												j["Member"] = gmlist;
												std::ofstream o("save/guilds/_" + PlayerDB::getProperName(((PlayerInfo*)(peer->data))->guild) + ".json"); //save
												if (!o.is_open()) continue;
												o << j << std::endl;
												((PlayerInfo*)(currentPeer->data))->guildBg = 0;
												((PlayerInfo*)(currentPeer->data))->guildFg = 0;
												((PlayerInfo*)(currentPeer->data))->guildLeader = "";
												((PlayerInfo*)(currentPeer->data))->guild = "";
												((PlayerInfo*)(currentPeer->data))->guildStatement = "";
												((PlayerInfo*)(currentPeer->data))->guildlast = "";
												((PlayerInfo*)(currentPeer->data))->lastgm = "";
												((PlayerInfo*)(currentPeer->data))->lastgmname = "";
												((PlayerInfo*)(currentPeer->data))->joinguild = false;
												((PlayerInfo*)(currentPeer->data))->lastgmworld = "";
												((PlayerInfo*)(currentPeer->data))->guildMembers.clear();
												updateInvis(currentPeer);
												updateInvis(peer);
												ifstream fg("save/players/_" + ((PlayerInfo*)(currentPeer->data))->rawName + ".json");
												json j2;
												fg >> j2;
												fg.close();
												j2["guild"] = "";
												j2["joinguild"] = false;
												ofstream fs("save/players/_" + ((PlayerInfo*)(currentPeer->data))->rawName + ".json");
												fs << j2;
												fs.close();
												outFromGuild(currentPeer);
												Player::OnConsoleMessage(currentPeer, "`5[GUILD ALERT] `oYou have been kicked from the guild by `2" + ((PlayerInfo*)(peer->data))->displayName + "`o.");
											}
											catch (std::exception&) {
												SendConsole("removegmonline Critical error details: rawName(" + ((PlayerInfo*)(currentPeer->data))->rawName + ")", "ERROR");
												enet_peer_disconnect_now(currentPeer, 0);
											}
											catch (std::runtime_error&) {
												SendConsole("removegmonline Critical error details: name(" + ((PlayerInfo*)(currentPeer->data))->rawName + ")", "ERROR");
												enet_peer_disconnect_now(currentPeer, 0);
											}
											catch (...) {
												SendConsole("removegmonline Critical error details: name(" + ((PlayerInfo*)(currentPeer->data))->rawName + ")", "ERROR");
												enet_peer_disconnect_now(currentPeer, 0);
											}
										}
										if (((PlayerInfo*)(currentPeer->data))->guild == ((PlayerInfo*)(peer->data))->guild) {
											Player::OnConsoleMessage(currentPeer, "`5[GUILD ALERT] `2" + ((PlayerInfo*)(peer->data))->lastgmname + "`o has been kicked from the guild!");
										}
									}
									Player::OnDialogRequest(peer, "set_default_color|`o\n\nadd_label_with_icon|big|`4Guild Member removed``|left|1366|\n\nadd_spacer|small|\nadd_textbox|`o" + ((PlayerInfo*)(peer->data))->lastgmname + " is no longer in the guild.``|\n\nadd_spacer|small|\nadd_button|guildportalbutton|`oOK``|0|0|\nadd_quick_exit|");
								}
								if (btn == "mutecursewarnlogs")
								{
									GTDialog allLog;
									string line;

									ifstream curselog("save/logs/curse.txt");
									allLog.addLabelWithIcon("`wCurse logs", 1434, LABEL_SMALL);
									allLog.addSpacer(SPACER_SMALL);
									while (getline(curselog, line))
									{
										allLog.addSmallText(line);
									}
									curselog.close();
									allLog.addSpacer(SPACER_SMALL);

									ifstream mutelog("save/logs/mute.txt");
									allLog.addLabelWithIcon("`wMute logs", 1434, LABEL_SMALL);
									allLog.addSpacer(SPACER_SMALL);
									while (getline(mutelog, line))
									{
										allLog.addSmallText(line);
									}
									mutelog.close();
									allLog.addSpacer(SPACER_SMALL);

									ifstream warnlog("save/logs/warns.txt");
									allLog.addLabelWithIcon("`wWarn logs", 1434, LABEL_SMALL);
									allLog.addSpacer(SPACER_SMALL);
									while (getline(warnlog, line))
									{
										allLog.addSmallText(line);
									}
									warnlog.close();
									allLog.addSpacer(SPACER_SMALL);

									ifstream uncurselog("save/logs/uncurse.txt");
									allLog.addLabelWithIcon("`wUn-Curse logs", 1434, LABEL_SMALL);
									allLog.addSpacer(SPACER_SMALL);
									while (getline(uncurselog, line))
									{
										allLog.addSmallText(line);
									}
									uncurselog.close();
									allLog.addSpacer(SPACER_SMALL);

									ifstream unmuteLog("save/logs/unmute.txt");
									allLog.addLabelWithIcon("`wUn-Mute logs", 1434, LABEL_SMALL);
									allLog.addSpacer(SPACER_SMALL);
									while (getline(unmuteLog, line))
									{
										allLog.addSmallText(line);
									}
									unmuteLog.close();
									allLog.addSpacer(SPACER_SMALL);

									allLog.addSpacer(SPACER_SMALL);
									allLog.addQuickExit();
									allLog.endDialog("Close", "", "Close it");
									Player::OnDialogRequest(peer, allLog.finishDialog());
								}
								if (btn == "wrenchlogs")
								{
									GTDialog allLog;
									string line;

									ifstream wrench2week("save/logs/wrench/panelban.txt");
									allLog.addLabelWithIcon("`wBan Panel logs", 1434, LABEL_SMALL);
									allLog.addSpacer(SPACER_SMALL);
									while (getline(wrench2week, line))
									{
										allLog.addSmallText(line);
									}
									wrench2week.close();
									allLog.addSpacer(SPACER_SMALL);	

									ifstream wrenchipban("save/logs/wrench/ipban.txt");
									allLog.addLabelWithIcon("`wWrench ip-ban logs", 1434, LABEL_SMALL);
									allLog.addSpacer(SPACER_SMALL);
									while (getline(wrenchipban, line))
									{
										allLog.addSmallText(line);
									}
									wrenchipban.close();

									allLog.addSpacer(SPACER_SMALL);
									allLog.addQuickExit();
									allLog.endDialog("Close", "", "Close it");
									Player::OnDialogRequest(peer, allLog.finishDialog());
								}
								if (btn == "worldlogs")
								{
									GTDialog allLog;
									string line;

									allLog.addSpacer(SPACER_SMALL);

									ifstream nukeLog("save/logs/nuke.txt");
									allLog.addLabelWithIcon("`wNuke logs", 1434, LABEL_SMALL);
									allLog.addSpacer(SPACER_SMALL);
									while (getline(nukeLog, line))
									{
										allLog.addSmallText(line);
									}
									nukeLog.close();
									allLog.addSpacer(SPACER_SMALL);

									ifstream unnukeLog("save/logs/unnuke.txt");
									allLog.addLabelWithIcon("`wUn-Nuke logs", 1434, LABEL_SMALL);
									allLog.addSpacer(SPACER_SMALL);
									while (getline(unnukeLog, line))
									{
										allLog.addSmallText(line);
									}
									unnukeLog.close();

									allLog.addSpacer(SPACER_SMALL);
									allLog.addQuickExit();
									allLog.endDialog("Close", "", "Close it");
									Player::OnDialogRequest(peer, allLog.finishDialog());
								}
								if (btn == "otherlogs")
								{
									GTDialog allLog;
									string line;

									ifstream giveranklog("save/logs/giverank.txt");
									allLog.addLabelWithIcon("`wGive rank logs", 1434, LABEL_SMALL);
									allLog.addSpacer(SPACER_SMALL);
									while (getline(giveranklog, line))
									{
										allLog.addSmallText(line);
									}
									giveranklog.close();
									allLog.addSpacer(SPACER_SMALL);

									ifstream givelevellog("save/logs/givelevel.txt");
									allLog.addLabelWithIcon("`wGive level logs", 1434, LABEL_SMALL);
									allLog.addSpacer(SPACER_SMALL);
									while (getline(givelevellog, line))
									{
										allLog.addSmallText(line);
									}
									givelevellog.close();
									allLog.addSpacer(SPACER_SMALL);

									ifstream itemlog("save/logs/item.txt");
									allLog.addLabelWithIcon("`w/item logs", 1434, LABEL_SMALL);
									allLog.addSpacer(SPACER_SMALL);
									while (getline(itemlog, line))
									{
										allLog.addSmallText(line);
									}
									itemlog.close();
									allLog.addSpacer(SPACER_SMALL);



									ifstream removeinventoryitemlog("save/logs/removelock.txt");
									allLog.addLabelWithIcon("`wBreak world logs", 1434, LABEL_SMALL);
									allLog.addSpacer(SPACER_SMALL);
									while (getline(removeinventoryitemlog, line))
									{
										allLog.addSmallText(line);
									}
									removeinventoryitemlog.close();
									allLog.addSpacer(SPACER_SMALL);

									allLog.addSpacer(SPACER_SMALL);
									allLog.addQuickExit();
									allLog.endDialog("Close", "", "Close it");
									Player::OnDialogRequest(peer, allLog.finishDialog());
								}
								if (btn == "rules") {
									Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wHelp & Rules``|left|18|\nadd_spacer|small|\nadd_textbox|`wTo keep this place fun we've got some ground rules to check out:``|left|\nadd_spacer|small|\nadd_label_with_icon|small|`wKeep your password secret. Sharing your password will result in stolen items.``|left|24|\nadd_label_with_icon|small|`wUnprotected items are at risk of being stolen. Use doors, locks, and blocks wisely to protect your items.``|left|24|\nadd_label_with_icon|small|`wWe cannot return stolen items, so BE CAREFUL!``|left|24|\nadd_label_with_icon|small|`wBe civil. Bullying, racism, excessive profanity, sexual content, and abusive behavior are not allowed.``|left|24|\nadd_label_with_icon|small|`wPlayers that are harmful to the community may be banned. This includes accounts that use lies, fake games, or trickery to mistreat other players.``|left|24|\nadd_label_with_icon|small|`wPunishments may be applied to alt accounts as well as any devices and IP addresses used by the offender.``|left|24|\nadd_label_with_icon|small|`wTrying to get punished or asking for a punishment can earn you a worse punishment.``|left|24|\nadd_label_with_icon|small|`w'Hacking' the game - including client-side manipulation, auto-clickers, speed hacks, clock manipulation, bots, macroing, and autofarming - will result in a ban.``|left|24|\nadd_label_with_icon|small|`wDon't sell " + server_name + "'s item's or gem's for original growtopia wl. if you caught by an owner you will a worse punishment.``|left|24|\nadd_label_with_icon|small|`wDon't ban or mute or curse people without an obvius reason. breaking this rules will get you a worse punishment.``|left|24|\nadd_label_with_icon|small|`wDon't lie about mods or fake official Growtopia system messages.``|left|24|\nadd_label_with_icon|small|`w'Drop games' are illegal scams. You can be punished for hosting, playing, advertising or even watching.``|left|24|\nadd_label_with_icon|small|`wBetting or gambling (asking players to pay for a chance to win something) is not allowed.``|left|24|\nadd_label_with_icon|small|`wIf you find a world or player name that is in violation of our rules, message a @Mod. Do not /bc or /sb from an inappropriate world.``|left|24|\nadd_label_with_icon|small|`w@Moderators are here to enforce the rules. Abusing, spamming or harassing mods will have consequences.``|left|24|\nadd_label_with_icon|small|`wAccounts, locks, or worlds may be deleted after long periods of inactivity.``|left|24|\nadd_label_with_icon|small|`wOut of game buying/selling of Growtopia accounts, items or worlds is not allowed and may result in a ban.``|left|24|\nadd_label_with_icon|small|`wIAP fraud will result in permanent suspension.``|left|24|\nadd_label_with_icon|small|`wItem function and prices are subject to change without warning.``|left|24|\nadd_label_with_icon|small|`wYour creations and items could be deleted at any time. We do everything in our power to prevent this, but data loss may happen without warning. Lost items cannot be restored.``|left|24|\nadd_spacer|small|\nadd_label_with_icon|small|`wFor technical support, IAP issues, or to report a problem, please email " + server_email + "``|left|24|\nadd_label|with|icon|small|`wThis Rules Isn't applicable for Server-Developer.``|left|24|\nadd_spacer|small|\nend_dialog|popup||Continue|");
								}
								if (btn == "view_guide") {
									GTDialog guide;
									guide.addLabelWithIcon("`9" + server_name + " Guide", 6336, LABEL_BIG);
									guide.addTextBox("Here you can find information about " + server_name + " items and custom recipes, note this guide might contain some missing information!");
									guide.addSpacer(SPACER_SMALL);
									guide.addLabelWithIcon("`9Chemical Combiner Recipes:", 952, LABEL_BIG);
									guide.addSpacer(SPACER_SMALL);
									string dialog = "";
									try {
										ifstream infile("binary.txt");
										for (string line; getline(infile, line);) {
											if (line.length() > 3 && line.at(0) != '/' && line.at(1) != '/') {
												auto ex = explode("|", line);
												dialog += "add_label_with_icon|small|`o" + ex.at(3) + " " + getItemDef(atoi(ex.at(0).c_str())).name + " + " + ex.at(4) + " " + getItemDef(atoi(ex.at(1).c_str())).name + " + " + ex.at(5) + " " + getItemDef(atoi(ex.at(2).c_str())).name + "|left|" + ex.at(6) + "|\n";
											}
										}
										infile.close();
										guide.addCustom(dialog);
										/*guide.addSpacer(SPACER_SMALL);
										guide.addLabelWithIcon("`9Custom Seed Recipes:", 2, LABEL_BIG);
										guide.addSpacer(SPACER_SMALL);
										dialog = "";
										ifstream infile3("recipes.txt");
										for (string line; getline(infile3, line);) {
											if (line.length() > 3 && line.at(0) != '/' && line.at(1) != '/') {
												auto ex = explode("|", line);
												dialog += "add_label_with_icon|small|`o" + getItemDef(atoi(ex.at(0).c_str())).name + " + " + getItemDef(atoi(ex.at(1).c_str())).name + "|left|" + to_string(atoi(ex.at(2).c_str()) - 1) + "|\n";
											}
										}
										infile3.close();
										guide.addCustom(dialog);*/
										guide.addSpacer(SPACER_SMALL);
										guide.addQuickExit();
										guide.addButton("Close", "Close");
										Player::OnDialogRequest(peer, guide.finishDialog());
									}
									catch (const std::out_of_range& e) {
										std::cout << e.what() << std::endl;
									}
								}
								if (btn == "getKey") {
									if (isWorldOwner(peer, world) || isDev(peer)) {
										try {
											auto iscontains = false;
											SearchInventoryItem(peer, 1424, 1, iscontains);
											if (!iscontains) {
												if (world->droppedCount > 0) {
													bool found = false;
													for (int i = 0; i < world->droppedItems.size(); i++) {
														int x_p = world->droppedItems.at(i).x / 32;
														int y_p = world->droppedItems.at(i).y / 32;
														if (world->items.at(x_p + (y_p * world->width)).foreground == 0) {
															found = true;
															break;
														}
													}
													if (found) {
														Player::OnTalkBubble(peer, pData->netID, "`4Oops!... Can't trade a world with floating items that are unblocked or in treasure chests!``", 0, false);
														continue;
													}
												}
												Player::OnTalkBubble(peer, pData->netID, "You got a `#World Key``! You can now trade this world to other players.", 0, false);
												Player::PlayAudio(peer, "audio/use_lock.wav", 0);
												bool success = true;
												SaveItemMoreTimes(1424, 1, peer, success);
											}
										} catch(const std::out_of_range& e) {
											std::cout << e.what() << std::endl;
										}
									}
								}
								if (btn == "trade") {
									if (static_cast<PlayerInfo*>(peer->data)->isCursed == true) {
										Player::OnConsoleMessage(peer, "`4You are cursed now!");
										continue;
									}
									string trade_name = pData->lastInfo;
									if (trade_name.size() < 3) {
										Player::OnConsoleMessage(peer, "You'll need to enter at least the first three characters of the person's name.");
										continue;
									}
									bool Found = false, Block = false;
									int Same_name = 0, Sub_worlds_name = 0;
									string Intel_sense_nick = "";
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
										if (isHere(peer, currentPeer)) {
											if (getStrLower(static_cast<PlayerInfo*>(currentPeer->data)->displayName).find(getStrLower(trade_name)) != string::npos) Same_name++;
										}
										else if (isMod(peer)) {
											if (getStrLower(static_cast<PlayerInfo*>(currentPeer->data)->displayName).find(getStrLower(trade_name)) != string::npos) Sub_worlds_name++;
										}
									}
									if (Same_name > 1) {
										Player::OnConsoleMessage(peer, "`oThere are more than two players in this world starting with " + trade_name + " `obe more specific!");
										continue;
									}
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
										if (isHere(peer, currentPeer) && getStrLower(static_cast<PlayerInfo*>(currentPeer->data)->displayName).find(getStrLower(trade_name)) != string::npos) {
											if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == static_cast<PlayerInfo*>(peer->data)->rawName) {
												Player::OnConsoleMessage(peer, "`oYou trade all your stuff to yourself in exchange for all your stuff.");
												Block = true;
												break;
											}
											Block = true;
											Found = true;
											Intel_sense_nick = static_cast<PlayerInfo*>(currentPeer->data)->displayName;
											if (static_cast<PlayerInfo*>(currentPeer->data)->trade) {
												Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wThat person is busy.", 0, false);
												break;
											}
											static_cast<PlayerInfo*>(peer->data)->trade = false;
											static_cast<PlayerInfo*>(peer->data)->trade_netid = static_cast<PlayerInfo*>(currentPeer->data)->netID;
											Player::OnStartTrade(peer, static_cast<PlayerInfo*>(currentPeer->data)->displayName, static_cast<PlayerInfo*>(currentPeer->data)->netID);
											break;
										}
									}
									if (Block) continue;
									if (!Found) {
										Player::OnConsoleMessage(peer, "`4Oops:`` There is nobody currently in this world with a name starting with `w" + trade_name + "``.");
									}
								}
								if (btn == "rift_cape_edit") {
									string aura_on = "0", portal_aura1 = "0", starfield_aura1 = "0", electrical_aura1 = "0", portal_aura2 = "0", starfield_aura2 = "0", electrical_aura2 = "0";
									switch (pData->rift_type) { /*1style*/
										case 2555: /*portal*/
										{
											portal_aura1 = "1";
											aura_on = "1";
											break;
										}
										case 2811: /*starfield*/
										{
											starfield_aura1 = "1";
											aura_on = "1";
											break;
										}
										case 3067: /*electrical*/
										{
											electrical_aura1 = "1";
											aura_on = "1";
											break;
										}
										default:
										{
											break;
										}
									}
									Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wRift Cape``|left|10424|\nadd_spacer|small|\nadd_text_input|text_input_time_cycle|Time Dilation Cycle Time:|30|5|\nadd_checkbox|checkbox_time_cycle|Time Dilation On / Off|0\nadd_button|button_manual|Instructions|noflags|0|0|\nadd_spacer|small|\nadd_label|big|Cape Style 1|left\nadd_spacer|small|\nadd_label|small|Cape Color:|left\nadd_text_input|text_input_cape_color0|Cape - R,G,B:|" + to_string(pData->rift_cape_r) + "," + to_string(pData->rift_cape_g) + "," + to_string(pData->rift_cape_b) + "|11|\nadd_spacer|small|\nadd_checkbox|checkbox_cape_collar0|Cape Collar On / Off|1\nadd_label|small|Cape Collar Color:|left\nadd_text_input|text_input_collar_color0|Collar - R,G,B:|" + to_string(pData->rift_collar_r) + "," + to_string(pData->rift_collar_g) + "," + to_string(pData->rift_collar_b) + "|11|\nadd_spacer|small|\nadd_checkbox|checkbox_closed_cape0|Closed Cape|0\nadd_checkbox|checkbox_open_on_move0|Open Cape on Movement|1\nadd_checkbox|checkbox_aura0|Aura On / Off|" + aura_on + "\nadd_checkbox|checkbox_aura_1st0|      Portal Aura|" + portal_aura1 + "\nadd_checkbox|checkbox_aura_2nd0|      Starfield Aura|" + starfield_aura1 + "\nadd_checkbox|checkbox_aura_3rd0|      Electrical Aura|" + electrical_aura1 + "\nadd_label|big|Cape Style 2|left\nadd_spacer|small|\nadd_label|small|Cape Color:|left\nadd_text_input|text_input_cape_color1|Cape - R,G,B:|137,30,43|11|\nadd_spacer|small|\nadd_checkbox|checkbox_cape_collar1|Cape Collar On / Off|1\nadd_label|small|Cape Collar Color:|left\nadd_text_input|text_input_collar_color1|Collar - R,G,B:|34,35,63|11|\nadd_spacer|small|\nadd_checkbox|checkbox_closed_cape1|Closed Cape|1\nadd_checkbox|checkbox_open_on_move1|Open Cape on Movement|1\nadd_checkbox|checkbox_aura1|Aura On / Off|1\nadd_checkbox|checkbox_aura_1st1|      Portal Aura|" + portal_aura2 + "\nadd_checkbox|checkbox_aura_2nd1|      Starfield Aura|" + starfield_aura2 + "\nadd_checkbox|checkbox_aura_3rd1|      Electrical Aura|" + electrical_aura2 + "\nadd_spacer|small|\nadd_button|restore_default|Restore to Default|noflags|0|0|\nend_dialog|dialog_rift_cape|Cancel|Update|\nadd_quick_exit|");
								}
								if (btn == "goals") {
									int firefighterxp = 1500;
									if (pData->firefighterlevel > 0) firefighterxp = firefighterxp * pData->firefighterlevel;
									if (pData->firefighterlevel == 0) firefighterxp = 750;
									int providerxp = 1300;
									if (pData->providerlevel > 0) providerxp = providerxp * pData->providerlevel;
									if (pData->providerlevel == 0) providerxp = 600;
									int geigerxp = 600;
									if (pData->geigerlevel > 0) geigerxp = geigerxp * pData->geigerlevel;
									if (pData->geigerlevel == 0) geigerxp = 350;
									int fishermanxp = 1600;
									if (pData->fishermanlevel > 0) fishermanxp = fishermanxp * pData->fishermanlevel;
									if (pData->fishermanlevel == 0) fishermanxp = 900;
									Player::OnDialogRequest(peer, "add_label_with_icon|big|`wRole Stats``|left|982|\nadd_spacer|small|\nadd_textbox|`9What prizes and powers have you unlocked in your Roles and what's left to discover? Find out here!``|left|\nadd_spacer|small|\nadd_player_info|Firefighter|" + to_string(pData->firefighterlevel) + "|" + to_string(pData->firefighterxp) + "|" + to_string(firefighterxp) + "|\nadd_spacer|small|\nadd_button|viewFirefighter|`0View Firefighter Rewards``|noflags|0|0|\nadd_spacer|small|\nadd_player_info|Provider|" + to_string(pData->providerlevel) + "|" + to_string(pData->providerxp) + "|" + to_string(providerxp) + "|\nadd_spacer|small|\nadd_button|viewProvider|`0View Provider Rewards``|noflags|0|0|\nadd_spacer|small|\nadd_player_info|Geiger Hunter|" + to_string(pData->geigerlevel) + "|" + to_string(pData->geigerxp) + "|" + to_string(geigerxp) + "|\nadd_spacer|small|\nadd_button|viewGeiger|`0View Geiger Hunter Rewards``|noflags|0|0|\nadd_spacer|small|\nadd_player_info|Fisherman|" + to_string(pData->fishermanlevel) + "|" + to_string(pData->fishermanxp) + "|" + to_string(fishermanxp) + "|\nadd_spacer|small|\nadd_button|viewFisherman|`0View Fisherman Rewards``|noflags|0|0|\nadd_spacer|small|\nadd_button|back|Back|noflags|0|0|\nend_dialog|mainwrenchpage|||\nadd_quick_exit|");
								}
								if (btn == "viewFisherman") {
									string level1 = "", level2 = "", level3 = "", level4 = "", level5 = "", level6 = "", level7 = "", level8 = "", level9 = "", level10 = "";
									if (pData->fishermanlevel >= 1) {
										level1 = "`oUnlocked: Licorice Rod``";
									} else {
										level1 = "`a(Locked) Licorice Rod``";
									}
									if (pData->fishermanlevel >= 2) {
										level2 = "`oUnlocked: Quantum: 1% chances of getting items as a bonus drop from from fishing``";
									} else {
										level2 = "`a(Locked) Quantum: 1% chances of getting items as a bonus drop from from fishing``";
									}
									if (pData->fishermanlevel >= 3) {
										level3 = "`oUnlocked: Adds a chance to get Golden Block as a bonus drop from fishing``";
									} else {
										level3 = "`a(Locked) Adds a chance to get Golden Block as a bonus drop from fishing``";
									}
									if (pData->fishermanlevel >= 4) {
										level4 = "`oUnlocked: Floating Leaf``|left|3074|\nadd_label_with_icon|sml|`oUnlocked: Quantum (level 2) - Chance increase to 2%``";
									} else {
										level4 = "`a(Locked) Floating Leaf``|left|3074|\nadd_label_with_icon|sml|`a(Locked) Quantum (level 2) - Chance increase to 2%``";
									}
									if (pData->fishermanlevel >= 5) {
										level5 = "`oUnlocked: Magical Rainbow Fishing Rod``";
									} else {
										level5 = "`a(Locked) Magical Rainbow Fishing Rod``";
									}
									if (pData->fishermanlevel >= 6) {
										level6 = "`oUnlocked: Quantum (level 3) - Chance increase to 3%``";
									} else {
										level6 = "`a(Locked) Quantum (level 3) - Chance increase to 3%``";
									}
									if (pData->fishermanlevel >= 7) {
										level7 = "`oUnlocked: Bubble Wings``";
									} else {
										level7 = "`a(Locked) Bubble Wings``";
									}
									if (pData->fishermanlevel >= 8) {
										level8 = "`oUnlocked: Quantum (level 4) - Chance increase to 4%``|left|7002|\nadd_label_with_icon|sml|`oUnlocked: Cursed Fishing Rod``|left|3100|";
									} else {
										level8 = "`a(Locked) Quantum (level 4) - Chance increase to 4%``|left|7002|\nadd_label_with_icon|sml|`a(Locked) Cursed Fishing Rod``|left|3100|";
									}
									if (pData->fishermanlevel >= 9) {
										level9 = "`oUnlocked: Ancestral Tesseract of Dimensions``";
									} else {
										level9 = "`a(Locked) Ancestral Tesseract of Dimensions``";
									}
									if (pData->fishermanlevel >= 10) {
										level10 = "`oUnlocked: Adds a chance to get double gems from fishing``|left|112|\nadd_label_with_icon|sml|`oUnlocked: Quantum (level 5) - Chance increase to 5%``|left|7002|\nadd_label_with_icon|sml|`oUnlocked: Goldenrod``";
									} else {
										level10 = "`a(Locked) Adds a chance to get double gems from fishing``|left|112|\nadd_label_with_icon|sml|`a(Locked) Quantum (level 5) - Chance increase to 5%``|left|7002|\nadd_label_with_icon|sml|`a(Locked) Goldenrod``";
									}
									Player::OnDialogRequest(peer, "add_label_with_icon|big|`wFisherman Rewards``|left|10262|\nadd_spacer|small|\nadd_textbox|`9Here are all the Fisherman rewards that you have earned so far!``|left|\nadd_spacer|small|\nadd_spacer|small|\nadd_smalltext|Level 1 rewards:|left|\nadd_label_with_icon|sml|" + level1 + "|left|3010|\nadd_spacer|small|\nadd_smalltext|Level 2 rewards:|left|\nadd_label_with_icon|sml|" + level2 + "|left|7002|\nadd_spacer|small|\nadd_smalltext|Level 3 rewards:|left|\nadd_label_with_icon|sml|" + level3 + "|left|260|\nadd_spacer|small|\nadd_smalltext|Level 4 rewards:|left|\nadd_label_with_icon|sml|" + level4 + "|left|7002|\nadd_spacer|small|\nadd_smalltext|Level 5 rewards:|left|\nadd_label_with_icon|sml|" + level5 + "|left|5740|\nadd_spacer|small|\nadd_smalltext|Level 6 rewards:|left|\nadd_label_with_icon|sml|" + level6 + "|left|7002|\nadd_spacer|small|\nadd_smalltext|Level 7 rewards:|left|\nadd_label_with_icon|sml|" + level7 + "|left|1550|\nadd_spacer|small|\nadd_smalltext|Level 8 rewards:|left|\nadd_label_with_icon|sml|" + level8 + "|left|10424|\nadd_spacer|small|\nadd_smalltext|Level 9 rewards:|left|\nadd_label_with_icon|sml|" + level9 + "|left|5080|\nadd_spacer|small|\nadd_smalltext|Level 10 rewards:|left|\nadd_label_with_icon|sml|" + level10 + "|left|3040|\nadd_spacer|small|\nadd_button|back|Back|noflags|0|0|\nend_dialog|roleRewardsPage|||\nadd_quick_exit|");
								}
								if (btn == "viewGeiger") {
									string level1 = "", level2 = "", level3 = "", level4 = "", level5 = "", level6 = "", level7 = "", level8 = "", level9 = "", level10 = "";
									if (pData->geigerlevel >= 1) {
										level1 = "`oUnlocked: Uranium Necklace``";
									} else {
										level1 = "`a(Locked) Uranium Necklace``";
									}
									if (pData->geigerlevel >= 2) {
										level2 = "`oUnlocked: Infusion: 1% chances of not gaining irradiated mod``";
									} else {
										level2 = "`a(Locked) Infusion: 1% chances of not gaining irradiated mod``";
									}
									if (pData->geigerlevel >= 3) {
										level3 = "`oUnlocked: Adds a chance to get Uranium Block as a bonus drop from geiger hunting``";
									} else {
										level3 = "`a(Locked) Adds a chance to get Uranium Block as a bonus drop from geiger hunting``";
									}
									if (pData->geigerlevel >= 4) {
										level4 = "`oUnlocked: Weil Magic: 1% chances of gaining extra bonus drop from geiger hunting``|left|3764|\nadd_label_with_icon|sml|`oUnlocked: Infusion (level 2) - Chance increase to 2%``";
									} else {
										level4 = "`a(Locked) Weil Magic: 1% chances of gaining extra bonus drop from geiger hunting``|left|3764|\nadd_label_with_icon|sml|`a(Locked) Infusion (level 2) - Chance increase to 2%``";
									}
									if (pData->geigerlevel >= 5) {
										level5 = "`oUnlocked: Adds a chance to get Electrical Power Cube as a bonus drop from geiger hunting``";
									} else {
										level5 = "`a(Locked) Adds a chance to get Electrical Power Cube as a bonus drop from geiger hunting``";
									}
									if (pData->geigerlevel >= 6) {
										level6 = "`oUnlocked: Infusion (level 3) - Chance increase to 3%``";
									} else {
										level6 = "`a(Locked) Infusion (level 3) - Chance increase to 3%``";
									}
									if (pData->geigerlevel >= 7) {
										level7 = "`oUnlocked: Unlocked: Weil Magic (level 2) - Chance increase to 2%``";
									} else {
										level7 = "`a(Locked) Unlocked: Weil Magic (level 2) - Chance increase to 2%``";
									}
									if (pData->geigerlevel >= 8) {
										level8 = "`oUnlocked: Infusion (level 4) - Chance increase to 4%``|left|9386|\nadd_label_with_icon|sml|`oUnlocked: Rift Cape``|left|10424|";
									} else {
										level8 = "`a(Locked) Infusion (level 4) - Chance increase to 4%``|left|9386|\nadd_label_with_icon|sml|`a(Locked) Rift Cape``|left|10424|";
									}
									if (pData->geigerlevel >= 9) {
										level9 = "`oUnlocked: Ancestral Lens of Riches``";
									} else {
										level9 = "`a(Locked) Ancestral Lens of Riches``";
									}
									if (pData->geigerlevel >= 10) {
										level10 = "`oUnlocked: Adds a chance to get Growtoken as a bonus drop from geiger hunting``|left|1486|\nadd_label_with_icon|sml|`oUnlocked: Infusion (level 5) - Chance increase to 5%``|left|9386|\nadd_label_with_icon|sml|`oUnlocked: Unique Prize``";
									} else {
										level10 = "`a(Locked) Adds a chance to get Growtoken as a bonus drop from geiger hunting``|left|1486|\nadd_label_with_icon|sml|`a(Locked) Infusion (level 5) - Chance increase to 5%``|left|9386|\nadd_label_with_icon|sml|`a(Locked) Unique Prize``";
									}
									Player::OnDialogRequest(peer, "add_label_with_icon|big|`wGeiger Hunter Rewards``|left|2204|\nadd_spacer|small|\nadd_textbox|`9Here are all the Geiger Hunter rewards that you have earned so far!``|left|\nadd_spacer|small|\nadd_spacer|small|\nadd_smalltext|Level 1 rewards:|left|\nadd_label_with_icon|sml|" + level1 + "|left|4656|\nadd_spacer|small|\nadd_smalltext|Level 2 rewards:|left|\nadd_label_with_icon|sml|" + level2 + "|left|9386|\nadd_spacer|small|\nadd_smalltext|Level 3 rewards:|left|\nadd_label_with_icon|sml|" + level3 + "|left|4658|\nadd_spacer|small|\nadd_smalltext|Level 4 rewards:|left|\nadd_label_with_icon|sml|" + level4 + "|left|9386|\nadd_spacer|small|\nadd_smalltext|Level 5 rewards:|left|\nadd_label_with_icon|sml|" + level5 + "|left|6976|\nadd_spacer|small|\nadd_smalltext|Level 6 rewards:|left|\nadd_label_with_icon|sml|" + level6 + "|left|9386|\nadd_spacer|small|\nadd_smalltext|Level 7 rewards:|left|\nadd_label_with_icon|sml|" + level7 + "|left|3764|\nadd_spacer|small|\nadd_smalltext|Level 8 rewards:|left|\nadd_label_with_icon|sml|" + level8 + "|left|10424|\nadd_spacer|small|\nadd_smalltext|Level 9 rewards:|left|\nadd_label_with_icon|sml|" + level9 + "|left|5084|\nadd_spacer|small|\nadd_smalltext|Level 10 rewards:|left|\nadd_label_with_icon|sml|" + level10 + "|left|2478|\nadd_spacer|small|\nadd_button|back|Back|noflags|0|0|\nend_dialog|roleRewardsPage|||\nadd_quick_exit|");
								}
								if (btn == "viewProvider") {
									string level1 = "", level2 = "", level3 = "", level4 = "", level5 = "", level6 = "", level7 = "", level8 = "", level9 = "", level10 = "";
									if (pData->providerlevel >= 1) {
										level1 = "`oUnlocked: Awkward Friendly Unicorn``";
									} else {
										level1 = "`a(Locked) Awkward Friendly Unicorn``";
									}
									if (pData->providerlevel >= 2) {
										level2 = "`oUnlocked: Weed Magic: 1% chances of providers dropping double items``";
									} else {
										level2 = "`a(Locked) Weed Magic: 1% chances of providers dropping double items``";
									}
									if (pData->providerlevel >= 3) {
										level3 = "`oUnlocked: 3 Growtokens``";
									} else {
										level3 = "`a(Locked) 3 Growtokens``";
									}
									if (pData->providerlevel >= 4) {
										level4 = "`oUnlocked: Adds a chance to get Smaraged Block as a bonus drop from harvesting providers``|left|5136|\nadd_label_with_icon|sml|`oUnlocked: Weed Magic (level 2) - Chance increase to 2%``";
									} else {
										level4 = "`a(Locked) Adds a chance to get Smaraged Block as a bonus drop from harvesting providers``|left|5136|\nadd_label_with_icon|sml|`a(Locked) Weed Magic (level 2) - Chance increase to 2%``";
									}
									if (pData->providerlevel >= 5) {
										level5 = "`oUnlocked: Ancestral Seed of Life``";
									} else {
										level5 = "`a(Locked) Ancestral Seed of Life``";
									}
									if (pData->providerlevel >= 6) {
										level6 = "`oUnlocked: Weed Magic (level 3) - Chance increase to 3%``";
									} else {
										level6 = "`a(Locked) Weed Magic (level 3) - Chance increase to 3%``";
									}
									if (pData->providerlevel >= 7) {
										level7 = "`oUnlocked: Adds a chance to get Emerald Shard as a bonus drop from harvesting providers``";
									} else {
										level7 = "`a(Locked) Adds a chance to get Emerald Shard as a bonus drop from harvesting providers``";
									}
									if (pData->providerlevel >= 8) {
										level8 = "`oUnlocked: 30-Day Premium Subscription Token``|left|6860|\nadd_label_with_icon|sml|`oUnlocked: Weed Magic (level 4) - Chance increase to 4%``";
									} else {
										level8 = "`a(Locked) 30-Day Premium Subscription Token``|left|6860|\nadd_label_with_icon|sml|`a(Locked) Weed Magic (level 4) - Chance increase to 4%``";
									}
									if (pData->providerlevel >= 9) {
										level9 = "`oUnlocked: 10 Growtokens``";
									} else {
										level9 = "`a(Locked) 10 Growtokens``";
									}
									if (pData->providerlevel >= 10) {
										level10 = "`oUnlocked: Adds a chance for providers to drop themself without losing one``|left|10072|\nadd_label_with_icon|sml|`oUnlocked: Weed Magic (level 5) - Chance increase to 5%``|left|954|\nadd_label_with_icon|sml|`oUnlocked: Unique Prize``";
									} else {
										level10 = "`a(Locked) Adds a chance for providers to drop themself without losing one``|left|10072|\nadd_label_with_icon|sml|`a(Locked) Weed Magic (level 5) - Chance increase to 5%``|left|954|\nadd_label_with_icon|sml|`a(Locked) Unique Prize``";
									}
									Player::OnDialogRequest(peer, "add_label_with_icon|big|`wProvider Rewards``|left|872|\nadd_spacer|small|\nadd_textbox|`9Here are all the Provider rewards that you have earned so far!``|left|\nadd_spacer|small|\nadd_spacer|small|\nadd_smalltext|Level 1 rewards:|left|\nadd_label_with_icon|sml|" + level1 + "|left|1636|\nadd_spacer|small|\nadd_smalltext|Level 2 rewards:|left|\nadd_label_with_icon|sml|" + level2 + "|left|954|\nadd_spacer|small|\nadd_smalltext|Level 3 rewards:|left|\nadd_label_with_icon|sml|" + level3 + "|left|1486|\nadd_spacer|small|\nadd_smalltext|Level 4 rewards:|left|\nadd_label_with_icon|sml|" + level4 + "|left|954|\nadd_spacer|small|\nadd_smalltext|Level 5 rewards:|left|\nadd_label_with_icon|sml|" + level5 + "|left|5082|\nadd_spacer|small|\nadd_smalltext|Level 6 rewards:|left|\nadd_label_with_icon|sml|" + level6 + "|left|954|\nadd_spacer|small|\nadd_smalltext|Level 7 rewards:|left|\nadd_label_with_icon|sml|" + level7 + "|left|2410|\nadd_spacer|small|\nadd_smalltext|Level 8 rewards:|left|\nadd_label_with_icon|sml|" + level8 + "|left|954|\nadd_spacer|small|\nadd_smalltext|Level 9 rewards:|left|\nadd_label_with_icon|sml|" + level9 + "|left|1486|\nadd_spacer|small|\nadd_smalltext|Level 10 rewards:|left|\nadd_label_with_icon|sml|" + level10 + "|left|2478|\nadd_spacer|small|\nadd_button|back|Back|noflags|0|0|\nend_dialog|roleRewardsPage|||\nadd_quick_exit|");
								}
								if (btn == "viewFirefighter") {
									string level1 = "", level2 = "", level3 = "", level4 = "", level5 = "", level6 = "", level7 = "", level8 = "", level9 = "", level10 = "";
									if (pData->firefighterlevel >= 1) {
										level1 = "`oUnlocked: Growtoken``";
									} else {
										level1 = "`a(Locked) Growtoken``";
									}
									if (pData->firefighterlevel >= 2) {
										level2 = "`oUnlocked: Fire King: 1% chances of receiving bonus gems when putting out fire``";
									} else {
										level2 = "`a(Locked) Fire King: 1% chances of receiving bonus gems when putting out fire``";
									}
									if (pData->firefighterlevel >= 3) {
										level3 = "`oUnlocked: Adds a chance to get Amethyst Block as a bonus drop from putting out fire``";
									} else {
										level3 = "`a(Locked) Adds a chance to get Amethyst Block as a bonus drop from putting out fire``";
									}
									if (pData->firefighterlevel >= 4) {
										level4 = "`oUnlocked: Adds a chance to get Fallen Pillar as a bonus drop from putting out fire``|left|7156|\nadd_label_with_icon|sml|`oUnlocked: Fire King (level 2) - Chance increase to 2%``";
									} else {
										level4 = "`a(Locked) Adds a chance to get Fallen Pillar as a bonus drop from putting out fire``|left|7156|\nadd_label_with_icon|sml|`a(Locked) Fire King (level 2) - Chance increase to 2%``";
									}
									if (pData->firefighterlevel >= 5) {
										level5 = "`oUnlocked: Burning Hands``";
									} else {
										level5 = "`a(Locked) Burning Hands``";
									}
									if (pData->firefighterlevel >= 6) {
										level6 = "`oUnlocked: Fire King (level 3) - Chance increase to 3%``";
									} else {
										level6 = "`a(Locked) Fire King (level 3) - Chance increase to 3%``";
									}
									if (pData->firefighterlevel >= 7) {
										level7 = "`oUnlocked: Adds a chance to get Diamond Stone as a bonus drop from putting out fire``";
									} else {
										level7 = "`a(Locked) Adds a chance to get Diamond Stone as a bonus drop from putting out fire``";
									}
									if (pData->firefighterlevel >= 8) {
										level8 = "`oUnlocked: 30-Day Premium Subscription Token``|left|6860|\nadd_label_with_icon|sml|`oUnlocked: Fire King (level 4) - Chance increase to 4%``";
									} else {
										level8 = "`a(Locked) 30-Day Premium Subscription Token``|left|6860|\nadd_label_with_icon|sml|`a(Locked) Fire King (level 4) - Chance increase to 4%``";
									}
									if (pData->firefighterlevel >= 9) {
										level9 = "`oUnlocked: 10 Growtokens``";
									} else {
										level9 = "`a(Locked) 10 Growtokens``";
									}
									if (pData->firefighterlevel >= 10) {
										level10 = "`oUnlocked: Adds a chance to get foreground block that was on fire as a bonus drop``|left|10072|\nadd_label_with_icon|sml|`oUnlocked: Fire King (level 5) - Chance increase to 5%``|left|3046|\nadd_label_with_icon|sml|`oUnlocked: Unique Prize``";
									} else {
										level10 = "`a(Locked) Adds a chance to get foreground block that was on fire as a bonus drop``|left|10072|\nadd_label_with_icon|sml|`a(Locked) Fire King (level 5) - Chance increase to 5%``|left|3046|\nadd_label_with_icon|sml|`a(Locked) Unique Prize``";
									}
									Player::OnDialogRequest(peer, "add_label_with_icon|big|`wFirefighter Rewards``|left|3046|\nadd_spacer|small|\nadd_textbox|`9Here are all the Firefighter rewards that you have earned so far!``|left|\nadd_spacer|small|\nadd_spacer|small|\nadd_smalltext|Level 1 rewards:|left|\nadd_label_with_icon|sml|" + level1 + "|left|1486|\nadd_spacer|small|\nadd_smalltext|Level 2 rewards:|left|\nadd_label_with_icon|sml|" + level2 + "|left|3046|\nadd_spacer|small|\nadd_smalltext|Level 3 rewards:|left|\nadd_label_with_icon|sml|" + level3 + "|left|4762|\nadd_spacer|small|\nadd_smalltext|Level 4 rewards:|left|\nadd_label_with_icon|sml|" + level4 + "|left|3046|\nadd_spacer|small|\nadd_smalltext|Level 5 rewards:|left|\nadd_label_with_icon|sml|" + level5 + "|left|4996|\nadd_spacer|small|\nadd_smalltext|Level 6 rewards:|left|\nadd_label_with_icon|sml|" + level6 + "|left|3046|\nadd_spacer|small|\nadd_smalltext|Level 7 rewards:|left|\nadd_label_with_icon|sml|" + level7 + "|left|5138|\nadd_spacer|small|\nadd_smalltext|Level 8 rewards:|left|\nadd_label_with_icon|sml|" + level8 + "|left|3046|\nadd_spacer|small|\nadd_smalltext|Level 9 rewards:|left|\nadd_label_with_icon|sml|" + level9 + "|left|1486|\nadd_spacer|small|\nadd_smalltext|Level 10 rewards:|left|\nadd_label_with_icon|sml|" + level10 + "|left|2478|\nadd_spacer|small|\nadd_button|back|Back|noflags|0|0|\nend_dialog|roleRewardsPage|||\nadd_quick_exit|");
								}
								if (btn == "pullstock")
								{
									if (world->owner != "" && !isWorldOwner(peer, world) && !isMod(peer)) continue;
									int xxx = pData->lastPunchX;
									int yyy = pData->lastPunchY;
									if (xxx < 0 && yyy < 0) continue;
									try {
										int withdrawcpy = world->items.at(xxx + (yyy * world->width)).vdraw;
										if (withdrawcpy != 0) {
											Player::OnTalkBubble(peer, pData->netID, "`wWithdraw the world locks first!", 0, true);
											continue;
										}
										int realid = world->items.at(xxx + (yyy * world->width)).vid;
										int countid = world->items.at(xxx + (yyy * world->width)).vcount;
										if (CheckItemMaxed(peer, realid, countid)) {
											Player::OnTalkBubble(peer, pData->netID, "`wYou can't carry any of those!", 0, true);
											Player::OnConsoleMessage(peer, "`oYou can't carry any of those!");
											continue;
										}
										if (countid > 200) {
											bool success = true;
											SaveItemMoreTimes(realid, 200, peer, success, pData->rawName + " collected from Vending Machine");
											world->items.at(xxx + (yyy * world->width)).vcount -= 200;
											Player::OnTalkBubble(peer, pData->netID, "`wYou picked up 200 " + getItemDef(realid).name + "`w, leaving " + to_string(world->items.at(xxx + (yyy * world->width)).vcount) + " in the machine.", 0, true);
											if (isMod(peer) && !isWorldOwner(peer, world)) LogAccountActivity(pData->rawName, pData->rawName, "Collected 200 " + getItemDef(realid).name + " from " + getItemDef(world->items.at(xxx + (yyy * world->width)).foreground).name + " (" + world->name + ")");
											Player::OnConsoleMessage(peer, "`oYou picked up 200 " + getItemDef(realid).name + "`o, leaving " + to_string(world->items.at(xxx + (yyy * world->width)).vcount) + " in the machine.");
											ENetPeer* currentPeer;
											for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
												if (isHere(peer, currentPeer)) {
													if (world->items.at(xxx + (yyy * world->width)).opened && world->items.at(xxx + (yyy * world->width)).vcount < world->items.at(xxx + (yyy * world->width)).vprice) {
														UpdateVend(currentPeer, xxx, yyy, 0, false, world->items.at(xxx + (yyy * world->width)).vprice, world->items.at(xxx + (yyy * world->width)).background, world->items.at(xxx + (yyy * world->width)).opened);
													}
													else UpdateVend(currentPeer, xxx, yyy, world->items.at(xxx + (yyy * world->width)).vid, false, world->items.at(xxx + (yyy * world->width)).vprice, world->items.at(xxx + (yyy * world->width)).background, world->items.at(xxx + (yyy * world->width)).opened);
												}
											}
										}
										else
										{
											world->items.at(xxx + (yyy * world->width)).vprice = 0;
											bool success = true;
											SaveItemMoreTimes(realid, countid, peer, success, pData->rawName + " collected from Vending Machine");
											world->items.at(xxx + (yyy * world->width)).vid = 0;
											world->items.at(xxx + (yyy * world->width)).vcount = 0;
											Player::OnTalkBubble(peer, pData->netID, "`wYou picked up " + to_string(countid) + " " + getItemDef(realid).name + "`w.", 0, true);
											if (isMod(peer) && !isWorldOwner(peer, world)) LogAccountActivity(pData->rawName, pData->rawName, "Collected " + to_string(countid) + " " + getItemDef(realid).name + " from " + getItemDef(world->items.at(xxx + (yyy * world->width)).foreground).name + " (" + world->name + ")");
											Player::OnConsoleMessage(peer, "`oYou picked up " + to_string(countid) + " " + getItemDef(realid).name + "`o.");
											ENetPeer* currentPeer;
											for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
												if (isHere(peer, currentPeer)) {
													if (world->items.at(xxx + (yyy * world->width)).opened && world->items.at(xxx + (yyy * world->width)).vcount < world->items.at(xxx + (yyy * world->width)).vprice) {
														UpdateVend(currentPeer, xxx, yyy, 0, false, world->items.at(xxx + (yyy * world->width)).vprice, world->items.at(xxx + (yyy * world->width)).background, world->items.at(xxx + (yyy * world->width)).opened);
													}
													else UpdateVend(currentPeer, xxx, yyy, 0, false, 0, world->items.at(xxx + (yyy * world->width)).background, world->items.at(xxx + (yyy * world->width)).opened);
												}
											}
										}
									}
									catch (const std::out_of_range& e) {
										std::cout << e.what() << std::endl;
									}
								}
								/*if (btn == "withdraw")
								{
									if (world->owner != "" && !isWorldOwner(peer, world)) continue;
									int xxx = pData->lastPunchX;
									int yyy = pData->lastPunchY;
									if (xxx < 0 && yyy < 0) continue;
									try {
										int withdrawcpy = world->items.at(xxx + (yyy * world->width)).vdraw;
										if (withdrawcpy != 0) {
											if (withdrawcpy <= 200) {
												if (CheckItemMaxed(peer, 242, withdrawcpy)) {
													Player::OnTalkBubble(peer, pData->netID, "`wI dont have free space to collect " + to_string(withdrawcpy) + " World Locks!", 0, true);
													continue;
												}
												world->items.at(xxx + (yyy * world->width)).vdraw = 0;
												int realid = world->items.at(xxx + (yyy * world->width)).vid;
												int priceid = world->items.at(xxx + (yyy * world->width)).vprice;
												bool success = true;
												SaveItemMoreTimes(242, withdrawcpy, peer, success, pData->rawName + " collected from Vending Machine");
												if (isMod(peer) && !isWorldOwner(peer, world)) LogAccountActivity(pData->rawName, pData->rawName, "Collected " + to_string(withdrawcpy) + " World Locks from " + getItemDef(world->items.at(xxx + (yyy * world->width)).foreground).name + " (" + world->name + ")");
												Player::OnTalkBubble(peer, pData->netID, "`wYou collected " + to_string(withdrawcpy) + " World Locks.", 0, true);
												if (world->items.at(xxx + (yyy * world->width)).vcount == 0) {
													priceid = 0;
													realid = 0;
												}
												ENetPeer* currentPeer;
												for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
													if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
													if (isHere(peer, currentPeer)) {
														if (world->items.at(xxx + (yyy * world->width)).opened && world->items.at(xxx + (yyy * world->width)).vcount < world->items.at(xxx + (yyy * world->width)).vprice) {
															UpdateVend(currentPeer, xxx, yyy, 0, false, priceid, world->items.at(xxx + (yyy * world->width)).background, world->items.at(xxx + (yyy * world->width)).opened);
														}
														else UpdateVend(currentPeer, xxx, yyy, realid, false, priceid, world->items.at(xxx + (yyy * world->width)).background, world->items.at(xxx + (yyy * world->width)).opened);
													}
												}
											}
											else if (withdrawcpy > 200)
											{
												if (CheckItemMaxed(peer, 242, 200))
												{
													Player::OnTalkBubble(peer, pData->netID, "`wI dont have free space to collect 200 World Locks!", 0, true);
													continue;
												}
												int grazinti = withdrawcpy - 200;
												world->items.at(xxx + (yyy * world->width)).vdraw = grazinti;
												int realid = world->items.at(xxx + (yyy * world->width)).vid;
												int priceid = world->items.at(xxx + (yyy * world->width)).vprice;
												bool success = true;
												SaveItemMoreTimes(242, 200, peer, success, pData->rawName + " collected from Vending Machine");
												if (isMod(peer) && !isWorldOwner(peer, world)) LogAccountActivity(pData->rawName, pData->rawName, "Collected 200 World Locks from " + getItemDef(world->items.at(xxx + (yyy * world->width)).foreground).name + " (" + world->name + ")");
												Player::OnTalkBubble(peer, pData->netID, "`wYou collected 200 World Locks, leaving " + to_string(grazinti) + " in the machine!", 0, true);
												if (world->items.at(xxx + (yyy * world->width)).vcount == 0) {
													priceid = 0;
													realid = 0;
												}
												ENetPeer* currentPeer;
												for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
													if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
													if (isHere(peer, currentPeer)) {
														if (world->items.at(xxx + (yyy * world->width)).opened && world->items.at(xxx + (yyy * world->width)).vcount < world->items.at(xxx + (yyy * world->width)).vprice) {
															UpdateVend(currentPeer, xxx, yyy, 0, true, priceid, world->items.at(xxx + (yyy * world->width)).background, world->items.at(xxx + (yyy * world->width)).opened);
														}
														else UpdateVend(currentPeer, xxx, yyy, realid, true, priceid, world->items.at(xxx + (yyy * world->width)).background, world->items.at(xxx + (yyy * world->width)).opened);
													}
												}
											}
											else {
												Player::OnTalkBubble(peer, pData->netID, "`wHuh?", 0, true);
											}
										}
									}
									catch (const std::out_of_range& e) {
										std::cout << e.what() << std::endl;
									}
								}*/
								if (btn == "withdraw") {
									int xxx = ((PlayerInfo*)(peer->data))->lastPunchX;
									int yyy = ((PlayerInfo*)(peer->data))->lastPunchY;
									if (xxx < 0 && yyy < 0) continue;
									try {
										bool success = true;
										int withdrawcpy = world->items.at(xxx + (yyy * world->width)).vdraw;
										int count, Rem = 0; int counts = 0; string text = "";
										if (withdrawcpy != 0) {
											if (withdrawcpy <= 100) {
												count = withdrawcpy;
												short int currentItemCount = 0;
												for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++) {
													if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == 242) {
														currentItemCount = ((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
													}
												}
												int plus = currentItemCount + count;
												if (plus > 200) {
													counts = 200 - currentItemCount;
													if (CheckItemMaxed(peer, 242, counts)) {
														Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`wI dont have free space to collect World Locks!", 0, true);
														continue;
													}
													else {
														SaveItemMoreTimes(242, counts, peer, success, pData->rawName + " collected from Vending Machine");
														world->items.at(xxx + (yyy * world->width)).vdraw -= counts;
														int cn = world->items.at(xxx + (yyy * world->width)).vdraw;
														Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`wYou collected " + to_string(counts) + " World Locks, leaving " + to_string(cn) + " World Locks in the machine!", 0, true);
													}
												}
												else {
													if (CheckItemMaxed(peer, 242, withdrawcpy)) {
														Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`wI dont have free space to collect World Locks!", 0, true);
														continue;
													}
													else {
														SaveItemMoreTimes(242, withdrawcpy, peer, success, pData->rawName + " collected from Vending Machine");
														Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`wYou collected " + to_string(withdrawcpy) + " World Locks.", 0, true);
														world->items.at(xxx + (yyy * world->width)).vdraw = 0;
													}
												}
											}
											else if (withdrawcpy > 100) {
												count = withdrawcpy / 100;
												short int currentItemCount = 0;
												for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++) {
													if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == 1796) {
														currentItemCount = ((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
													}
												}
												int plus = currentItemCount + count;
												if (plus > 200) {
													counts = 200 - currentItemCount;
													if (CheckItemMaxed(peer, 1796, counts)) {
														Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`wI dont have free space to collect Diamond Locks!", 0, true);
														continue;
													}
													SaveItemMoreTimes(1796, counts, peer, success, pData->rawName + " collected from Vending Machine");
													world->items.at(xxx + (yyy * world->width)).vdraw -= counts * 100;
													int cn = world->items.at(xxx + (yyy * world->width)).vdraw;
													short int currentItemCount1 = 0; string dtxt, dtxt2, dtxt3 = ""; int total, total1 = 0;
													for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++) {
														if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == 1796) {
															currentItemCount1 = ((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
														}
													}
													if (currentItemCount1 == 200 && cn > 100) {
														total = cn / 100;
														total1 = total - cn;
														if (total1 > 0) {
															dtxt2 = " " + to_string(total1) + " World Locks";
															dtxt3 = " and";
														}
														dtxt = "" + to_string(total) + " Diamond Lock" + dtxt3 + "";
													}
													Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`wYou collected " + to_string(counts) + " Diamond Locks, leaving " + dtxt + dtxt2 + " in the machine!", 0, true);
												}
												else {
													if (count < 200) counts += count;
													else if (count > 199) counts += 200;
													if (CheckItemMaxed(peer, 1796, counts)) {
														Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`wI dont have free space to collect World Locks & Diamond Locks!", 0, true);
														continue;
													}
													SaveItemMoreTimes(1796, counts, peer, success, pData->rawName + " collected from Vending Machine");
													world->items.at(xxx + (yyy * world->width)).vdraw -= counts * 100;
													Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`wYou collected " + to_string(count) + " Diamond Lock.", 0, true);
													int cn = world->items.at(xxx + (yyy * world->width)).vdraw;
													if (cn != 0) {
														int countz = 0; short int currentItemCount = 0;
														for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++) {
															if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == 242) {
																currentItemCount = ((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
															}
														}
														int plus = currentItemCount + cn;
														if (plus > 200) countz = 200 - currentItemCount;
														else if (cn < 200) countz += cn;
														else if (cn > 199) countz += 200;
														if (CheckItemMaxed(peer, 242, countz)) {
															Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`wI dont have free space to collect World Locks!", 0, true);
															continue;
														}
														SaveItemMoreTimes(242, countz, peer, success, pData->rawName + " collected from Vending Machine");
														Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`wYou collected " + to_string(counts) + " Diamond Lock and " + to_string(countz) + " World Locks.", 0, true);
														world->items.at(xxx + (yyy * world->width)).vdraw -= countz;
													}
													else {
													}
												}
											}
											int realid = world->items.at(xxx + (yyy * world->width)).vid;
											int priceid = world->items.at(xxx + (yyy * world->width)).vprice;
											if (world->items.at(xxx + (yyy * world->width)).vcount == 0) {
												priceid = 0; realid = 0;
											}
											bool with = false;
											if (world->items.at(xxx + (yyy * world->width)).vdraw > 0) with = true;
											for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
												if (isHere(peer, currentPeer)) {
													if (isHere(peer, currentPeer)) {
														if (world->items.at(xxx + (yyy * world->width)).opened && world->items.at(xxx + (yyy * world->width)).vcount < world->items.at(xxx + (yyy * world->width)).vprice) {
															UpdateVend(currentPeer, xxx, yyy, 0, true, priceid, world->items.at(xxx + (yyy * world->width)).background, world->items.at(xxx + (yyy * world->width)).opened);
														}
														else UpdateVend(currentPeer, xxx, yyy, realid, true, priceid, world->items.at(xxx + (yyy * world->width)).background, world->items.at(xxx + (yyy * world->width)).opened);
													}
												}
											}
										}
										else {
											Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`wHuh?", 0, true);
										}
									}
									catch (const std::out_of_range& e) {
										std::cout << e.what() << std::endl;
									}
								}
								if (btn == "pullstock2")
								{
									if (world->owner != "" && !isWorldOwner(peer, world) && !isMod(peer)) continue;
									int xxx = pData->lastPunchX;
									int yyy = pData->lastPunchY;
									if (xxx < 0 && yyy < 0) continue;
									try {
										int withdrawcpy = world->items.at(xxx + (yyy * world->width)).vdraw;
										if (withdrawcpy != 0) {
											Player::OnTalkBubble(peer, pData->netID, "`wWithdraw the world locks first!", 0, true);
											continue;
										}
										int realid = world->items.at(xxx + (yyy * world->width)).vid;
										int countid = world->items.at(xxx + (yyy * world->width)).vcount;
										if (CheckItemMaxed(peer, realid, countid)) {
											Player::OnTalkBubble(peer, pData->netID, "`wYou can't carry any of those!", 0, true);
											Player::OnConsoleMessage(peer, "`oYou can't carry any of those!");
											continue;
										}
										if (countid > 200) {
											bool success = true;
											SaveItemMoreTimes(realid, 200, peer, success, pData->rawName + " collected from DigiVend Machine");
											world->items.at(xxx + (yyy * world->width)).vcount -= 200;
											Player::OnTalkBubble(peer, pData->netID, "`wYou picked up 200 " + getItemDef(realid).name + "`w, leaving " + to_string(world->items.at(xxx + (yyy * world->width)).vcount) + " in the machine.", 0, true);
											if (isMod(peer) && !isWorldOwner(peer, world)) LogAccountActivity(pData->rawName, pData->rawName, "Collected 200 " + getItemDef(realid).name + " from " + getItemDef(world->items.at(xxx + (yyy * world->width)).foreground).name + " (" + world->name + ")");
											Player::OnConsoleMessage(peer, "`oYou picked up 200 " + getItemDef(realid).name + "`o, leaving " + to_string(world->items.at(xxx + (yyy * world->width)).vcount) + " in the machine.");
											ENetPeer* currentPeer;
											for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
												if (isHere(peer, currentPeer)) {
													if (world->items.at(xxx + (yyy * world->width)).opened && world->items.at(xxx + (yyy * world->width)).vcount < world->items.at(xxx + (yyy * world->width)).vprice) {
														UpdateDigiVend(currentPeer, xxx, yyy, 0, false, world->items.at(xxx + (yyy * world->width)).vprice, world->items.at(xxx + (yyy * world->width)).background, world->items.at(xxx + (yyy * world->width)).opened);
													}
													else UpdateDigiVend(currentPeer, xxx, yyy, world->items.at(xxx + (yyy * world->width)).vid, false, world->items.at(xxx + (yyy * world->width)).vprice, world->items.at(xxx + (yyy * world->width)).background, world->items.at(xxx + (yyy * world->width)).opened);
												}
											}
										}
										else
										{
											world->items.at(xxx + (yyy * world->width)).vprice = 0;
											bool success = true;
											SaveItemMoreTimes(realid, countid, peer, success, pData->rawName + " collected from DigiVend Machine");
											world->items.at(xxx + (yyy * world->width)).vid = 0;
											world->items.at(xxx + (yyy * world->width)).vcount = 0;
											Player::OnTalkBubble(peer, pData->netID, "`wYou picked up " + to_string(countid) + " " + getItemDef(realid).name + "`w.", 0, true);
											if (isMod(peer) && !isWorldOwner(peer, world)) LogAccountActivity(pData->rawName, pData->rawName, "Collected " + to_string(countid) + " " + getItemDef(realid).name + " from " + getItemDef(world->items.at(xxx + (yyy * world->width)).foreground).name + " (" + world->name + ")");
											Player::OnConsoleMessage(peer, "`oYou picked up " + to_string(countid) + " " + getItemDef(realid).name + "`o.");
											ENetPeer* currentPeer;
											for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
												if (isHere(peer, currentPeer)) {
													if (world->items.at(xxx + (yyy * world->width)).opened && world->items.at(xxx + (yyy * world->width)).vcount < world->items.at(xxx + (yyy * world->width)).vprice) {
														UpdateDigiVend(currentPeer, xxx, yyy, 0, false, world->items.at(xxx + (yyy * world->width)).vprice, world->items.at(xxx + (yyy * world->width)).background, world->items.at(xxx + (yyy * world->width)).opened);
													}
													else UpdateDigiVend(currentPeer, xxx, yyy, 0, false, 0, world->items.at(xxx + (yyy * world->width)).background, world->items.at(xxx + (yyy * world->width)).opened);
												}
											}
										}
									}
									catch (const std::out_of_range& e) {
										std::cout << e.what() << std::endl;
									}
								}
								if (btn == "withdraw2") {
									int xxx = ((PlayerInfo*)(peer->data))->lastPunchX;
									int yyy = ((PlayerInfo*)(peer->data))->lastPunchY;
									if (xxx < 0 && yyy < 0) continue;
									try {
										bool success = true;
										int withdrawcpy = world->items.at(xxx + (yyy * world->width)).vdraw;
										int count, Rem = 0; int counts = 0; string text = "";
										if (withdrawcpy != 0) {
											if (withdrawcpy <= 100) {
												count = withdrawcpy;
												short int currentItemCount = 0;
												for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++) {
													if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == 242) {
														currentItemCount = ((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
													}
												}
												int plus = currentItemCount + count;
												if (plus > 200) {
													counts = 200 - currentItemCount;
													if (CheckItemMaxed(peer, 242, counts)) {
														Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`wI dont have free space to collect World Locks!", 0, true);
														continue;
													}
													else {
														SaveItemMoreTimes(242, counts, peer, success, pData->rawName + " collected from Vending Machine");
														world->items.at(xxx + (yyy * world->width)).vdraw -= counts;
														int cn = world->items.at(xxx + (yyy * world->width)).vdraw;
														Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`wYou collected " + to_string(counts) + " World Locks, leaving " + to_string(cn) + " World Locks in the machine!", 0, true);
													}
												}
												else {
													if (CheckItemMaxed(peer, 242, withdrawcpy)) {
														Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`wI dont have free space to collect World Locks!", 0, true);
														continue;
													}
													else {
														SaveItemMoreTimes(242, withdrawcpy, peer, success, pData->rawName + " collected from Vending Machine");
														Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`wYou collected " + to_string(withdrawcpy) + " World Locks.", 0, true);
														world->items.at(xxx + (yyy * world->width)).vdraw = 0;
													}
												}
											}
											else if (withdrawcpy > 100) {
												count = withdrawcpy / 100;
												short int currentItemCount = 0;
												for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++) {
													if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == 1796) {
														currentItemCount = ((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
													}
												}
												int plus = currentItemCount + count;
												if (plus > 200) {
													counts = 200 - currentItemCount;
													if (CheckItemMaxed(peer, 1796, counts)) {
														Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`wI dont have free space to collect Diamond Locks!", 0, true);
														continue;
													}
													SaveItemMoreTimes(1796, counts, peer, success, pData->rawName + " collected from Vending Machine");
													world->items.at(xxx + (yyy * world->width)).vdraw -= counts * 100;
													int cn = world->items.at(xxx + (yyy * world->width)).vdraw;
													short int currentItemCount1 = 0; string dtxt, dtxt2, dtxt3 = ""; int total, total1 = 0;
													for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++) {
														if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == 1796) {
															currentItemCount1 = ((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
														}
													}
													if (currentItemCount1 == 200 && cn > 100) {
														total = cn / 100;
														total1 = total - cn;
														if (total1 > 0) {
															dtxt2 = " " + to_string(total1) + " World Locks";
															dtxt3 = " and";
														}
														dtxt = "" + to_string(total) + " Diamond Lock" + dtxt3 + "";
													}
													Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`wYou collected " + to_string(counts) + " Diamond Locks, leaving " + dtxt + dtxt2 + " in the machine!", 0, true);
												}
												else {
													if (count < 200) counts += count;
													else if (count > 199) counts += 200;
													if (CheckItemMaxed(peer, 1796, counts)) {
														Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`wI dont have free space to collect World Locks & Diamond Locks!", 0, true);
														continue;
													}
													SaveItemMoreTimes(1796, counts, peer, success, pData->rawName + " collected from Vending Machine");
													world->items.at(xxx + (yyy * world->width)).vdraw -= counts * 100;
													Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`wYou collected " + to_string(count) + " Diamond Lock.", 0, true);
													int cn = world->items.at(xxx + (yyy * world->width)).vdraw;
													if (cn != 0) {
														int countz = 0; short int currentItemCount = 0;
														for (int i = 0; i < ((PlayerInfo*)(peer->data))->inventory.items.size(); i++) {
															if (((PlayerInfo*)(peer->data))->inventory.items.at(i).itemID == 242) {
																currentItemCount = ((PlayerInfo*)(peer->data))->inventory.items.at(i).itemCount;
															}
														}
														int plus = currentItemCount + cn;
														if (plus > 200) countz = 200 - currentItemCount;
														else if (cn < 200) countz += cn;
														else if (cn > 199) countz += 200;
														if (CheckItemMaxed(peer, 242, countz)) {
															Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`wI dont have free space to collect World Locks!", 0, true);
															continue;
														}
														SaveItemMoreTimes(242, countz, peer, success, pData->rawName + " collected from Vending Machine");
														Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`wYou collected " + to_string(counts) + " Diamond Lock and " + to_string(countz) + " World Locks.", 0, true);
														world->items.at(xxx + (yyy * world->width)).vdraw -= countz;
													}
													else {
													}
												}
											}
											int realid = world->items.at(xxx + (yyy * world->width)).vid;
											int priceid = world->items.at(xxx + (yyy * world->width)).vprice;
											if (world->items.at(xxx + (yyy * world->width)).vcount == 0) {
												priceid = 0; realid = 0;
											}
											bool with = false;
											if (world->items.at(xxx + (yyy * world->width)).vdraw > 0) with = true;
											for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
												if (isHere(peer, currentPeer)) {
													if (isHere(peer, currentPeer)) {
														if (world->items.at(xxx + (yyy * world->width)).opened && world->items.at(xxx + (yyy * world->width)).vcount < world->items.at(xxx + (yyy * world->width)).vprice) {
															UpdateDigiVend(currentPeer, xxx, yyy, 0, true, priceid, world->items.at(xxx + (yyy * world->width)).background, world->items.at(xxx + (yyy * world->width)).opened);
														}
														else UpdateDigiVend(currentPeer, xxx, yyy, realid, true, priceid, world->items.at(xxx + (yyy * world->width)).background, world->items.at(xxx + (yyy * world->width)).opened);
													}
												}
											}
										}
										else {
											Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`wHuh?", 0, true);
										}
									}
									catch (const std::out_of_range& e) {
										std::cout << e.what() << std::endl;
									}
								}
								if (btn == "manipulatorstop") {
									if (world == nullptr || pData->currentWorld == "EXIT" || serverIsFrozen) continue;
									int x = pData->lastPunchX;
									int y = pData->lastPunchY;
									try {
										world->items.at(x + (y * world->width)).mid = 0;
										ENetPeer* currentPeer;
										for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
											if (isHere(peer, currentPeer)) {
												send_item_sucker(currentPeer, 6952, x, y, world->items.at(x + (y * world->width)).mid, 0, false, false, world->items.at(x + (y * world->width)).background);
											}
										}
									}
									catch (const std::out_of_range& e) {
										std::cout << e.what() << std::endl;
									}
								}
								if (btn == "organicstop") {
									if (world == nullptr || pData->currentWorld == "EXIT" || serverIsFrozen) continue;
									int x = pData->lastPunchX;
									int y = pData->lastPunchY;
									try {
										if (world->items.at(x + (y * world->width)).mc > 250) {
											if (CheckItemMaxed(peer, world->items.at(x + (y * world->width)).mid, 250)) {
												Player::OnTalkBubble(peer, pData->netID, "`wI dont have a free space to pickup `2250 `$" + getItemDef(world->items.at(x + (y * world->width)).mid).name + "`w!", 0, true);
												continue;
											}
											else {
												world->items.at(x + (y * world->width)).mc -= 250;
												bool success = true;
												SaveItemMoreTimes(world->items.at(x + (y * world->width)).mid, 250, peer, success, pData->rawName + " withdraw from Techno-Organic Engine");
												Player::OnTalkBubble(peer, pData->netID, "`oCollected `2250 `5" + getItemDef(world->items.at(x + (y * world->width)).mid).name + " `oFrom the Techno-Organic Engine!", 0, true);
												if (isMod(peer) && !isWorldOwner(peer, world)) LogAccountActivity(pData->rawName, pData->rawName, "Collected 250 " + getItemDef(world->items.at(x + (y * world->width)).mid).name + " from " + getItemDef(world->items.at(x + (y * world->width)).foreground).name + " (" + world->name + ")");
												ENetPeer* currentPeer;
												for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
													if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
													if (isHere(peer, currentPeer)) {
														send_item_sucker(currentPeer, 6954, x, y, world->items.at(x + (y * world->width)).mid, 1, true, true, world->items.at(x + (y * world->width)).background);
													}
												}
											}
										}
										else
										{
											if (CheckItemMaxed(peer, world->items.at(x + (y * world->width)).mid, world->items.at(x + (y * world->width)).mc)) {
												Player::OnTalkBubble(peer, pData->netID, "`wI dont have a free space to pickup `2" + to_string(world->items.at(x + (y * world->width)).mc) + " `$" + getItemDef(world->items.at(x + (y * world->width)).mid).name + "`w!", 0, true);
												continue;
											}
											else {
												bool success = true;
												SaveItemMoreTimes(world->items.at(x + (y * world->width)).mid, world->items.at(x + (y * world->width)).mc, peer, success, pData->rawName + " withdraw from Techno-Organic Engine");
												Player::OnTalkBubble(peer, pData->netID, "`oCollected `2" + to_string(world->items.at(x + (y * world->width)).mc) + " `5" + getItemDef(world->items.at(x + (y * world->width)).mid).name + " `oFrom the Techno-Organic Engine!", 0, true);
												if (isMod(peer) && !isWorldOwner(peer, world)) LogAccountActivity(pData->rawName, pData->rawName, "Collected " + to_string(world->items.at(x + (y * world->width)).mc) + " " + getItemDef(world->items.at(x + (y * world->width)).mid).name + " from " + getItemDef(world->items.at(x + (y * world->width)).foreground).name + " (" + world->name + ")");
												world->items.at(x + (y * world->width)).mid = 0;
												ENetPeer* currentPeer;
												for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
													if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
													if (isHere(peer, currentPeer)) {
														send_item_sucker(currentPeer, 6954, x, y, world->items.at(x + (y * world->width)).mid, -1, true, true, world->items.at(x + (y * world->width)).background);
													}
												}
												world->items.at(x + (y * world->width)).mc = 0;
											}
										}
									}
									catch (const std::out_of_range& e) {
										std::cout << e.what() << std::endl;
									}
								}
								if (btn == "addorganic") {
									if (world->owner != "" && !isWorldOwner(peer, world)) continue;
									int xxx = pData->lastPunchX;
									int yyy = pData->lastPunchY;
									if (xxx < 0 && yyy < 0) continue;
									try {
										int iditem = world->items.at(xxx + (yyy * world->width)).mid;
										int countitem = world->items.at(xxx + (yyy * world->width)).mc;
										auto mtitems = 0;
										for (auto i = 0; i < pData->inventory.items.size(); i++) {
											if (pData->inventory.items.at(i).itemID == iditem) {
												mtitems = pData->inventory.items.at(i).itemCount;
												break;
											}
										}
										auto iscontainseas = false;
										SearchInventoryItem(peer, iditem, mtitems, iscontainseas);
										if (!iscontainseas) {
											Player::OnTalkBubble(peer, pData->netID, "Huh?", 0, true);
											continue;
										}
										else {
											if (countitem + mtitems > 15000) {
												Player::OnTalkBubble(peer, pData->netID, "The machine will really explode if you will fit more of them into it!", 0, true);
												continue;
											}
											RemoveInventoryItem(iditem, mtitems, peer, true);
											countitem += mtitems;
											world->items.at(xxx + (yyy * world->width)).mc = countitem;
											Player::OnTalkBubble(peer, pData->netID, "`wAdded " + to_string(mtitems) + " to the machine.", 0, true);
											if (isMod(peer) && !isWorldOwner(peer, world)) LogAccountActivity(pData->rawName, pData->rawName, "Added " + to_string(mtitems) + " " + getItemDef(world->items.at(xxx + (yyy * world->width)).mid).name + " into " + getItemDef(world->items.at(xxx + (yyy * world->width)).foreground).name + " (" + world->name + ")");
											ENetPeer* currentPeer;
											for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
												if (isHere(peer, currentPeer)) {
													send_item_sucker(currentPeer, 6954, xxx, yyy, world->items.at(xxx + (yyy * world->width)).mid, 1, true, true, world->items.at(xxx + (yyy * world->width)).background);
												}
											}
										}
									}
									catch (const std::out_of_range& e) {
										std::cout << e.what() << std::endl;
									}
								}
								if (btn == "addvend") {
									if (world->owner != "" && !isWorldOwner(peer, world) && !isMod(peer)) continue;
									int xxx = pData->lastPunchX;
									int yyy = pData->lastPunchY;
									if (xxx < 0 && yyy < 0) continue;
									try {
										int iditem = world->items.at(xxx + (yyy * world->width)).vid;
										int countitem = world->items.at(xxx + (yyy * world->width)).vcount;
										auto mtitems = 0;
										for (auto i = 0; i < pData->inventory.items.size(); i++) {
											if (pData->inventory.items.at(i).itemID == iditem) {
												mtitems = pData->inventory.items.at(i).itemCount;
												break;
											}
										}
										auto iscontainseas = false;
										SearchInventoryItem(peer, iditem, mtitems, iscontainseas);
										if (!iscontainseas) {
											Player::OnTalkBubble(peer, pData->netID, "Huh?", 0, true);
											continue;
										}
										else {
											RemoveInventoryItem(iditem, mtitems, peer, true);
											updateplayerset(peer, iditem);
											countitem += mtitems;
											world->items.at(xxx + (yyy * world->width)).vcount = countitem;
											Player::OnTalkBubble(peer, pData->netID, "`wAdded " + to_string(mtitems) + " to the machine.", 0, true);
											if (isMod(peer) && !isWorldOwner(peer, world)) LogAccountActivity(pData->rawName, pData->rawName, "Added " + to_string(mtitems) + " " + getItemDef(world->items.at(xxx + (yyy * world->width)).vid).name + " into " + getItemDef(world->items.at(xxx + (yyy * world->width)).foreground).name + " (" + world->name + ")");
										}
									}
									catch (const std::out_of_range& e) {
										std::cout << e.what() << std::endl;
									}
								}
								if (btn == "addletter")
								{
									if (world == nullptr || pData->currentWorld == "EXIT" || serverIsFrozen) continue;
									try {
										std::stringstream bss(cch);
										std::string bto;

										string text = "";
										string coord = "";

										while (std::getline(bss, bto, '\n'))
										{
											vector<string> infoDat = explode("|", bto);
											if (infoDat.at(0).substr(0, 15) == "addletterinput_")
											{
												text = infoDat.at(1);
												string coord = infoDat.at(0).substr(infoDat.at(0).find("_") + 1);
												auto isdbox = std::experimental::filesystem::exists("save/mailbox/_" + pData->currentWorld + "/X" + coord + ".json");
												if (!isdbox)
												{
													Player::OnTalkBubble(peer, pData->netID, "`4An error occured. Break the mailbox.", 0, true);
													break;
												}

												if (text.size() < 3)
												{
													Player::OnTalkBubble(peer, pData->netID, "`wThats not interesting enough to mail.", 0, true);
													break;
												}



												ifstream ifff("save/mailbox/_" + pData->currentWorld + "/X" + coord + ".json");
												json j;
												ifff >> j;
												ifff.close();

												if (j["inmail"] > 19)
												{
													Player::OnTalkBubble(peer, pData->netID, "`oThis mailbox already has `w20 `oletters in it. Try again later.", 0, true);
												}
												for (int i = 0; i < 20; i++)
												{
													if (j["mails"].at(i)["growid"] == "")
													{
														j["mails"].at(i)["growid"] = pData->displayName;
														j["mails"].at(i)["text"] = text;
														if (isMod(peer) && !isWorldOwner(peer, world)) LogAccountActivity(pData->rawName, pData->rawName, "Added letter (" + text + "``) into Mailbox (" + world->name + ")");
														Player::OnTalkBubble(peer, pData->netID, "`2You place your letter in the mailbox.", 0, true);
														int x = j["x"];
														int y = j["y"];
														if (j["inmail"] < 1)
														{
															/*ENetPeer* currentPeer;
															for (currentPeer = server->peers;
																currentPeer < &server->peers[server->peerCount];
																++currentPeer)
															{
																if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
																if (isHere(peer, currentPeer))
																{
																	SendItemPacket(currentPeer, 656, 0, x, y, 1);
																}
															}*/
														}
														j["inmail"] = j["inmail"].get<double>() + 1;
														ofstream of("save/mailbox/_" + pData->currentWorld + "/X" + coord + ".json");
														of << j << std::endl;
														of.close();
														break;
													}
												}
											}
										}
									}
									catch (const std::out_of_range& e) {
										std::cout << e.what() << std::endl;
									}
								}
								if (btn == "addblueletter")
								{
									if (world == nullptr || pData->currentWorld == "EXIT" || serverIsFrozen) continue;
									try {
										std::stringstream bss(cch);
										std::string bto;

										string text = "";

										while (std::getline(bss, bto, '\n'))
										{
											vector<string> infoDat = explode("|", bto);
											if (infoDat.at(0).substr(0, 19) == "addblueletterinput_")
											{
												text = infoDat.at(1);
												string coord = infoDat.at(0).substr(infoDat.at(0).find("_") + 1);
												auto isdbox = std::experimental::filesystem::exists("save/bluemailbox/_" + pData->currentWorld + "/X" + coord + ".json");
												if (!isdbox)
												{
													Player::OnTalkBubble(peer, pData->netID, "`4An error occured. Break the blue mailbox.", 0, true);
													break;
												}

												if (text.size() < 3)
												{
													Player::OnTalkBubble(peer, pData->netID, "`wThats not interesting enough to mail.", 0, true);
													break;
												}



												ifstream ifff("save/bluemailbox/_" + pData->currentWorld + "/X" + coord + ".json");
												json j;
												ifff >> j;
												ifff.close();

												if (j["inmail"] > 19)
												{
													Player::OnTalkBubble(peer, pData->netID, "`oThis mailbox already has `w20 `oletters in it. Try again later.", 0, true);
												}
												for (int i = 0; i < 20; i++)
												{
													if (j["mails"].at(i)["growid"] == "")
													{
														j["mails"].at(i)["growid"] = pData->displayName;
														j["mails"].at(i)["text"] = text;
														Player::OnTalkBubble(peer, pData->netID, "`2You place your letter in the mailbox.", 0, true);
														if (isMod(peer) && !isWorldOwner(peer, world)) LogAccountActivity(pData->rawName, pData->rawName, "Added letter (" + text + "``) into Blue Mailbox (" + world->name + ")");
														int x = j["x"];
														int y = j["y"];
														if (j["inmail"] < 1)
														{
															ENetPeer* currentPeer;
															for (currentPeer = server->peers;
																currentPeer < &server->peers[server->peerCount];
																++currentPeer)
															{
																if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
																if (isHere(peer, currentPeer))
																{
																	SendItemPacket(currentPeer, 1006, 0, x, y, 1);
																}
															}
														}
														j["inmail"] = j["inmail"].get<double>() + 1;
														ofstream of("save/bluemailbox/_" + pData->currentWorld + "/X" + coord + ".json");
														of << j << std::endl;
														of.close();
														break;
													}
												}
											}
										}
									}
									catch (const std::out_of_range& e) {
										std::cout << e.what() << std::endl;
									}
								}
								if (btn == "boxlvl2depositconfirm")
								{
									if (world == nullptr || pData->currentWorld == "EXIT" || serverIsFrozen) continue;
									try {
										std::stringstream bss(cch);
										std::string bto;

										string count = "";
										int countint = 0;
										string coord = "";
										string id = "";
										int idint = 0;

										while (std::getline(bss, bto, '\n'))
										{
											vector<string> infoDat = explode("|", bto);
											if (infoDat.at(0).substr(0, 20) == "boxlvl2depositcount_")
											{
												count = infoDat.at(1);

												string coord_and_id = infoDat.at(0).erase(0, 20);
												string::size_type pos = coord_and_id.find('_');
												if (pos != std::string::npos)
												{
													coord = coord_and_id.substr(0, pos);
													coord_and_id.erase(0, pos + 1);
													id = coord_and_id;
												}
												else
												{
													break;
												}
												auto isdbox = std::experimental::filesystem::exists("save/storageboxlvl2/_" + pData->currentWorld + "/X" + coord + ".json");
												if (!isdbox)
												{
													Player::OnTalkBubble(peer, pData->netID, "`4An error occured while getting box info.", 0, true);
													break;
												}

												bool contains_non_int3 = !std::regex_match(id, std::regex("^[0-9]+$"));
												if (contains_non_int3 == true)
												{
													break;
												}

												bool contains_non_int4 = !std::regex_match(count, std::regex("^[0-9]+$"));
												if (contains_non_int4 == true)
												{
													Player::OnTalkBubble(peer, pData->netID, "Invalid input in amount!", 0, false);
													break;
												}
												countint = atoi(count.c_str());

												idint = atoi(id.c_str());
												if (idint < 1 || idint > maxItems)
												{
													break;
												}

												if (countint < 1 || countint > 250)
												{
													Player::OnTalkBubble(peer, pData->netID, "Invalid input in amount!", 0, false);
													break;
												}



												ifstream ifff("save/storageboxlvl2/_" + pData->currentWorld + "/X" + coord + ".json");
												json j;
												ifff >> j;
												ifff.close();

												if (j["instorage"] > 19)
												{
													Player::OnTalkBubble(peer, pData->netID, "`4Storage Box Xtreme - Level 2 is full!", 0, true);
													break;
												}
												bool isContains = false;
												SearchInventoryItem(peer, idint, countint, isContains);
												if (isContains == false)
												{
													Player::OnTextOverlay(peer, "`4You Don't have enough " + itemDefs[idint].name + " in your inventory.");
													break;
												}
												j["instorage"] = j["instorage"].get<double>() + 1;

												for (int i = 0; i < 20; i++)
												{
													if (j["storage"].at(i)["itemid"] == 0)
													{
														j["storage"].at(i)["itemid"] = idint;
														j["storage"].at(i)["placedby"] = pData->rawName;
														j["storage"].at(i)["itemcount"] = countint;

														Player::OnTalkBubble(peer, pData->netID, "`wStored " + to_string(countint) + " " + itemDefs[idint].name + " `win the Storage Box Xtreme - Level 2", 0, true);
														if (isMod(peer) && !isWorldOwner(peer, world)) LogAccountActivity(pData->rawName, pData->rawName, "Stored " + to_string(countint) + " " + itemDefs[idint].name + " in Storage Box Xtreme - Level 2 (" + world->name + ")");
														break;
													}
												}

												ofstream of("save/storageboxlvl2/_" + pData->currentWorld + "/X" + coord + ".json");
												of << j << std::endl;
												of.close();
												RemoveInventoryItem(idint, countint, peer, true);
												updateplayerset(peer, idint);
											}
										}
									}
									catch (const std::out_of_range& e) {
										std::cout << e.what() << std::endl;
									}
								}
								if (btn == "boxlvl3depositconfirm")
								{
									if (world == nullptr || pData->currentWorld == "EXIT" || serverIsFrozen) continue;
									try {
										std::stringstream bss(cch);
										std::string bto;

										string count = "";
										int countint = 0;
										string coord = "";
										string id = "";
										int idint = 0;

										while (std::getline(bss, bto, '\n'))
										{
											vector<string> infoDat = explode("|", bto);
											if (infoDat.at(0).substr(0, 20) == "boxlvl3depositcount_")
											{
												count = infoDat.at(1);

												string coord_and_id = infoDat.at(0).erase(0, 20);
												string::size_type pos = coord_and_id.find('_');
												if (pos != std::string::npos)
												{
													coord = coord_and_id.substr(0, pos);
													coord_and_id.erase(0, pos + 1);
													id = coord_and_id;
												}
												else
												{
													break;
												}
												auto isdbox = std::experimental::filesystem::exists("save/storageboxlvl3/_" + pData->currentWorld + "/X" + coord + ".json");
												if (!isdbox)
												{
													Player::OnTalkBubble(peer, pData->netID, "`4An error occured while getting box info.", 0, true);
													break;
												}

												bool contains_non_int3 = !std::regex_match(id, std::regex("^[0-9]+$"));
												if (contains_non_int3 == true)
												{
													break;
												}

												bool contains_non_int4 = !std::regex_match(count, std::regex("^[0-9]+$"));
												if (contains_non_int4 == true)
												{
													Player::OnTalkBubble(peer, pData->netID, "Invalid input in amount!", 0, false);
													break;
												}
												countint = atoi(count.c_str());

												idint = atoi(id.c_str());
												if (idint < 1 || idint > maxItems)
												{
													break;
												}

												if (countint < 1 || countint > 250)
												{
													Player::OnTalkBubble(peer, pData->netID, "Invalid input in amount!", 0, false);
													break;
												}



												ifstream ifff("save/storageboxlvl3/_" + pData->currentWorld + "/X" + coord + ".json");
												json j;
												ifff >> j;
												ifff.close();

												if (j["instorage"] > 19)
												{
													Player::OnTalkBubble(peer, pData->netID, "`4Storage Box Xtreme - Level 3 is full!", 0, true);
													break;
												}
												bool isContains = false;
												SearchInventoryItem(peer, idint, countint, isContains);
												if (isContains == false)
												{
													Player::OnTextOverlay(peer, "`4You Don't have enough " + itemDefs[idint].name + " in your inventory.");
													break;
												}
												j["instorage"] = j["instorage"].get<double>() + 1;

												for (int i = 0; i < 20; i++)
												{
													if (j["storage"].at(i)["itemid"] == 0)
													{
														j["storage"].at(i)["itemid"] = idint;
														j["storage"].at(i)["placedby"] = pData->rawName;
														j["storage"].at(i)["itemcount"] = countint;

														Player::OnTalkBubble(peer, pData->netID, "`wStored " + to_string(countint) + " " + itemDefs[idint].name + " `win the Storage Box Xtreme - Level 3", 0, true);
														if (isMod(peer) && !isWorldOwner(peer, world)) LogAccountActivity(pData->rawName, pData->rawName, "Stored " + to_string(countint) + " " + itemDefs[idint].name + " in Storage Box Xtreme - Level 3 (" + world->name + ")");
														break;
													}
												}

												ofstream of("save/storageboxlvl3/_" + pData->currentWorld + "/X" + coord + ".json");
												of << j << std::endl;
												of.close();
												RemoveInventoryItem(idint, countint, peer, true);
												updateplayerset(peer, idint);
											}
										}
									}
									catch (const std::out_of_range& e) {
										std::cout << e.what() << std::endl;
									}
								}
								if (btn == "boxlvl1depositconfirm")
								{
									if (world == nullptr || pData->currentWorld == "EXIT" || serverIsFrozen) continue;
									try {
										std::stringstream bss(cch);
										std::string bto;

										string count = "";
										int countint = 0;
										string coord = "";
										string id = "";
										int idint = 0;

										while (std::getline(bss, bto, '\n'))
										{
											vector<string> infoDat = explode("|", bto);
											if (infoDat.at(0).substr(0, 20) == "boxlvl1depositcount_")
											{
												count = infoDat.at(1);

												string coord_and_id = infoDat.at(0).erase(0, 20);
												string::size_type pos = coord_and_id.find('_');
												if (pos != std::string::npos)
												{
													coord = coord_and_id.substr(0, pos);
													coord_and_id.erase(0, pos + 1);
													id = coord_and_id;
												}
												else
												{
													break;
												}
												auto isdbox = std::experimental::filesystem::exists("save/storageboxlvl1/_" + pData->currentWorld + "/X" + coord + ".json");
												if (!isdbox)
												{
													Player::OnTalkBubble(peer, pData->netID, "`4An error occured while getting box info.", 0, true);
													break;
												}

												bool contains_non_int3 = !std::regex_match(id, std::regex("^[0-9]+$"));
												if (contains_non_int3 == true)
												{
													break;
												}

												bool contains_non_int4 = !std::regex_match(count, std::regex("^[0-9]+$"));
												if (contains_non_int4 == true)
												{
													Player::OnTalkBubble(peer, pData->netID, "Invalid input in amount!", 0, false);
													break;
												}
												countint = atoi(count.c_str());

												idint = atoi(id.c_str());
												if (idint < 1 || idint > maxItems)
												{
													break;
												}

												if (countint < 1 || countint > 250)
												{
													Player::OnTalkBubble(peer, pData->netID, "Invalid input in amount!", 0, false);
													break;
												}



												ifstream ifff("save/storageboxlvl1/_" + pData->currentWorld + "/X" + coord + ".json");
												json j;
												ifff >> j;
												ifff.close();

												if (j["instorage"] > 19)
												{
													Player::OnTalkBubble(peer, pData->netID, "`4Storage Box Xtreme - Level 1 is full!", 0, true);
													break;
												}
												bool isContains = false;
												SearchInventoryItem(peer, idint, countint, isContains);
												if (isContains == false)
												{
													Player::OnTextOverlay(peer, "`4You Don't have enough " + itemDefs[idint].name + " in your inventory.");
													break;
												}
												j["instorage"] = j["instorage"].get<double>() + 1;

												for (int i = 0; i < 20; i++)
												{
													if (j["storage"].at(i)["itemid"] == 0)
													{
														j["storage"].at(i)["itemid"] = idint;
														j["storage"].at(i)["placedby"] = pData->rawName;
														j["storage"].at(i)["itemcount"] = countint;

														Player::OnTalkBubble(peer, pData->netID, "`wStored " + to_string(countint) + " " + itemDefs[idint].name + " `win the Storage Box Xtreme - Level 1", 0, true);
														if (isMod(peer) && !isWorldOwner(peer, world)) LogAccountActivity(pData->rawName, pData->rawName, "Stored " + to_string(countint) + " " + itemDefs[idint].name + " in Storage Box Xtreme - Level 1 (" + world->name + ")");
														break;
													}
												}

												ofstream of("save/storageboxlvl1/_" + pData->currentWorld + "/X" + coord + ".json");
												of << j << std::endl;
												of.close();
												RemoveInventoryItem(idint, countint, peer, true);
												updateplayerset(peer, idint);
											}
										}
									}
									catch (const std::out_of_range& e) {
										std::cout << e.what() << std::endl;
									}
								}
								if (btn == "boxlvl2_withdrawConfirm")
								{
									if (world == nullptr || pData->currentWorld == "EXIT" || serverIsFrozen) continue;
									try {
										std::stringstream bss(cch);
										std::string bto;

										string howMany = "";
										string apos = "";
										string coord = "";
										int aposInt = 0;
										int howManyInt = 0;

										while (std::getline(bss, bto, '\n'))
										{
											vector<string> infoDat = explode("|", bto);
											if (infoDat.at(0).substr(0, 16) == "boxlvl2withdraw_")
											{
												howMany = infoDat.at(1);
												if (howMany.size() > 5) break;

												string coord_and_apos = infoDat.at(0).erase(0, 16);
												string::size_type pos = coord_and_apos.find('_');
												if (pos != std::string::npos)
												{
													coord = coord_and_apos.substr(0, pos);
													coord_and_apos.erase(0, pos + 1);
													apos = coord_and_apos;
												}
												else
												{
													break;
												}
												auto isdbox = std::experimental::filesystem::exists("save/storageboxlvl2/_" + pData->currentWorld + "/X" + coord + ".json");
												if (!isdbox)
												{
													Player::OnTalkBubble(peer, pData->netID, "`4An error occured while getting safe vault info.", 0, true);
													break;
												}

												bool contains_non_int3 = !std::regex_match(apos, std::regex("^[0-9]+$"));
												if (contains_non_int3 == true)
												{
													break;
												}

												bool contains_non_int4 = !std::regex_match(howMany, std::regex("^[0-9]+$"));
												if (contains_non_int4 == true)
												{
													Player::OnTalkBubble(peer, pData->netID, "Invalid input in amount!", 0, false);
													break;
												}
												howManyInt = atoi(howMany.c_str());

												aposInt = atoi(apos.c_str());

												if (howManyInt < 1 || howManyInt > 250)
												{
													Player::OnTalkBubble(peer, pData->netID, "Invalid input in amount!", 0, false);
													break;
												}



												ifstream ifff("save/storageboxlvl2/_" + pData->currentWorld + "/X" + coord + ".json");
												json j;
												ifff >> j;
												ifff.close();

												int itemid = 0;
												bool success = true;

												for (int i = 0; i < 20; i++)
												{
													if (j["storage"].at(i)["aposition"] == aposInt)
													{
														itemid = j["storage"].at(i)["itemid"];

														if (itemid == 0) break;

														if (howManyInt > j["storage"].at(i)["itemcount"])
														{
															Player::OnTextOverlay(peer, "`4Your Storage Box Xtreme - Level 2 does not contains such many.");
															break;
														}

														if (CheckItemExists(peer, j["storage"].at(i)["itemid"]))
														{
															int currentlyHave = GetQuantityOfItem(peer, j["storage"].at(i)["itemid"]);
															if (howManyInt + currentlyHave < 251)
															{
																SaveItemMoreTimes(j["storage"].at(i)["itemid"], howManyInt, peer, success, pData->rawName + " from Storage Box Xtreme - Level 2");
															}
															else
															{
																Player::OnTextOverlay(peer, "`4You Don't have enought space.");
																break;
															}
														}
														else
														{
															if (pData->inventory.items.size() == pData->currentInventorySize)
															{
																Player::OnTextOverlay(peer, "`4Your inventory is full! You can purchase an inventory upgrade in the shop.");
																break;
															}

															SaveItemMoreTimes(j["storage"].at(i)["itemid"], howManyInt, peer, success, pData->rawName + " from Storage Box Xtreme - Level 2");
														}

														Player::OnTalkBubble(peer, pData->netID, "`wRemoved " + to_string(howManyInt) + " " + itemDefs[itemid].name + " from the Storage Box Xtreme - Level 2", 0, true);
														if (isMod(peer) && !isWorldOwner(peer, world)) LogAccountActivity(pData->rawName, pData->rawName, "Removed " + to_string(howManyInt) + " " + itemDefs[itemid].name + " from Storage Box Xtreme - Level 2 (" + world->name + ")");

														if (j["storage"].at(i)["itemcount"] == howManyInt)
														{
															j["storage"].at(i)["itemid"] = 0;
															j["storage"].at(i)["placedby"] = "There was " + to_string(howManyInt) + " of " + to_string(itemid) + " item, and " + pData->rawName + " withdrawed them.";
															j["storage"].at(i)["itemcount"] = 0;
															j["instorage"] = j["instorage"].get<double>() - 1;
														}
														else
														{
															j["storage"].at(i)["itemcount"] = j["storage"].at(i)["itemcount"].get<double>() - howManyInt;
														}

														ofstream of("save/storageboxlvl2/_" + pData->currentWorld + "/X" + coord + ".json");
														of << j << std::endl;
														of.close();
														break;
													}
												}
											}
										}
									}
									catch (const std::out_of_range& e) {
										std::cout << e.what() << std::endl;
									}
								}
								if (btn == "boxlvl3_withdrawConfirm")
								{
									if (world == nullptr || pData->currentWorld == "EXIT" || serverIsFrozen) continue;
									try {
										std::stringstream bss(cch);
										std::string bto;

										string howMany = "";
										string apos = "";
										string coord = "";
										int aposInt = 0;
										int howManyInt = 0;

										while (std::getline(bss, bto, '\n'))
										{
											vector<string> infoDat = explode("|", bto);
											if (infoDat.at(0).substr(0, 16) == "boxlvl3withdraw_")
											{
												howMany = infoDat.at(1);
												if (howMany.size() > 5) break;

												string coord_and_apos = infoDat.at(0).erase(0, 16);
												string::size_type pos = coord_and_apos.find('_');
												if (pos != std::string::npos)
												{
													coord = coord_and_apos.substr(0, pos);
													coord_and_apos.erase(0, pos + 1);
													apos = coord_and_apos;
												}
												else
												{
													break;
												}
												auto isdbox = std::experimental::filesystem::exists("save/storageboxlvl3/_" + pData->currentWorld + "/X" + coord + ".json");
												if (!isdbox)
												{
													Player::OnTalkBubble(peer, pData->netID, "`4An error occured while getting safe vault info.", 0, true);
													break;
												}

												bool contains_non_int3 = !std::regex_match(apos, std::regex("^[0-9]+$"));
												if (contains_non_int3 == true)
												{
													break;
												}

												bool contains_non_int4 = !std::regex_match(howMany, std::regex("^[0-9]+$"));
												if (contains_non_int4 == true)
												{
													Player::OnTalkBubble(peer, pData->netID, "Invalid input in amount!", 0, false);
													break;
												}
												howManyInt = atoi(howMany.c_str());

												aposInt = atoi(apos.c_str());

												if (howManyInt < 1 || howManyInt > 250)
												{
													Player::OnTalkBubble(peer, pData->netID, "Invalid input in amount!", 0, false);
													break;
												}



												ifstream ifff("save/storageboxlvl3/_" + pData->currentWorld + "/X" + coord + ".json");
												json j;
												ifff >> j;
												ifff.close();

												int itemid = 0;
												bool success = true;

												for (int i = 0; i < 20; i++)
												{
													if (j["storage"].at(i)["aposition"] == aposInt)
													{
														itemid = j["storage"].at(i)["itemid"];

														if (itemid == 0) break;

														if (howManyInt > j["storage"].at(i)["itemcount"])
														{
															Player::OnTextOverlay(peer, "`4Your Storage Box Xtreme - Level 3 does not contains such many.");
															break;
														}

														if (CheckItemExists(peer, j["storage"].at(i)["itemid"]))
														{
															int currentlyHave = GetQuantityOfItem(peer, j["storage"].at(i)["itemid"]);
															if (howManyInt + currentlyHave < 251)
															{
																SaveItemMoreTimes(j["storage"].at(i)["itemid"], howManyInt, peer, success, pData->rawName + " from Storage Box Xtreme - Level 3");
															}
															else
															{
																Player::OnTextOverlay(peer, "`4You Don't have enought space.");
																break;
															}
														}
														else
														{
															if (pData->inventory.items.size() == pData->currentInventorySize)
															{
																Player::OnTextOverlay(peer, "`4Your inventory is full! You can purchase an inventory upgrade in the shop.");
																break;
															}

															SaveItemMoreTimes(j["storage"].at(i)["itemid"], howManyInt, peer, success, pData->rawName + " from Storage Box Xtreme - Level 3");
														}

														Player::OnTalkBubble(peer, pData->netID, "`wRemoved " + to_string(howManyInt) + " " + itemDefs[itemid].name + " from the Storage Box Xtreme - Level 3", 0, true);
														if (isMod(peer) && !isWorldOwner(peer, world)) LogAccountActivity(pData->rawName, pData->rawName, "Removed " + to_string(howManyInt) + " " + itemDefs[itemid].name + " from Storage Box Xtreme - Level 3 (" + world->name + ")");

														if (j["storage"].at(i)["itemcount"] == howManyInt)
														{
															j["storage"].at(i)["itemid"] = 0;
															j["storage"].at(i)["placedby"] = "There was " + to_string(howManyInt) + " of " + to_string(itemid) + " item, and " + pData->rawName + " withdrawed them.";
															j["storage"].at(i)["itemcount"] = 0;
															j["instorage"] = j["instorage"].get<double>() - 1;
														}
														else
														{
															j["storage"].at(i)["itemcount"] = j["storage"].at(i)["itemcount"].get<double>() - howManyInt;
														}

														ofstream of("save/storageboxlvl3/_" + pData->currentWorld + "/X" + coord + ".json");
														of << j << std::endl;
														of.close();
														break;
													}
												}
											}
										}
									}
									catch (const std::out_of_range& e) {
										std::cout << e.what() << std::endl;
									}
								}
								if (btn == "boxlvl1_withdrawConfirm")
								{
									if (world == nullptr || pData->currentWorld == "EXIT" || serverIsFrozen) continue;
									try {
										std::stringstream bss(cch);
										std::string bto;

										string howMany = "";
										string apos = "";
										string coord = "";
										int aposInt = 0;
										int howManyInt = 0;

										while (std::getline(bss, bto, '\n'))
										{
											vector<string> infoDat = explode("|", bto);
											if (infoDat.at(0).substr(0, 16) == "boxlvl1withdraw_")
											{
												howMany = infoDat.at(1);
												if (howMany.size() > 5) break;

												string coord_and_apos = infoDat.at(0).erase(0, 16);
												string::size_type pos = coord_and_apos.find('_');
												if (pos != std::string::npos)
												{
													coord = coord_and_apos.substr(0, pos);
													coord_and_apos.erase(0, pos + 1);
													apos = coord_and_apos;
												}
												else
												{
													break;
												}
												auto isdbox = std::experimental::filesystem::exists("save/storageboxlvl1/_" + pData->currentWorld + "/X" + coord + ".json");
												if (!isdbox)
												{
													Player::OnTalkBubble(peer, pData->netID, "`4An error occured while getting safe vault info.", 0, true);
													break;
												}

												bool contains_non_int3 = !std::regex_match(apos, std::regex("^[0-9]+$"));
												if (contains_non_int3 == true)
												{
													break;
												}

												bool contains_non_int4 = !std::regex_match(howMany, std::regex("^[0-9]+$"));
												if (contains_non_int4 == true)
												{
													Player::OnTalkBubble(peer, pData->netID, "Invalid input in amount!", 0, false);
													break;
												}
												howManyInt = atoi(howMany.c_str());

												aposInt = atoi(apos.c_str());

												if (howManyInt < 1 || howManyInt > 250)
												{
													Player::OnTalkBubble(peer, pData->netID, "Invalid input in amount!", 0, false);
													break;
												}



												ifstream ifff("save/storageboxlvl1/_" + pData->currentWorld + "/X" + coord + ".json");
												json j;
												ifff >> j;
												ifff.close();

												int itemid = 0;
												bool success = true;

												for (int i = 0; i < 20; i++)
												{
													if (j["storage"].at(i)["aposition"] == aposInt)
													{
														itemid = j["storage"].at(i)["itemid"];

														if (itemid == 0) break;

														if (howManyInt > j["storage"].at(i)["itemcount"])
														{
															Player::OnTextOverlay(peer, "`4Your Storage Box Xtreme - Level 1 does not contains such many.");
															break;
														}

														if (CheckItemExists(peer, j["storage"].at(i)["itemid"]))
														{
															int currentlyHave = GetQuantityOfItem(peer, j["storage"].at(i)["itemid"]);
															if (howManyInt + currentlyHave < 251)
															{
																SaveItemMoreTimes(j["storage"].at(i)["itemid"], howManyInt, peer, success, pData->rawName + " from Storage Box Xtreme - Level 1");
															}
															else
															{
																Player::OnTextOverlay(peer, "`4You Don't have enought space.");
																break;
															}
														}
														else
														{
															if (pData->inventory.items.size() == pData->currentInventorySize)
															{
																Player::OnTextOverlay(peer, "`4Your inventory is full! You can purchase an inventory upgrade in the shop.");
																break;
															}
															SaveItemMoreTimes(j["storage"].at(i)["itemid"], howManyInt, peer, success, pData->rawName + " from Storage Box Xtreme - Level 1");
														}

														Player::OnTalkBubble(peer, pData->netID, "`wRemoved " + to_string(howManyInt) + " " + itemDefs[itemid].name + " from the Storage Box Xtreme - Level 1", 0, true);
														if (isMod(peer) && !isWorldOwner(peer, world)) LogAccountActivity(pData->rawName, pData->rawName, "Removed " + to_string(howManyInt) + " " + itemDefs[itemid].name + " from Storage Box Xtreme - Level 1 (" + world->name + ")");

														if (j["storage"].at(i)["itemcount"] == howManyInt)
														{
															j["storage"].at(i)["itemid"] = 0;
															j["storage"].at(i)["placedby"] = "There was " + to_string(howManyInt) + " of " + to_string(itemid) + " item, and " + pData->rawName + " withdrawed them.";
															j["storage"].at(i)["itemcount"] = 0;
															j["instorage"] = j["instorage"].get<double>() - 1;
														}
														else
														{
															j["storage"].at(i)["itemcount"] = j["storage"].at(i)["itemcount"].get<double>() - howManyInt;
														}

														ofstream of("save/storageboxlvl1/_" + pData->currentWorld + "/X" + coord + ".json");
														of << j << std::endl;
														of.close();
														break;
													}
												}
											}
										}
									}
									catch (const std::out_of_range& e) {
										std::cout << e.what() << std::endl;
									}
								}
								if (btn.substr(0, 21) == "safeBoxDepositedItem_")
								{
									if (world == nullptr || pData->currentWorld == "EXIT" || serverIsFrozen) continue;
									if (pData->rawName == PlayerDB::getProperName(world->owner) || world->owner == "" || isMod(peer))
									{
										try {
											string apos_and_coord = btn.erase(0, 21);
											string::size_type pos = apos_and_coord.find('_');
											string apos = "";
											string coord = "";

											if (pos != std::string::npos)
											{
												apos = apos_and_coord.substr(0, pos);
												apos_and_coord.erase(0, pos + 1);
												coord = apos_and_coord;
											}
											else
											{
												break;
											}
											auto isdbox = std::experimental::filesystem::exists("save/safevault/_" + pData->currentWorld + "/X" + coord + ".json");
											if (!isdbox)
											{
												Player::OnTalkBubble(peer, pData->netID, "`4An error occured while getting safe vault info.", 0, true);
												break;
											}

											bool contains_non_int3 = !std::regex_match(apos, std::regex("^[0-9]+$"));
											if (contains_non_int3 == true)
											{
												break;
											}



											ifstream ifff("save/safevault/_" + pData->currentWorld + "/X" + coord + ".json");
											json j;
											ifff >> j;
											ifff.close();

											int itemid = 0;
											int count = 0;
											for (int i = 0; i < 20; i++)
											{
												if (j["safe"].at(i)["aposition"] == atoi(apos.c_str()))
												{
													itemid = j["safe"].at(i)["itemid"];
													count = j["safe"].at(i)["itemcount"];
													GTDialog mySafe;
													mySafe.addLabelWithIcon("`wSafe Vault", 8878, LABEL_BIG);
													mySafe.addSmallText("`oYou have `w" + to_string(count) + " " + itemDefs[itemid].name + " `ostored.");
													mySafe.addSmallText("`oWithdraw how many?");
													mySafe.addInputBox("safewithdraw_" + coord + "_" + apos, "", to_string(count), 5);
													mySafe.addSpacer(SPACER_SMALL);
													mySafe.addQuickExit();
													mySafe.endDialog("safe_withdrawConfirm", "Remove items", "Exit");
													Player::OnDialogRequest(peer, mySafe.finishDialog());
													break;
												}
											}
										}
										catch (const std::out_of_range& e) {
											std::cout << e.what() << std::endl;
										}
									}
								}
								if (btn.substr(0, 29) == "saferecoverPasswordInConfirm_")
								{
									if (pData->rawName == PlayerDB::getProperName(world->owner) || world->owner == "" || isMod(peer))
									{
										if (world == nullptr || pData->currentWorld == "EXIT" || serverIsFrozen) continue;
										string coord = btn.substr(btn.find("_") + 1);
										auto isdbox = std::experimental::filesystem::exists("save/safevault/_" + pData->currentWorld + "/X" + coord + ".json");
										if (!isdbox)
										{
											Player::OnTalkBubble(peer, pData->netID, "`4An error occured. Break the safe.", 0, true);
											break;
										}
										GTDialog recover;
										recover.addLabelWithIcon("`wSafe Vault", 8878, LABEL_BIG);
										recover.addSmallText("Please enter recovery answer.");
										recover.addInputBox("saferecoveryanswer_" + coord, "", "", 12);
										recover.addButton("saferecoveryanswerconfirm", "Enter Recovery Answer");
										recover.addSpacer(SPACER_SMALL);
										recover.addQuickExit();
										recover.endDialog("Close", "", "Exit");
										Player::OnDialogRequest(peer, recover.finishDialog());
									}
								}
								if (btn == "saferecoveryanswerconfirm")
								{
									if (world == nullptr || pData->currentWorld == "EXIT" || serverIsFrozen) continue;
									try {
										std::stringstream bss(cch);
										std::string bto;

										string recoveryanswer = "";
										string coord = "";

										while (std::getline(bss, bto, '\n'))
										{
											vector<string> infoDat = explode("|", bto);
											if (infoDat.at(0).substr(0, 19) == "saferecoveryanswer_")
											{
												if (pData->rawName == PlayerDB::getProperName(world->owner) || world->owner == "" || isMod(peer))
												{
													recoveryanswer = infoDat.at(1);
													coord = infoDat.at(0).substr(19, infoDat.at(0).length() - 1).c_str();
													auto isdbox = std::experimental::filesystem::exists("save/safevault/_" + pData->currentWorld + "/X" + coord + ".json");
													if (!isdbox)
													{
														Player::OnTalkBubble(peer, pData->netID, "`4An error occured. Break the safe.", 0, true);
														break;
													}



													ifstream ifff("save/safevault/_" + pData->currentWorld + "/X" + coord + ".json");
													json j;
													ifff >> j;
													ifff.close();

													if (recoveryanswer != j["recovery"])
													{
														Player::OnTalkBubble(peer, pData->netID, "`4Recovery answer did not match!", 0, true);
														break;
													}

													j["password"] = "";
													j["recovery"] = "";
													ofstream of("save/safevault/_" + pData->currentWorld + "/X" + coord + ".json");
													of << j << std::endl;
													of.close();

													Player::OnTalkBubble(peer, pData->netID, "Your safe vault was `2Updated!", 0, true);
												}
											}
										}
									}
									catch (const std::out_of_range& e) {
										std::cout << e.what() << std::endl;
									}
								}
								if (btn == "safe_updatepassword")
								{
									if (world == nullptr || pData->currentWorld == "EXIT" || serverIsFrozen) continue;
									try {
										std::stringstream bss(cch);
										std::string bto;

										string inputoldpass = "";
										string coord = "";
										string newpass = "";
										string recans = "";

										while (std::getline(bss, bto, '\n'))
										{
											vector<string> infoDat = explode("|", bto);
											if (infoDat.at(0).substr(0, 16) == "safeoldpassword_")
											{
												if (pData->rawName == PlayerDB::getProperName(world->owner) || world->owner == "" || isMod(peer))
												{
													inputoldpass = infoDat.at(1);
													coord = infoDat.at(0).substr(16, infoDat.at(0).length() - 1).c_str();
													auto isdbox = std::experimental::filesystem::exists("save/safevault/_" + pData->currentWorld + "/X" + coord + ".json");
													if (!isdbox)
													{
														Player::OnTalkBubble(peer, pData->netID, "`4An error occured. Break the safe.", 0, true);
														break;
													}

													ifstream ifff("save/safevault/_" + pData->currentWorld + "/X" + coord + ".json");
													json j;
													ifff >> j;
													ifff.close();

													if (j["password"] != inputoldpass)
													{
														Player::OnTalkBubble(peer, pData->netID, "`4Old password did not match", 0, true);
														break;
													}
												}
											}
											if (infoDat.at(0) == "safe_newpassword")
											{
												if (pData->rawName == PlayerDB::getProperName(world->owner) || world->owner == "" || isMod(peer))
												{
													newpass = infoDat.at(1);
												}
											}
											if (infoDat.at(0) == "storage_recoveryanswer")
											{
												if (pData->rawName == PlayerDB::getProperName(world->owner) || world->owner == "" || isMod(peer))
												{
													recans = infoDat.at(1);
													ifstream ifff("save/safevault/_" + pData->currentWorld + "/X" + coord + ".json");
													json j;
													ifff >> j;
													ifff.close();

													j["password"] = newpass;
													j["recovery"] = recans;
													ofstream of("save/safevault/_" + pData->currentWorld + "/X" + coord + ".json");
													of << j << std::endl;
													of.close();

													Player::OnTalkBubble(peer, pData->netID, "Your safe vault was `2Updated!", 0, true);
												}
											}
										}
									}
									catch (const std::out_of_range& e) {
										std::cout << e.what() << std::endl;
									}
								}
								if (btn == "safe_removepassword")
								{
									if (world == nullptr || pData->currentWorld == "EXIT" || serverIsFrozen) continue;
									try {
										std::stringstream bss(cch);
										std::string bto;

										string inputoldpass = "";
										string coord = "";

										while (std::getline(bss, bto, '\n'))
										{
											vector<string> infoDat = explode("|", bto);
											if (infoDat.at(0).substr(0, 16) == "safeoldpassword_")
											{
												if (pData->rawName == PlayerDB::getProperName(world->owner) || world->owner == "" || isMod(peer))
												{
													inputoldpass = infoDat.at(1);
													coord = infoDat.at(0).substr(16, infoDat.at(0).length() - 1).c_str();
													auto isdbox = std::experimental::filesystem::exists("save/safevault/_" + pData->currentWorld + "/X" + coord + ".json");
													if (!isdbox)
													{
														Player::OnTalkBubble(peer, pData->netID, "`4An error occured. Break the safe.", 0, true);
														break;
													}



													ifstream ifff("save/safevault/_" + pData->currentWorld + "/X" + coord + ".json");
													json j;
													ifff >> j;
													ifff.close();

													if (j["password"] != inputoldpass)
													{
														Player::OnTalkBubble(peer, pData->netID, "`4Old password did not match", 0, true);
														break;
													}

													j["password"] = "";
													j["recovery"] = "";
													ofstream of("save/safevault/_" + pData->currentWorld + "/X" + coord + ".json");
													of << j << std::endl;
													of.close();

													Player::OnTalkBubble(peer, pData->netID, "Your safe vault is no longer `4Password Protected`o!", 0, true);
													if (isMod(peer) && !isWorldOwner(peer, world)) LogAccountActivity(pData->rawName, pData->rawName, "Disabled Safe Vault password protection (" + world->name + ")");
												}
											}
										}
									}
									catch (const std::out_of_range& e) {
										std::cout << e.what() << std::endl;
									}
								}
								if (btn == "safe_setpassword")
								{
									if (world == nullptr || pData->currentWorld == "EXIT" || serverIsFrozen) continue;
									try {
										std::stringstream bss(cch);
										std::string bto;

										string inputnewpass = "";
										string coord = "";
										string inputnewrecoveryans = "";

										while (std::getline(bss, bto, '\n'))
										{
											vector<string> infoDat = explode("|", bto);
											if (infoDat.at(0).substr(0, 12) == "safenewpass_")
											{
												if (pData->rawName == PlayerDB::getProperName(world->owner) || world->owner == "" || isMod(peer))
												{
													inputnewpass = infoDat.at(1);
													coord = infoDat.at(0).substr(12, infoDat.at(0).length() - 1).c_str();
													auto isdbox = std::experimental::filesystem::exists("save/safevault/_" + pData->currentWorld + "/X" + coord + ".json");
													if (!isdbox)
													{
														Player::OnTalkBubble(peer, pData->netID, "`4An error occured. Break the safe.", 0, true);
														break;
													}

													if (inputnewpass.size() < 2)
													{
														Player::OnTalkBubble(peer, pData->netID, "`4Your password is too easy.", 0, true);
														break;
													}
												}
											}
											if (infoDat.at(0) == "safe_recoverypass")
											{
												if (pData->rawName == PlayerDB::getProperName(world->owner) || world->owner == "" || isMod(peer))
												{
													inputnewrecoveryans = infoDat.at(1);

													if (inputnewpass.size() < 2)
													{
														Player::OnTalkBubble(peer, pData->netID, "`4Your recovery answer is too easy.", 0, true);
														break;
													}
													ifstream ifff("save/safevault/_" + pData->currentWorld + "/X" + coord + ".json");
													json j;
													ifff >> j;
													ifff.close();
													j["password"] = inputnewpass;
													j["recovery"] = inputnewrecoveryans;

													ofstream of("save/safevault/_" + pData->currentWorld + "/X" + coord + ".json");
													of << j << std::endl;
													of.close();

													Player::OnTalkBubble(peer, pData->netID, "Your safe vault is now `2Password Protected`o!", 0, true);
													if (isMod(peer) && !isWorldOwner(peer, world)) LogAccountActivity(pData->rawName, pData->rawName, "Changed Safe Vault password to " + inputnewpass + " and recovery answer to " + inputnewrecoveryans + " (" + world->name + ")");
												}
											}
										}
									}
									catch (const std::out_of_range& e) {
										std::cout << e.what() << std::endl;
									}
								}
								if (btn == "safe_confirmpass")
								{
									if (world == nullptr || pData->currentWorld == "EXIT" || serverIsFrozen) continue;
									try {
										std::stringstream bss(cch);
										std::string bto;

										string inputpass = "";

										while (std::getline(bss, bto, '\n'))
										{
											vector<string> infoDat = explode("|", bto);
											if (infoDat.at(0).substr(0, 21) == "safeconfirmpassInput_")
											{
												inputpass = infoDat.at(1);
												if (pData->rawName == PlayerDB::getProperName(world->owner) || world->owner == "" || isMod(peer))
												{
													string coord = infoDat.at(0).substr(21, infoDat.at(0).length() - 1).c_str();
													auto isdbox = std::experimental::filesystem::exists("save/safevault/_" + pData->currentWorld + "/X" + coord + ".json");
													if (!isdbox)
													{
														Player::OnTalkBubble(peer, pData->netID, "`4An error occured. Break the safe.", 0, true);
														break;
													}

													ifstream ifff("save/safevault/_" + pData->currentWorld + "/X" + coord + ".json");
													json j;
													ifff >> j;
													ifff.close();
													string basic_string = j["password"];
													if (inputpass != basic_string)
													{
														Player::OnTalkBubble(peer, pData->netID, "`4Password did not match", 0, true);
														break;
													}
													int stored = j["insafe"];

													Player::OnTalkBubble(peer, pData->netID, "`2Password matched", 0, true);

													GTDialog mySafe;
													mySafe.addLabelWithIcon("`wSafe Vault", 8878, LABEL_BIG);

													if (stored > 0)
													{
														mySafe.addSpacer(SPACER_SMALL);
													}

													int count = 0;
													int id = 0;
													int aposition = 0;
													for (int i = 0; i < 20; i++)
													{
														if (j["safe"].at(i)["itemid"] != 0)
														{
															count = j["safe"].at(i)["itemcount"];
															id = j["safe"].at(i)["itemid"];
															aposition = j["safe"].at(i)["aposition"];

															if (i % 6 == 0 && i != 0)
															{
																mySafe.addStaticBlueFrameWithIdCountText(to_string(id), to_string(count), getItemDef(id).name, "safeBoxDepositedItem_" + to_string(aposition) + "_" + coord, true);
															}
															else
															{
																mySafe.addStaticBlueFrameWithIdCountText(to_string(id), to_string(count), getItemDef(id).name, "safeBoxDepositedItem_" + to_string(aposition) + "_" + coord, false);
															}
														}
													}

													if (stored > 0)
													{
														mySafe.addNewLineAfterFrame();
													}

													mySafe.addSmallText("`w" + to_string(stored) + "/20 `$items stored.");
													mySafe.addSpacer(SPACER_SMALL);
													mySafe.addPicker("safedeposit_" + coord, "Deposit item", "Select an item");
													if (j["password"] == "")
													{
														mySafe.addSmallText("`$This Safe Vault is not `4password protected`$!");
													}
													else
													{
														mySafe.addSmallText("`$This Safe Vault is `2password protected`$!");
													}
													mySafe.addSpacer(SPACER_SMALL);
													mySafe.addSmallText("`$Change your password.");
													mySafe.addButton("safeupdatepass_" + coord, "Update Password");

													mySafe.addSpacer(SPACER_SMALL);
													mySafe.addQuickExit();
													mySafe.endDialog("Close", "", "Exit");
													Player::OnDialogRequest(peer, mySafe.finishDialog());
													break;
												}
											}
										}
									}
									catch (const std::out_of_range& e) {
										std::cout << e.what() << std::endl;
									}
								}
								if (btn == "pickupdisplayitem")
								{
									if (world == nullptr || pData->currentWorld == "EXIT" || serverIsFrozen) continue;
									if (pData->rawName == world->owner || world->owner == "")
									{
										try {
											short dfg = pData->displayfg;
											short dbg = pData->displaybg;
											int x = pData->displaypunchx;
											int y = pData->displaypunchy;
											pData->displayfg = 0;
											pData->displaybg = 0;
											pData->displaypunchx = 0;
											pData->displaypunchy = 0;
											if (world->items.at(x + (y * world->width)).intdata != 0)
											{
												Player::OnTalkBubble(peer, pData->netID, "`wYou removed `5" + getItemDef(world->items.at(x + (y * world->width)).intdata).name + " `wfrom the Display Block.", 0, true);
												bool success = true;
												SaveItemMoreTimes(world->items.at(x + (y * world->width)).intdata, 1, peer, success, pData->rawName + " from Display Block");
												world->items.at(x + (y * world->width)).intdata = 0;
												ENetPeer* currentPeer;
												for (currentPeer = server->peers;
													currentPeer < &server->peers[server->peerCount];
													++currentPeer)
												{
													if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
														continue;
													if (isHere(peer, currentPeer))
													{
														UpdateVisualsForBlock(currentPeer, true, x, y, world);
													}
												}
												if (isMod(peer) && !isWorldOwner(peer, world)) LogAccountActivity(pData->rawName, pData->rawName, "Pickup " + getItemDef(world->items.at(x + (y * world->width)).intdata).name + " from " + getItemDef(world->items.at(x + (y * world->width)).foreground).name + " (" + world->name + ")");
											}
											else
											{
												Player::OnTalkBubble(peer, pData->netID, "Error occured while trying to remove item!", 0, true);
												continue;
											}
										}
										catch (const std::out_of_range& e) {
											std::cout << e.what() << std::endl;
										}
									}
								}
								if (btn == "WorldDropPickup") {
									if (world == nullptr || pData->currentWorld == "EXIT" || serverIsFrozen) continue;
									if (pData->rawName == world->owner || isMod(peer)) {
										if (!world->DisableDrop) {
											world->DisableDrop = true;
											Player::OnConsoleMessage(peer, "`oVisitors can no longer collect dropped items!");
											for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
												if (pData->rawName == world->owner) continue;
												if (pData->currentWorld != "EXIT") {
													if (pData->rawName != static_cast<PlayerInfo*>(currentPeer->data)->rawName && pData->currentWorld == static_cast<PlayerInfo*>(currentPeer->data)->currentWorld) {
														Player::OnConsoleMessage(currentPeer, "`oOwner has disabled ability to collect dropped items!");
													}
												}
											}
											if (isMod(peer) && !isWorldOwner(peer, world)) LogAccountActivity(pData->rawName, pData->rawName, "Disabled ability to collect dropped items (" + world->name + ")");
										} else {
											world->DisableDrop = false;
											Player::OnConsoleMessage(peer, "`oVisitors can again collect dropped items!");
											for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
												if (pData->rawName == world->owner) continue;
												if (pData->currentWorld != "EXIT") {
													if (pData->rawName != static_cast<PlayerInfo*>(currentPeer->data)->rawName && pData->currentWorld == static_cast<PlayerInfo*>(currentPeer->data)->currentWorld) {
														Player::OnConsoleMessage(currentPeer, "`oOwner has enabled ability to collect dropped items!");
													}
												}
											}
											if (isMod(peer) && !isWorldOwner(peer, world)) LogAccountActivity(pData->rawName, pData->rawName, "Enabled ability to collect dropped items (" + world->name + ")");
										}
									}
								}
								if (btn == "getremote") {
									if (world == nullptr || pData->currentWorld == "EXIT" || serverIsFrozen) continue;
									try {
										int x = pData->lastPunchX;
										int y = pData->lastPunchY;
										bool canuseremote = true;
										if (canuseremote) {
											if (pData->inventory.items.size() == pData->currentInventorySize) {
												Player::OnTalkBubble(peer, pData->netID, "`wInventory is full!", 0, true);
												continue;
											}
											bool iscontainss = false;
											SearchInventoryItem(peer, 5640, 1, iscontainss);
											if (!iscontainss) {
												if (isWorldOwner(peer, world) && world->items.at(x + (y * world->width)).mid != 0 && world->items.at(x + (y * world->width)).mc != 0 || world->items.at(x + (y * world->width)).rm && world->items.at(x + (y * world->width)).mid != 0 && world->items.at(x + (y * world->width)).mc != 0) {
													Player::OnTalkBubble(peer, pData->netID, "`wYou received a MAGPLANT 5000 Remote.", 0, true);
													bool success = true;
													SaveItemMoreTimes(5640, 1, peer, success, pData->rawName + " from MAGPLANT 5000");
													pData->magplantitemid = world->items.at(x + (y * world->width)).mid;
													pData->magplantx = x;
													pData->magplanty = y;
												}
											}
											else {
												pData->magplantitemid = world->items.at(x + (y * world->width)).mid;
												pData->magplantx = x;
												pData->magplanty = y;
												Player::OnTalkBubble(peer, pData->netID, "`wYou received a MAGPLANT 5000 Remote.", 0, true);
											}
										}
									}
									catch (const std::out_of_range& e) {
										std::cout << e.what() << std::endl;
									}
								}
								if (btn == "retrieveitem") {
									if (world == nullptr || pData->currentWorld == "EXIT" || serverIsFrozen) continue;
									if (pData->rawName != world->owner && !isMod(peer)) continue;
									try {
										int x = pData->lastPunchX;
										int y = pData->lastPunchY;
										int suckerid = pData->suckerid;
										string suckername = pData->suckername;
										if (world->items.at(x + (y * world->width)).mid == 112) {
											bool iscontainss = false;
											SearchInventoryItem(peer, 5640, 1, iscontainss);
											if (iscontainss) {
												pData->magplantitemid = 0;
												RemoveInventoryItem(5640, 1, peer, true);
											}
											int currentgems = 0;
											ifstream fs("save/gemdb/_" + pData->rawName + ".txt");
											fs >> currentgems;
											fs.close();
											currentgems += world->items.at(x + (y * world->width)).mc;
											Player::OnSetBux(peer, currentgems, 0);
											ofstream of("save/gemdb/_" + pData->rawName + ".txt");
											of << currentgems;
											of.close();
											Player::OnTalkBubble(peer, pData->netID, "`oCollected `2" + to_string(world->items.at(x + (y * world->width)).mc) + " `5" + getItemDef(world->items.at(x + (y * world->width)).mid).name + " `oFrom the " + getItemDef(suckerid).name + "!", 0, true);
											for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
												if (isHere(peer, currentPeer)) {
													send_item_sucker(currentPeer, suckerid, x, y, world->items.at(x + (y * world->width)).mid, 0, true, true, world->items.at(x + (y * world->width)).background);
												}
											}
											if (isMod(peer) && !isWorldOwner(peer, world)) LogAccountActivity(pData->rawName, pData->rawName, "Collected " + to_string(world->items.at(x + (y * world->width)).mc) + " " + getItemDef(world->items.at(x + (y * world->width)).mid).name + " from " + getItemDef(world->items.at(x + (y * world->width)).foreground).name + " (" + world->name + ")");
											world->items.at(x + (y * world->width)).mc = 0;
											continue;
										}
										if (world->items.at(x + (y * world->width)).mc > 250) {
											if (CheckItemMaxed(peer, world->items.at(x + (y * world->width)).mid, 250)) {
												Player::OnTalkBubble(peer, pData->netID, "`wI dont have a free space to pickup `2250 `$" + getItemDef(world->items.at(x + (y * world->width)).mid).name + "`w!", 0, true);
												continue;
											}
											else {
												world->items.at(x + (y * world->width)).mc -= 250;
												bool success = true;
												SaveItemMoreTimes(world->items.at(x + (y * world->width)).mid, 250, peer, success, pData->rawName + " withdraw from MAGPLANT 5000");
												Player::OnTalkBubble(peer, pData->netID, "`oCollected `2250 `5" + getItemDef(world->items.at(x + (y * world->width)).mid).name + " `oFrom the " + getItemDef(suckerid).name + "!", 0, true);
												ENetPeer* currentPeer;
												for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
													if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
													if (isHere(peer, currentPeer)) {
														send_item_sucker(currentPeer, suckerid, x, y, world->items.at(x + (y * world->width)).mid, 1, true, true, world->items.at(x + (y * world->width)).background);
													}
												}
												if (isMod(peer) && !isWorldOwner(peer, world)) LogAccountActivity(pData->rawName, pData->rawName, "Collected 250 " + getItemDef(world->items.at(x + (y * world->width)).mid).name + " from " + getItemDef(world->items.at(x + (y * world->width)).foreground).name + " (" + world->name + ")");
											}
										}
										else {
											if (CheckItemMaxed(peer, world->items.at(x + (y * world->width)).mid, world->items.at(x + (y * world->width)).mc)) {
												Player::OnTalkBubble(peer, pData->netID, "`wI dont have a free space to pickup `2" + to_string(world->items.at(x + (y * world->width)).mc) + " `$" + getItemDef(world->items.at(x + (y * world->width)).mid).name + "`w!", 0, true);
												continue;
											}
											else {
												bool iscontainss = false;
												SearchInventoryItem(peer, 5640, 1, iscontainss);
												if (iscontainss) {
													pData->magplantitemid = 0;
													RemoveInventoryItem(5640, 1, peer, true);
												}
												bool success = true;
												SaveItemMoreTimes(world->items.at(x + (y * world->width)).mid, world->items.at(x + (y * world->width)).mc, peer, success, pData->rawName + " withdraw from MAGPLANT 5000");
												Player::OnTalkBubble(peer, pData->netID, "`oCollected `2" + to_string(world->items.at(x + (y * world->width)).mc) + " `5" + getItemDef(world->items.at(x + (y * world->width)).mid).name + " `oFrom the " + getItemDef(suckerid).name + "!", 0, true);
												ENetPeer* currentPeer;
												for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
													if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
													if (isHere(peer, currentPeer)) {
														send_item_sucker(currentPeer, suckerid, x, y, world->items.at(x + (y * world->width)).mid, 0, true, true, world->items.at(x + (y * world->width)).background);
													}
												}
												if (isMod(peer) && !isWorldOwner(peer, world)) LogAccountActivity(pData->rawName, pData->rawName, "Collected " + to_string(world->items.at(x + (y * world->width)).mc) + " " + getItemDef(world->items.at(x + (y * world->width)).mid).name + " from " + getItemDef(world->items.at(x + (y * world->width)).foreground).name + " (" + world->name + ")");
												world->items.at(x + (y * world->width)).mc = 0;
											}
										}
									}
									catch (const std::out_of_range& e) {
										std::cout << e.what() << std::endl;
									}
								}	
								if (btn.substr(0, 17) == "showuseractivity_") {
									if (!isMod(peer)) continue;
									string user = btn.substr(17, cch.length() - 17 - 1);
									try {
										ifstream read_player("save/players/_" + user + ".json");
										if (!read_player.is_open()) {
											Player::OnConsoleMessage(peer, user + " does not exist");
											continue;
										}	
										json j;
										read_player >> j;
										read_player.close();
										string username = j["username"];
										string accountnotes = j["accountnotes"];
									} catch (std::exception& e) {
										std::cout << e.what() << std::endl;
										continue;
									}	
								}	
								if (btn.substr(0, 25) == "showuserinventoryoffline_") {
									if (!isMod(peer)) continue;
									string user = btn.substr(25, cch.length() - 25 - 1);
									try {
										ifstream read_player("save/players/_" + user + ".json");
										if (!read_player.is_open()) {
											Player::OnConsoleMessage(peer, user + " does not exist");
											continue;
										}	
										json j;
										read_player >> j;
										read_player.close();
										string username = j["username"];
										int inventorysize = j["inventorysize"];
										json inventory = j["inventory"];
										string appendItems = "";
										int itemid = 0;
										int itemCount = 0;
										for (int i = 0; i < inventorysize; i++) {
											itemid = inventory["items"].at(i)["itemid"];
											itemCount = inventory["items"].at(i)["quantity"];
											if (itemid == 0) continue;
											if (i % 6 == 0 && i != 0) {
												appendItems += "\nadd_button_with_icon||END_LIST|noflags|0|0|\nadd_button_with_icon|||staticBlueFrame|" + to_string(itemid) + "|" + to_string(itemCount) + "|";
											} else {
												appendItems += "\nadd_button_with_icon|||staticBlueFrame|" + to_string(itemid) + "|" + to_string(itemCount) + "|";
											}
										}
										Player::OnDialogRequest(peer, "set_default_color|\nadd_label|mid|`wViewing " + username + " `winventory|right|\nadd_spacer|small|" + appendItems + "|\nadd_button_with_icon||END_LIST|noflags|0|0|\nadd_button|punishview|Back|");
									} catch (std::exception& e) {
										std::cout << e.what() << std::endl;
									} catch (const std::out_of_range& e) {
										std::cout << e.what() << std::endl;
									}
								}
								if (btn == "warptosb")
								{
									if (pData->currentWorld == "EXIT")
									{
										continue;
									}
									if (pData->isCursed == true)
									{
										GamePacket p0 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`4You are cursed now!"));
										ENetPacket* packet0 = enet_packet_create(p0.data,
											p0.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet0);
										delete p0.data;
										continue;
									}
									string act = pData->lastSdbWorld;
									if (act == "")
									{
										GamePacket po = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "Unable to track down the location of the broadcast."));
										ENetPacket* packet = enet_packet_create(po.data,
											po.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);
									}
									else if (act == pData->currentWorld)
									{
										GamePacket po = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "Sorry, but you are already in the world!"));
										ENetPacket* packet = enet_packet_create(po.data,
											po.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);
									}
									else
									{
										handle_world(peer, act);
									}
								}
								if (btn == "inviteguildbutton") {
									if (((PlayerInfo*)(peer->data))->currentWorld == "EXIT") continue;
									std::ifstream ifff("save/guilds/_" + PlayerDB::getProperName(static_cast<PlayerInfo*>(peer->data)->guild) + ".json");
									if (ifff.fail()) {
										ifff.close();
										continue;
									}
									if (ifff.is_open()) {
									}
									json j;
									ifff >> j; //load
									vector<string> GE;
									vector<string> GC;
									for (int i = 0; i < j["Elder-Leader"].size(); i++) {
										GE.push_back(j["Elder-Leader"][i]);
									}
									for (int i = 0; i < j["Co-Leader"].size(); i++) {
										GC.push_back(j["Co-Leader"][i]);
									}

									if (((PlayerInfo*)(peer->data))->guild != "" && find(GE.begin(), GE.end(), static_cast<PlayerInfo*>(peer->data)->rawName) != GE.end() || find(GC.begin(), GC.end(), static_cast<PlayerInfo*>(peer->data)->rawName) != GC.end() || ((PlayerInfo*)(peer->data))->rawName == ((PlayerInfo*)(peer->data))->guildLeader) {
										int number = ((PlayerInfo*)(peer->data))->guildmatelist.size();
										if (number > 24) {
											Player::OnConsoleMessage(peer, "`3GUILD ERROR: `oYou already have `425 `oMembers! Please remove some before adding new ones!");
											continue;
										}
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
											if (isHere(peer, currentPeer)) {
												if (((PlayerInfo*)(currentPeer->data))->rawName == ((PlayerInfo*)(peer->data))->lastInfo) {
													string name = ((PlayerInfo*)(currentPeer->data))->rawName;
													if (((PlayerInfo*)(currentPeer->data))->guild != "") {
														Player::OnConsoleMessage(peer, "`3GUILD ERROR: `w" + ((PlayerInfo*)(currentPeer->data))->displayName + "`o is already in a Guild!");
													}
													else {
														Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "`5[`wGuild request sent to `2" + ((PlayerInfo*)(currentPeer->data))->displayName + "`5]", 0, true);
														string text = "action|play_sfx\nfile|audio/tip_start.wav\ndelayMS|0\n";
														sendSound(currentPeer, "tip_start.wav");
														((PlayerInfo*)(currentPeer->data))->guildlast = ((PlayerInfo*)(peer->data))->guild;
														((PlayerInfo*)(currentPeer->data))->isinvited = true;
														Player::OnConsoleMessage(currentPeer, "`5[GUILD REQUEST] `oYou've been invited to join `2" + ((PlayerInfo*)(peer->data))->guild + "`o by `w" + ((PlayerInfo*)(peer->data))->displayName + "`o! To accept, `wwrench yourself `oand then choose `2Join " + ((PlayerInfo*)(peer->data))->guild + "`o.");
													}
												}
											}
										}
									}
									else {
										Player::OnConsoleMessage(peer, "`5[GUILD ERROR] `oYou must be in a Guild as a Elder or higher in order to invite players!");
										continue;
									}
								}
								if (btn == "manage_audio") {
									Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label|big|Select a song|right|\nadd_label|small|Just a quick note there none of these songs are owned by us they are suggested by server players and were added by the developer's Once you start playing song there is no way to stop it!|left|\nadd_spacer|small|\nadd_checkbox|checkbox_ahrix|Ahrix Nova (Ahrix)|0|\nadd_checkbox|checkbox_phut|Axel Johansson - Miracles|0|\nadd_checkbox|checkbox_stopme|Don't stop me now (QUEEN)|0|\nadd_checkbox|checkbox_feelit|Can you feel it (NCS)|0|\nadd_checkbox|checkbox_sayso|Say So! (MEP)|0|\nadd_checkbox|checkbox_bealone|Never be alone (Cursed Sheep)|0|\nadd_button|Cancel|Play|noflags|0|0|\nend_dialog|song_edit||");
								}
								if (btn == "change_password")
								{
									Player::OnDialogRequest(peer, "set_default_color|`o\n\nadd_label_with_icon|big|`oChange your password``|left|32|\nadd_textbox|`oEnter your old password, then enter a new password and confirm your new password. Your GrowID will be updated automatically, please remember `$not to share `oyour password, if you do so there is no way to recover lost data`o!|\nadd_spacer|small|\nadd_text_input|current_password|`$Current Password``||32|\nadd_text_input|new_password|`$New Password``||32|\nadd_text_input|confirm_new_password|`$Confirm New Password``||32|\nend_dialog|password_change|Cancel|Update|");
								}
								if (btn == "billboardchange") {
									SendBillBoard(peer);
								}
								if (btn == "manage_title") {
									string titlecreatedialog = "", bluenametitle = "", titles = "No Titles Obtained", ltitle = "";
									bool iscontains = false;
									if (pData->level >= 125) {
										titles = "Viewing your titles";
										if (pData->bluenametitle) {
											bluenametitle += "\nadd_checkbox|blue_name|Blue name title|1";
										} else {
											bluenametitle += "\nadd_checkbox|blue_name|Blue name title|0";
										}
									} if (pData->ltitleunlocked == true) {
										titles = "Viewing your titles";
										if (pData->ltitle) {
											ltitle += "\nadd_checkbox|legendary_title|Legendary title|1";
										}
										else {
											ltitle += "\nadd_checkbox|legendary_title|Legendary title|0";
										}
									} if (pData->Subscriber) {
										titlecreatedialog = "\nadd_button|edit_title|`oEdit Title``|";
									}
									Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label|big|" + titles + "|right|\nadd_spacer|small|" + bluenametitle + ltitle + titlecreatedialog + "\nadd_button||OK|noflags|0|0|\nend_dialog|title_edit||");
								}
								if (btn == "notebook_edit")
								{
									int notebooksize = pData->notebook.size();
									Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label|big|Edit Notebook (" + to_string(notebooksize) + "/70)|left|0|\nadd_text_box_input|personal_note||" + pData->notebook + "|128|5|\nadd_spacer|small|\nadd_button|save|Save|noflags|0|0|\nadd_button|notebook_clear|Clear|noflags|0|0|\nadd_button|cancel|Cancel|noflags|0|0|\nend_dialog|notebook_edit||\nadd_quick_exit|");
								}
								if (btn == "worlds_view") {
									try {
										std::sort(pData->worldsowned.begin(), pData->worldsowned.end());
										auto it = std::unique(pData->worldsowned.begin(), pData->worldsowned.end());
										pData->worldsowned.erase(it, pData->worldsowned.end());
										string worlds_owned = "";
										for (int i = 0; i < pData->worldsowned.size(); i++) {
											if (i == pData->worldsowned.size() - 1) {
												worlds_owned += pData->worldsowned.at(i) + "";
											}
											else {
												worlds_owned += pData->worldsowned.at(i) + ", ";
											}
										}
										if (worlds_owned == "") worlds_owned = "You dont have any worlds locked!";
										Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label|big|Worlds Locked|right\nadd_spacer|small|\nadd_textbox|" + worlds_owned + "``|left|\nadd_spacer|small|\nadd_button||Close|noflags|0|0|\nend_dialog|my_worlds||");
									}
									catch (const std::out_of_range& e) {
										std::cout << e.what() << std::endl;
									}
								}
								if (btn == "notebook_clear") {
									if (!pData->haveGrowId) continue;
									pData->notebook = "";
									Player::OnTalkBubble(peer, pData->netID, "`2Text cleared.", 0, true);
								}
								if (btn == "joinguild") {
									if (((PlayerInfo*)(peer->data))->currentWorld == "EXIT") {
										continue;
									}
									vector<string> gmembers;
									string guildname = PlayerDB::getProperName(((PlayerInfo*)(peer->data))->guildlast);
									if (guildname != "") {
										try {
											std::ifstream ifff("save/guilds/_" + guildname + ".json");
											if (ifff.fail()) {
												ifff.close();
												continue;
											}
											json j;
											ifff >> j;
											int glevel;
											glevel = j["GuildLevel"];
											for (int i = 0; i < j["Member"].size(); i++) {
												gmembers.push_back(j["Member"][i]);
											}
											ifff.close();
											int membercount = gmembers.size();
											int maxmembers = 15;
											if (glevel == 2) maxmembers = 20;
											else if (glevel == 3) maxmembers = 25;
											else if (glevel == 4) maxmembers = 30;
											else if (glevel == 5) maxmembers = 35;
											else if (glevel == 6) maxmembers = 40;
											else if (glevel == 7) maxmembers = 45;
											else if (glevel == 8) maxmembers = 50;
											if (membercount >= maxmembers) {
												Player::OnConsoleMessage(peer, "`5[GUILD ALERT] `oThat guild is already full!");
												continue;
											}
											else {
												((PlayerInfo*)(peer->data))->guild = ((PlayerInfo*)(peer->data))->guildlast;
												((PlayerInfo*)(peer->data))->guildlast = "";
												((PlayerInfo*)(peer->data))->isinvited = false;
												((PlayerInfo*)(peer->data))->joinguild = true;
												updateInvis(peer);
												std::ifstream ifff("save/guilds/_" + PlayerDB::getProperName(((PlayerInfo*)(peer->data))->guild) + ".json");
												if (ifff.fail()) {
													ifff.close();
													Player::OnConsoleMessage(peer, "`4Error: `oGuild does not exist! If you are seeing this message, please take a screenshot and send it to a developer!");
													continue;
												}
												if (ifff.is_open()) {
												}
												json j;
												ifff >> j; //load
												vector<string> gmlist;
												for (int i = 0; i < j["Member"].size(); i++) {
													gmlist.push_back(j["Member"][i]);
												}
												gmlist.push_back(((PlayerInfo*)(peer->data))->rawName);
												j["Member"] = gmlist; //edit
												std::ofstream o("save/guilds/_" + PlayerDB::getProperName(((PlayerInfo*)(peer->data))->guild) + ".json"); //save
												if (!o.is_open()) continue;
												o << j << std::endl;
												ifstream fg("save/players/_" + ((PlayerInfo*)(peer->data))->rawName + ".json");
												json j2;
												fg >> j2;
												fg.close();
												j2["guild"] = ((PlayerInfo*)(peer->data))->guild;
												j2["joinguild"] = true;
												ofstream fs("save/players/_" + ((PlayerInfo*)(peer->data))->rawName + ".json");
												fs << j2;
												fs.close();
												for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
													if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
													if (((PlayerInfo*)(currentPeer->data))->guild == ((PlayerInfo*)(peer->data))->guild) {
														std::ifstream ifff("save/guilds/_" + ((PlayerInfo*)(peer->data))->guild + ".json");
														if (ifff.fail()) {
															ifff.close();
															continue;
														}
														json j;
														ifff >> j;
														int gfbg, gffg;
														gfbg = j["backgroundflag"];
														gffg = j["foregroundflag"];
														((PlayerInfo*)(peer->data))->guildFg = gffg;
														((PlayerInfo*)(peer->data))->guildBg = gfbg;
														updateGuild(peer);
														updateGuild(currentPeer);
														Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`0You successfully joined guild `2" + ((PlayerInfo*)(currentPeer->data))->guild + "!", 0, true);
														Player::OnConsoleMessage(currentPeer, "`5[GUILD ALERT] `2" + ((PlayerInfo*)(peer->data))->displayName + " `ojoined the guild!");
														updateInvis(peer);
													}
												}
											}
										}
										catch (std::exception&) {
											SendConsole("joinguild Critical error details: rawName(" + ((PlayerInfo*)(peer->data))->rawName + ")", "ERROR");
											enet_peer_disconnect_now(peer, 0);
										}
										catch (std::runtime_error&) {
											SendConsole("joinguild Critical error details: name(" + ((PlayerInfo*)(peer->data))->rawName + ")", "ERROR");
											enet_peer_disconnect_now(peer, 0);
										}
										catch (...) {
											SendConsole("joinguild Critical error details: name(" + ((PlayerInfo*)(peer->data))->rawName + ")", "ERROR");
											enet_peer_disconnect_now(peer, 0);
										}
									}
								}
								if (btn == "createguildinfo") {
									Player::OnDialogRequest(peer, "set_default_color|`o\n\nadd_label_with_icon|big|`wGrow Guild|left|5814||\nadd_textbox|`oWelcome to Grow Guilds where you can create a Guild! With a Guild you can compete in Guild Leaderboards to earn rewards and level up the Guild to add more members.|left|\nadd_spacer|small|\nadd_textbox|`oTo create a Guild you must either be a `2Supporter `oor `2Super Supporter`o.|left|\nadd_textbox|`oThe cost for `2Supporters `ois: `6200.000 `oGems.|left|\nadd_spacer|small|\nadd_textbox|`oYou will be charged: `6200.000 `oGems.|left|\nadd_spacer|small|\nadd_textbox|`6Caution`o: A guild can only be created in a world owned by you and locked with a `5World Lock`o!|left|\nadd_spacer|small|`\nadd_button|createguild|`oCreate a Guild``|0|0|\nadd_button|SocialPortal|Back|0|0|\nend_dialog||Close||");
								}
								if (btn == "createguild") {
									Player::OnDialogRequest(peer, "set_default_color|`o\n\nadd_label_with_icon|big|`wGrow Guild Creation``|left|5814|\nadd_spacer|small|\nadd_text_input|gname|Guild Name: ||20|\nadd_text_input|gstatement|Guild Statement: ||100|\nadd_text_input|ggcflagbg|`oGuild Flag Background ID:``||5|\nadd_text_input|ggcflagfg|`oGuild Flag Foreground ID:``||5|\nadd_spacer|small|\nadd_textbox|`oConfirm your guild settings by selecting `2Create Guild `obelow to create guild.|left|\nadd_textbox|`6Remember`o: A guild can be created in a world owned by you and locked with a `5World Lock`o!|left|\nadd_spacer|small|\nadd_textbox|`4Warning! `oThe guild name cannot be changed once you have confirmed the guild settings!|left|\nadd_spacer|small|\nadd_button|guildconfirm|`oCreate Guild|\nend_dialog|Cancel||");
								}
								if (btn == "showguild") {
									if (((PlayerInfo*)(peer->data))->currentWorld == "EXIT") {
										continue;
									}
									string onlinegmlist = "";
									int onlinecount = 0;
									string guildname = PlayerDB::getProperName(((PlayerInfo*)(peer->data))->guild);
									if (guildname != "") {
										try {
											std::ifstream ifff("save/guilds/_" + guildname + ".json");
											if (ifff.fail()) {
												ifff.close();
												((PlayerInfo*)(peer->data))->guild = "";
												continue;
											}
											json j;
											ifff >> j;
											int gfbg, gffg, guildlvl, guildxp;
											string gstatement, gleader;
											vector<string> gmembers;
											gfbg = j["backgroundflag"];
											gffg = j["foregroundflag"];
											gstatement = j["GuildStatement"].get<std::string>();
											gleader = j["Leader"].get<std::string>();
											guildlvl = j["GuildLevel"];
											guildxp = j["GuildExp"];
											for (int i = 0; i < j["Member"].size(); i++) {
												gmembers.push_back(j["Member"][i]);
											}
											((PlayerInfo*)(peer->data))->guildlevel = guildlvl;
											((PlayerInfo*)(peer->data))->guildexp = guildxp;
											((PlayerInfo*)(peer->data))->guildBg = gfbg;
											((PlayerInfo*)(peer->data))->guildFg = gffg;
											((PlayerInfo*)(peer->data))->guildStatement = gstatement;
											((PlayerInfo*)(peer->data))->guildLeader = gleader;
											((PlayerInfo*)(peer->data))->guildMembers = gmembers;
											ifff.close();
										}
										catch (std::exception&) {
											SendConsole("showguild Critical error details: rawName(" + ((PlayerInfo*)(peer->data))->rawName + ")", "ERROR");
											enet_peer_disconnect_now(peer, 0);
										}
										catch (std::runtime_error&) {
											SendConsole("showguild Critical error details: name(" + ((PlayerInfo*)(peer->data))->rawName + ")", "ERROR");
											enet_peer_disconnect_now(peer, 0);
										}
										catch (...) {
											SendConsole("showguild Critical error details: name(" + ((PlayerInfo*)(peer->data))->rawName + ")", "ERROR");
											enet_peer_disconnect_now(peer, 0);
										}
									}
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
										string name = ((PlayerInfo*)(currentPeer->data))->rawName;
										if (find(((PlayerInfo*)(peer->data))->guildMembers.begin(), ((PlayerInfo*)(peer->data))->guildMembers.end(), name) != ((PlayerInfo*)(peer->data))->guildMembers.end()) {
											if (((PlayerInfo*)(currentPeer->data))->rawName == ((PlayerInfo*)(peer->data))->guildLeader) {
												onlinegmlist += "\nadd_button|onlinegm_" + ((PlayerInfo*)(currentPeer->data))->rawName + "|`2ONLINE: `o" + ((PlayerInfo*)(currentPeer->data))->tankIDName + " `e(GL)``|0|0|";
												onlinecount++;
											}
											else {
												vector<string> GE;
												vector<string> GC;
												std::ifstream ifff("save/guilds/_" + PlayerDB::getProperName(static_cast<PlayerInfo*>(currentPeer->data)->guild) + ".json");
												if (ifff.fail()) {
													ifff.close();
													continue;
												}
												if (ifff.is_open()) {
												}
												json j;
												ifff >> j; //load
												for (int i = 0; i < j["Elder-Leader"].size(); i++) {
													GE.push_back(j["Elder-Leader"][i]);
												}
												for (int i = 0; i < j["Co-Leader"].size(); i++) {
													GC.push_back(j["Co-Leader"][i]);
												}

												string grole = "";
												if (find(GE.begin(), GE.end(), name) != GE.end()) grole = "`9(GE)";
												if (find(GC.begin(), GC.end(), name) != GC.end()) grole = "`6(GC)";
												onlinegmlist += "\nadd_button|onlinegm_" + ((PlayerInfo*)(currentPeer->data))->rawName + "|`2ONLINE: `o" + ((PlayerInfo*)(currentPeer->data))->tankIDName + " " + grole + "``|0|0|";
												onlinecount++;
											}
										}
									}
									int guildsize = 15;
									if (((PlayerInfo*)(peer->data))->guildlevel == 2) guildsize = 20;
									else if (((PlayerInfo*)(peer->data))->guildlevel == 3) guildsize = 25;
									else if (((PlayerInfo*)(peer->data))->guildlevel == 4) guildsize = 30;
									else if (((PlayerInfo*)(peer->data))->guildlevel == 5) guildsize = 35;
									else if (((PlayerInfo*)(peer->data))->guildlevel == 6) guildsize = 40;
									else if (((PlayerInfo*)(peer->data))->guildlevel == 7) guildsize = 45;
									else if (((PlayerInfo*)(peer->data))->guildlevel == 8) guildsize = 50;
									if (((PlayerInfo*)(peer->data))->rawName == ((PlayerInfo*)(peer->data))->guildLeader) {
										string guilds = "set_default_color|`o\n\nadd_dual_layer_icon_label|big|`wGuild Home|left|" + std::to_string(((PlayerInfo*)(peer->data))->guildBg) + "|" + std::to_string(((PlayerInfo*)(peer->data))->guildFg) + "|1.0|0|\n\nadd_spacer|small|\nadd_textbox|`oGuild Name: " + guildname + "|left|\nadd_textbox|Guild Statement: " + ((PlayerInfo*)(peer->data))->guildStatement + "``|\nadd_textbox|`oGuild size: " + to_string(guildsize) + " members|\nadd_textbox|`oGuild Level: " + std::to_string(((PlayerInfo*)(peer->data))->guildlevel) + "|\n\nadd_spacer|small|\nadd_button|guildoffline|`wShow offline too``|0|0|\nadd_button|goguildhome|`wGo to Guild Home``|0|0|\nadd_button|guildleveluper|`wUpgrade Guild``|0|0|\nadd_button|EditStatement|`wEdit Guild Statement|0|0|\nadd_button|leavefromguild|`4Abandon Guild``|0|0|\n\nadd_spacer|small|\nadd_textbox|`5" + std::to_string(onlinecount) + " of " + std::to_string(((PlayerInfo*)(peer->data))->guildMembers.size()) + " `wGuild Members Online|" + onlinegmlist + "\n\nadd_spacer|small|\nadd_button||`wClose``|0|0|\nadd_quick_exit|";
										Player::OnDialogRequest(peer, guilds);
									}
									else {
										string guild = "set_default_color|`o\n\nadd_dual_layer_icon_label|big|`wGuild Home|left|" + std::to_string(((PlayerInfo*)(peer->data))->guildBg) + "|" + std::to_string(((PlayerInfo*)(peer->data))->guildFg) + "|1.0|0|\n\nadd_spacer|small|\nadd_textbox|`oGuild Name: " + guildname + "|left|\nadd_textbox|Guild Statement: " + ((PlayerInfo*)(peer->data))->guildStatement + "``|\nadd_textbox|`oGuild size: " + to_string(guildsize) + " members|\nadd_textbox|`oGuild Level: " + std::to_string(((PlayerInfo*)(peer->data))->guildlevel) + "|\n\nadd_spacer|small|\nadd_button|guildoffline|`wShow offline too``|0|0|\nadd_button|goguildhome|`wGo to Guild Home``|0|0|\nadd_button|guildleveluper|`wUpgrade Guild``|0|0|\nadd_button|leavefromguild|`4Leave from guild``|0|0|\n\nadd_spacer|small|\nadd_textbox|`5" + std::to_string(onlinecount) + " of " + std::to_string(((PlayerInfo*)(peer->data))->guildMembers.size()) + " `wGuild Members Online|" + onlinegmlist + "\n\nadd_spacer|small|\nadd_button||`wClose``|0|0|\nadd_quick_exit|";
										Player::OnDialogRequest(peer, guild);
									}
								}
								if (btn == "EditStatement") {
									Player::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`wEdit Guild Statement|left|5814|\nadd_text_input|EditState|`$Guild Statement: |" + ((PlayerInfo*)(peer->data))->LastState + "|25|\nadd_spacer|small|\nadd_button|ConfirmState|`$Confirm|0|0|\nend_dialog|cl0se|Close||");
								}
								if (btn == "guildleveluper") {
									sendGuildInfo(peer);
								}
								if (btn == "ipbanwrench") {
									if (isMod(peer)) {
										Player::OnTextOverlay(peer, "IP Ban mod applied to " + pData->lastInfo + "!");
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
											if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == pData->lastInfo) {
												if (static_cast<PlayerInfo*>(currentPeer->data)->haveGrowId == false) continue;
												ofstream tolog("save/logs/wrench/ipban.txt", ios::app);
												tolog << "Administrator " << static_cast<PlayerInfo*>(peer->data)->rawName << " used ip ban in wrench on " << static_cast<PlayerInfo*>(currentPeer->data)->rawName << endl;
												tolog.close();
												autoBan(currentPeer, true, 100000, "ip ban wrench");
											}
										}
										SendPunishView(peer, pData->lastInfo);
									}
								}
								if (btn == "banpanel") {
									if (isMod(peer)) {
										pData->last_ban_days = 0;
										pData->last_ban_hours = 0;
										pData->last_ban_minutes = 0;
										pData->last_ban_reason = "";
										send_ban_panel(peer, "");
									}
								}
								if (btn == "mutepanel") {
									if (isMod(peer)) {
										pData->last_ban_days = 0;
										pData->last_ban_hours = 0;
										pData->last_ban_minutes = 0;
										pData->last_ban_reason = "";
										send_mute_panel(peer, "");
									}
								}
								if (btn == "cursepanel") {
									if (isMod(peer)) {
										pData->last_ban_days = 0;
										pData->last_ban_hours = 0;
										pData->last_ban_minutes = 0;
										pData->last_ban_reason = "";
										send_curse_panel(peer, "");
									}
								}
								if (btn == "suspend")
								{
									if (isMod(peer))
									{
										Player::OnTextOverlay(peer, "Ban mod applied to " + pData->lastInfo + "!");
										GamePacket p7 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`#** `$The Ancient Ones `ohave `4banned `w" + pData->lastInfo + " `#** `o(`4/rules `oto see the rules!)"));
										ENetPeer* currentPeer;
										time_t now = time(nullptr);
										char* dt = ctime(&now);
										for (currentPeer = server->peers;
											currentPeer < &server->peers[server->peerCount];
											++currentPeer)
										{
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
												continue;
											if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == pData->lastInfo)
											{
												if (static_cast<PlayerInfo*>(currentPeer->data)->haveGrowId == false) continue;
												GamePacket ps2 = packetEnd(appendInt(appendString(appendString(appendString(appendString(createPacket(), "OnAddNotification"), "interface/atomic_button.rttex"), "`0Warning from `4System`0: You've been `4BANNED `0from GrowtopiaOS for 730 days"), "audio/hub_open.wav"), 0));
												ENetPacket* packet2 = enet_packet_create(ps2.data,
													ps2.len,
													ENET_PACKET_FLAG_RELIABLE);
												enet_peer_send(currentPeer, 0, packet2);
												GamePacket ps3 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`oWarning from `4System`o: You've been `4BANNED `ofrom GrowtopiaOS for 730 days"));
												ENetPacket* packet3 = enet_packet_create(ps3.data,
													ps3.len,
													ENET_PACKET_FLAG_RELIABLE);
												enet_peer_send(currentPeer, 0, packet3);
												GamePacket pto = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "Applied punishment on " + pData->lastInfo + "."));
												ENetPacket* packetto = enet_packet_create(pto.data,
													pto.len,
													ENET_PACKET_FLAG_RELIABLE);
												enet_peer_send(peer, 0, packetto);
												enet_peer_disconnect_later(currentPeer, 0);
											}
											ENetPacket* packet7 = enet_packet_create(p7.data,
												p7.len,
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(currentPeer, 0, packet7);
										}
										string username = PlayerDB::getProperName(pData->rawName);
										try {
											ifstream read_player("save/players/_" + pData->lastInfo + ".json");
											if (!read_player.is_open()) {
												continue;
											}		
											json j;
											read_player >> j;
											read_player.close();
											j["isBanned"] = true;
											ofstream write_player("save/players/_" + pData->lastInfo + ".json");
											write_player << j << std::endl;
											write_player.close();
										} catch (std::exception& e) {
											std::cout << e.what() << std::endl;
											continue; 
										}
										LogAccountActivity(pData->rawName, pData->lastInfo, "Ban permanent (hacking/DGH)");
										SendPunishView(peer, pData->lastInfo);
									}
								}
								if (btn == "fakeautoban") {
									if (isMod(peer)) {
										bool Found = false;
										Player::OnTextOverlay(peer, "Fake auto ban used! Only works if they are online");
										string userdisplay = "";
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
											if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == pData->lastInfo) {
												Found = true;
												userdisplay = static_cast<PlayerInfo*>(currentPeer->data)->displayName;
												autoBan(currentPeer, true, 0, "");
												break;
											}
										}
										if (userdisplay == "") userdisplay = pData->lastInfo;
										if (Found) {
											for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
												Player::OnConsoleMessage(currentPeer, "`#** `$The Ancients `ohave used `#Ban `oon `w" + userdisplay + "`o! `#**");
											}
										}
										SendPunishView(peer, pData->lastInfo);
									}
								}
								/*if (btn == "suspendalts") {
									if (isMod(peer)) {
										MYSQL_ROW row;
										if (conn == nullptr) continue;
										if (conn != nullptr)
										{
											stringstream sse;
											sse << "SELECT * FROM PlayerDatabnase WHERE username = '" + PlayerDB::getProperName(pData->lastInfo) + "' LIMIT 1";
											auto query = sse.str();
											auto q = query.c_str();
											if (mysql_query(conn, q)) {
												cout << mysql_error(conn) << endl;
												continue;
											}
											string tip;
											string email;
											string ipid;
											res = mysql_store_result(conn);
											while (row = mysql_fetch_row(res)) {
												email = row[3];
												ipid = row[15];
												tip = row[38];
											} 
											if (tip == "") tip = "-1";
											if (ipid == "8421376") ipid = "-1";
											stringstream sse1;
											sse1 << "SELECT * FROM PlayerDatabanse WHERE ip = '" + tip + "' OR email = '" + email + "' OR ipID = '" + ipid + "'";
											auto query321 = sse1.str();
											auto q321 = query321.c_str();
											if (mysql_query(conn, q321)) {
												cout << mysql_error(conn) << endl; 
												continue;
											}
											string test;
											string isbanned;
											res = mysql_store_result(conn);
											while (row = mysql_fetch_row(res)) {
												test = row.at(1);
												isbanned = row[14];
												if (isbanned == "1") {
													Player::OnConsoleMessage(peer, test + " was already banned, skipped!");
													continue;
												}
												string q = "UPDATE PlayerDatabasne SET isBanned = '1' WHERE username = '" + test + "' OR email = '" + email + "' OR ipID = '" + ipid + "'";
												if (mysql_query(conn, q.c_str())) {
													cout << mysql_error(conn) << endl;
													continue;
												}
												SendConsole("" + test + " for permanent banned by " + pData->rawName + "", "BAN");
												Player::OnTextOverlay(peer, "Applied punishment on " + test + ".");
												for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
													if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
													Player::OnConsoleMessage(currentPeer, "`#** `$The Ancient Ones `ohave `4banned `w" + test + " `#** `o(`4/rules `oto see the rules!)");
													if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == pData->lastInfo) {
														if (static_cast<PlayerInfo*>(currentPeer->data)->haveGrowId == false) continue;
														Player::OnAddNotification(currentPeer, "`0Warning from `4System`0: You've been `4BANNED `0from GrowtopiaOS for 730 days", "audio/hub_open.wav", "interface/atomic_button.rttex");
														Player::OnConsoleMessage(currentPeer, "`oWarning from `4System`o: You've been `4BANNED `ofrom GrowtopiaOS for 730 days");
														enet_peer_disconnect_later(currentPeer, 0);
														break;
													}
												}
												LogAccountActivity(pData->rawName, test, "Ban permanent on alt(s)");
											}
										}
										SendPunishView(peer, pData->lastInfo);
									}
								}*/
								if (btn == "punishview") {
									if (isMod(peer)) SendPunishView(peer, pData->lastInfo);
								}
								if (btn == "rules")
								{
									Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wHelp & Rules``|left|18|\nadd_spacer|small|\nadd_textbox|`wTo keep this place fun we've got some ground rules to check out:``|left|\nadd_spacer|small|\nadd_label_with_icon|small|`wKeep your password secret. Sharing your password will result in stolen items.``|left|24|\nadd_label_with_icon|small|`wUnprotected items are at risk of being stolen. Use doors, locks, and blocks wisely to protect your items.``|left|24|\nadd_label_with_icon|small|`wWe cannot return stolen items, so BE CAREFUL!``|left|24|\nadd_label_with_icon|small|`wBe civil. Bullying, racism, excessive profanity, sexual content, and abusive behavior are not allowed.``|left|24|\nadd_label_with_icon|small|`wPlayers that are harmful to the community may be banned. This includes accounts that use lies, fake games, or trickery to mistreat other players.``|left|24|\nadd_label_with_icon|small|`wPunishments may be applied to alt accounts as well as any devices and IP addresses used by the offender.``|left|24|\nadd_label_with_icon|small|`wTrying to get punished or asking for a punishment can earn you a worse punishment.``|left|24|\nadd_label_with_icon|small|`w'Hacking' the game - including client-side manipulation, auto-clickers, speed hacks, clock manipulation, bots, macroing, and autofarming - will result in a ban.``|left|24|\nadd_label_with_icon|small|`wDon't sell " + server_name + "'s item's or gem's for original growtopia wl. if you caught by an owner you will a worse punishment.``|left|24|\nadd_label_with_icon|small|`wDon't ban or mute or curse people without an obvius reason. breaking this rules will get you a worse punishment.``|left|24|\nadd_label_with_icon|small|`wDon't lie about mods or fake official Growtopia system messages.``|left|24|\nadd_label_with_icon|small|`w'Drop games' are illegal scams. You can be punished for hosting, playing, advertising or even watching.``|left|24|\nadd_label_with_icon|small|`wBetting or gambling (asking players to pay for a chance to win something) is not allowed.``|left|24|\nadd_label_with_icon|small|`wIf you find a world or player name that is in violation of our rules, message a @Mod. Do not /bc or /sb from an inappropriate world.``|left|24|\nadd_label_with_icon|small|`w@Moderators are here to enforce the rules. Abusing, spamming or harassing mods will have consequences.``|left|24|\nadd_label_with_icon|small|`wAccounts, locks, or worlds may be deleted after long periods of inactivity.``|left|24|\nadd_label_with_icon|small|`wOut of game buying/selling of Growtopia accounts, items or worlds is not allowed and may result in a ban.``|left|24|\nadd_label_with_icon|small|`wIAP fraud will result in permanent suspension.``|left|24|\nadd_label_with_icon|small|`wItem function and prices are subject to change without warning.``|left|24|\nadd_label_with_icon|small|`wYour creations and items could be deleted at any time. We do everything in our power to prevent this, but data loss may happen without warning. Lost items cannot be restored.``|left|24|\nadd_spacer|small|\nadd_label_with_icon|small|`wFor technical support, IAP issues, or to report a problem, please email " + server_email + "``|left|24|\nadd_label|with|icon|small|`wThis Rules Isn't applicable for Server-Developer.``|left|24|\nadd_spacer|small|\nend_dialog|popup||Continue|");
								}
								if (btn == "wban")
								{
									if (world == nullptr || pData->currentWorld == "EXIT" || serverIsFrozen) continue;
									if (pData->lastInfo == pData->rawName)
									{
										continue;
									}
									if (pData->haveGrowId && pData->rawName == world->owner || isMod(peer))
									{
										ENetPeer* currentPeerp;
										for (currentPeerp = server->peers;
											currentPeerp < &server->peers[server->peerCount];
											++currentPeerp)
										{
											if (currentPeerp->state != ENET_PEER_STATE_CONNECTED)
												continue;
											string name = pData->displayName;
											string kickname = pData->lastDisplayname;
											//string kickname = pData->displayName;
											GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), name + " `4world bans " + "`o" + kickname + " from `w" + world->name + "`o!"));
											string text = "action|play_sfx\nfile|audio/repair.wav\ndelayMS|0\n";
											BYTE* data = new BYTE[5 + text.length()];
											BYTE zero = 0;
											int type = 3;
											memcpy(data, &type, 4);
											memcpy(data + 4, text.c_str(), text.length());
											memcpy(data + 4 + text.length(), &zero, 1);
											if (isHere(peer, currentPeerp))
											{
												ENetPacket* packetsou = enet_packet_create(data,
													5 + text.length(),
													ENET_PACKET_FLAG_RELIABLE);
												ENetPacket* packet = enet_packet_create(p.data,
													p.len,
													ENET_PACKET_FLAG_RELIABLE);
												enet_peer_send(currentPeerp, 0, packetsou);
												enet_peer_send(currentPeerp, 0, packet);
												delete[] data;
												delete p.data;
												if (static_cast<PlayerInfo*>(currentPeerp->data)->rawName == pData->lastInfo) // if last wrench
												{
													namespace fs = std::experimental::filesystem;
													if (!fs::is_directory("save/worldbans/_" + world->name) || !fs::exists("save/worldbans/_" + world->name))
													{
														fs::create_directory("save/worldbans/_" + world->name);
														std::ofstream outfile("save/worldbans/_" + world->name + "/" + static_cast<PlayerInfo*>(currentPeerp->data)->rawName);
														outfile << "worldbanned by: " + pData->rawName;
														outfile.close();
													}
													else
													{
														std::ofstream outfile("save/worldbans/_" + world->name + "/" + static_cast<PlayerInfo*>(currentPeerp->data)->rawName);
														outfile << "worldbanned by: " + pData->rawName;
														outfile.close();
													}
													sendPlayerLeave(currentPeerp);
													static_cast<PlayerInfo*>(currentPeerp->data)->currentWorld = "EXIT";
													sendWorldOffers(currentPeerp);
												}
											}
										}
									}
								}
								if (btn == "kick") {
									if (world == nullptr || pData->currentWorld == "EXIT" || serverIsFrozen) continue;
									if (pData->lastInfo == pData->rawName) continue;
									if (std::find(creators.begin(), creators.end(), pData->lastInfo) == creators.end()) {
										Player::OnConsoleMessage(peer, "`oYou can't kick this player!");
										continue;
									}
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
										if (isHere(peer, currentPeer)) {
											if (pData->rawName == world->owner || isMod(peer) || !restricted_area(peer, world, static_cast<PlayerInfo*>(currentPeer->data)->x / 32, static_cast<PlayerInfo*>(currentPeer->data)->y / 32) && world->owner == "") {
												Player::OnConsoleMessage(currentPeer, pData->displayName + " `4kicks " + "`o" + pData->lastDisplayname + "`o!");
												if (pData->lastInfo == static_cast<PlayerInfo*>(currentPeer->data)->rawName) playerRespawn(world, currentPeer, false);
											}
										}
									}
								}
								if (btn == "pull")
								{
									if (world == nullptr || pData->currentWorld == "EXIT" || serverIsFrozen) continue;
									if (pData->lastInfo == pData->rawName)
									{
										continue;
									}
									if (pData->rawName == world->owner || isMod(peer))
									{
										ENetPeer* currentPeer;
										for (currentPeer = server->peers;
											currentPeer < &server->peers[server->peerCount];
											++currentPeer)
										{
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
											string name = static_cast<PlayerInfo*>(currentPeer->data)->rawName;
											int pullX = pData->x;
											int pullY = pData->y;
											if (name == pData->lastInfo)
											{
												if (isHere(peer, currentPeer) && world->name != "EXIT")
												{
													string name = pData->displayName;
													string pullname = static_cast<PlayerInfo*>(currentPeer->data)->displayName;
													GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), name + " `5pulls " + "`o" + pullname + "`o!"));
													string text = "action|play_sfx\nfile|audio/object_spawn.wav\ndelayMS|0\n";
													BYTE* data = new BYTE[5 + text.length()];
													BYTE zero = 0;
													int type = 3;
													memcpy(data, &type, 4);
													memcpy(data + 4, text.c_str(), text.length());
													memcpy(data + 4 + text.length(), &zero, 1);
													ENetPacket* packet = enet_packet_create(p.data,
														p.len,
														ENET_PACKET_FLAG_RELIABLE);
													enet_peer_send(currentPeer, 0, packet);
													enet_peer_send(peer, 0, packet);
													ENetPacket* packetsou = enet_packet_create(data,
														5 + text.length(),
														ENET_PACKET_FLAG_RELIABLE);
													enet_peer_send(currentPeer, 0, packetsou);
													enet_peer_send(peer, 0, packetsou);
													GamePacket p2 = packetEnd(appendFloat(appendString(createPacket(), "OnSetPos"), pullX, pullY));
													memcpy(p2.data + 8, &(static_cast<PlayerInfo*>(currentPeer->data)->netID), 4);
													ENetPacket* packet2 = enet_packet_create(p2.data,
														p2.len,
														ENET_PACKET_FLAG_RELIABLE);
													enet_peer_send(currentPeer, 0, packet2);
													if (isWorldOwner(peer, world)) Player::OnTextOverlay(currentPeer, "You were pulled by " + pData->displayName + "");
													else if (isMod(peer)) Player::OnTextOverlay(currentPeer, "You were summoned by a mod");
													delete p2.data;
													delete p.data;
												}
											}
										}
									}
								}
								if (btn == "backsocialportal") {
									string ShowGuildDialog = "Create Guild";
									if (pData->guild != "") {
										ShowGuildDialog = "Show Guild Members";
									}
									Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big| `wSocial Portal`` |left|1366|\nadd_spacer|small|\nadd_button|showfriend|`wShow Friends``|noflags|0|0|\nadd_button|showguild|`w" + ShowGuildDialog + "``|noflags|0|0|\nadd_quick_exit|\nend_dialog|friends_guilds|OK||");
								}
								if (btn == "showfriend")
								{
									if (pData->currentWorld == "EXIT")
									{
										continue;
									}
									string onlinefrnlist = "";
									int onlinecount = 0;
									int totalcount = pData->friendinfo.size();
									ENetPeer* currentPeer;
									for (currentPeer = server->peers;
										currentPeer < &server->peers[server->peerCount];
										++currentPeer)
									{
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
											continue;
										string name = static_cast<PlayerInfo*>(currentPeer->data)->rawName;
										if (find(pData->friendinfo.begin(), pData->friendinfo.end(), name) != pData->friendinfo.end())
										{
											onlinefrnlist += "\nadd_button|onlinefrns_" + static_cast<PlayerInfo*>(currentPeer->data)->rawName + "|`2ONLINE: `o" + static_cast<PlayerInfo*>(currentPeer->data)->tankIDName + "``|0|0|";
											onlinecount++;
										}
									}
									if (totalcount == 0)
									{
										GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`o" + std::to_string(onlinecount) + " of " + std::to_string(totalcount) + " `wFriends Online``|left|1366|\n\nadd_spacer|small|\nadd_label|small|`1To add friends in `4ServerName's `1Click on someone's name and click add as a friend!`o.``|left|4|\n\nadd_spacer|small|\nadd_button||`5Close``|0|0|\nadd_quick_exit|"));
										ENetPacket* packet2 = enet_packet_create(p2.data,
											p2.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet2);
										delete p2.data;
									}
									else if (onlinecount == 0)
									{
										GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`o" + std::to_string(onlinecount) + " of " + std::to_string(totalcount) + " `wFriends Online``|left|1366|\n\nadd_spacer|small|\nadd_button|chc0|`wClose``|0|0|\nadd_label|small|`oNone of your friends are currently online.``|left|4|\n\nadd_spacer|small|\nadd_button|showoffline|`5Show offline``|0|0|\nadd_button||`5Close``|0|0|\nadd_quick_exit|"));
										ENetPacket* packet2 = enet_packet_create(p2.data,
											p2.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet2);
										delete p2.data;
									}
									else
									{
										GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`o" + std::to_string(onlinecount) + " of " + std::to_string(totalcount) + " `wFriends Online``|left|1366|\n\nadd_spacer|small|\nadd_button|chc0|`wClose``|0|0|" + onlinefrnlist + "\n\nadd_spacer|small|\nadd_button|showoffline|`5Show offline``|0|0|\nadd_button||`oClose``|0|0|\nadd_quick_exit|"));
										ENetPacket* packet2 = enet_packet_create(p2.data,
											p2.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet2);
										delete p2.data;
									}
								}
								if (btn.substr(0, 18) == "clearaccountnotes_") {
									if (std::find(creators.begin(), creators.end(), static_cast<PlayerInfo*>(peer->data)->rawName) != creators.end()) {
										string username = btn.substr(18, cch.length() - 18 - 1);
										try {
											ifstream read_player("save/players/_" + username + ".json");
											if (!read_player.is_open()) {
												continue;
											}		
											json j;
											read_player >> j;
											read_player.close();
											j["accountnotes"] = "";
											ofstream write_player("save/players/_" + username + ".json");
											write_player << j << std::endl;
											write_player.close();
										} catch (std::exception& e) {
											std::cout << e.what() << std::endl;
											continue; 
										}
										Player::OnTextOverlay(peer, "Account notes cleared for " + username + "!");
										SendPunishView(peer, username);
									}
								}
								if (btn.substr(0, 7) == "warpto_") {
									if (isMod(peer)) handle_world(peer, btn.substr(7, cch.length() - 7 - 1));
								}
								if (btn.substr(0, 9) == "viewinfo_") {
									if (isMod(peer)) SendPunishView(peer, btn.substr(9, cch.length() - 9 - 1));
								}
								if (btn.substr(0, 10) == "offlinegm_") {
									if (((PlayerInfo*)(peer->data))->currentWorld == "EXIT") continue;
									((PlayerInfo*)(peer->data))->lastgm = btn.substr(10, cch.length() - 10 - 1);
									if (btn.substr(10, cch.length() - 10 - 1) == ((PlayerInfo*)(peer->data))->guildLeader) {
										Player::OnDialogRequest(peer, "set_default_color|`o\n\nadd_dual_layer_icon_label|big|`w" + ((PlayerInfo*)(peer->data))->lastgm + "|left|" + std::to_string(((PlayerInfo*)(peer->data))->guildBg) + "|" + std::to_string(((PlayerInfo*)(peer->data))->guildFg) + "|1.0|0|\n\nadd_spacer|small|\nadd_textbox|`oRank: Leader|\nadd_spacer|small|\nadd_textbox|`o" + ((PlayerInfo*)(peer->data))->lastgm + " is `4offline`o.``|\nadd_spacer|small|\nadd_button|guildoffline|`oBack``|0|0|\nadd_quick_exit|");
									}
									else {
										if (((PlayerInfo*)(peer->data))->rawName == ((PlayerInfo*)(peer->data))->guildLeader) {
											Player::OnDialogRequest(peer, "set_default_color|`o\n\nadd_dual_layer_icon_label|big|`w" + ((PlayerInfo*)(peer->data))->lastgm + "|left|" + std::to_string(((PlayerInfo*)(peer->data))->guildBg) + "|" + std::to_string(((PlayerInfo*)(peer->data))->guildFg) + "|1.0|0|\n\nadd_spacer|small|\nadd_textbox|`oRank: Member|\nadd_spacer|small|\nadd_textbox|`o" + ((PlayerInfo*)(peer->data))->lastgm + " is `4offline`o.``|\nadd_spacer|small|\nadd_button|removegmoffline|`oKick from the guild``|0|0|\nadd_button|guildoffline|`oBack``|0|0|\nadd_quick_exit|");
										}
										else {
											Player::OnDialogRequest(peer, "set_default_color|`o\n\nadd_dual_layer_icon_label|big|`w" + ((PlayerInfo*)(peer->data))->lastgm + "|left|" + std::to_string(((PlayerInfo*)(peer->data))->guildBg) + "|" + std::to_string(((PlayerInfo*)(peer->data))->guildFg) + "|1.0|0|\n\nadd_spacer|small|\nadd_textbox|`oRank: Member|\nadd_spacer|small|\nadd_textbox|`o" + ((PlayerInfo*)(peer->data))->lastgm + " is `4offline`o.``|\nadd_spacer|small|\nadd_button|guildoffline|`oBack``|0|0|\nadd_quick_exit|");
										}
									}
								}
								if (btn.substr(0, 9) == "onlinegm_") {
									if (((PlayerInfo*)(peer->data))->currentWorld == "EXIT") continue;
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
										if (((PlayerInfo*)(currentPeer->data))->rawName == btn.substr(9, cch.length() - 9 - 1)) {
											((PlayerInfo*)(peer->data))->lastgmworld = ((PlayerInfo*)(currentPeer->data))->currentWorld;
											((PlayerInfo*)(peer->data))->lastgmname = ((PlayerInfo*)(currentPeer->data))->displayName;
											((PlayerInfo*)(peer->data))->lastgm = ((PlayerInfo*)(currentPeer->data))->rawName;
										}
									}
									if (btn.substr(9, cch.length() - 9 - 1) == ((PlayerInfo*)(peer->data))->rawName) {
										Player::OnDialogRequest(peer, "set_default_color|`o\n\nadd_label_with_icon|big|`w" + ((PlayerInfo*)(peer->data))->lastgmname + "``|left|1366|\n\nadd_spacer|small|\nadd_textbox|This is you!|\n\nadd_spacer|small|\nadd_button|showguild|`oBack``|0|0|\nadd_quick_exit|");
									}
									else {
										string PromoteRankDialog = "";
										string DemoteRankDialog = "";
										vector<string> GE;
										vector<string> GC;
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
											if (((PlayerInfo*)(currentPeer->data))->rawName == ((PlayerInfo*)(peer->data))->lastgm) {
												std::ifstream ifff("save/guilds/_" + PlayerDB::getProperName(static_cast<PlayerInfo*>(currentPeer->data)->guild) + ".json");
												if (ifff.fail()) {
													ifff.close();
													continue;
												}
												if (ifff.is_open()) {
												}
												json j;
												ifff >> j; //load
												for (int i = 0; i < j["Elder-Leader"].size(); i++) {
													GE.push_back(j["Elder-Leader"][i]);
												}
												for (int i = 0; i < j["Co-Leader"].size(); i++) {
													GC.push_back(j["Co-Leader"][i]);
												}
												if (find(GC.begin(), GC.end(), static_cast<PlayerInfo*>(currentPeer->data)->rawName) != GC.end()) {
													PromoteRankDialog = "";
													DemoteRankDialog = "\nadd_button|demoteguildrank|`wDemote to Member|";
												}
												else if (find(GE.begin(), GE.end(), static_cast<PlayerInfo*>(currentPeer->data)->rawName) != GE.end()) {
													PromoteRankDialog = "\nadd_button|promotetogc|Promote to GC(Guild Co-Leader)|0|0|";
													DemoteRankDialog = "\nadd_button|demoteguildrank|`wDemote to Member|";
												}
												else
												{
													PromoteRankDialog = "\nadd_button|promotetoge|Promote to GE(Guild Elder)|0|0|";
													DemoteRankDialog = "";
												}
											}
										}

										if (((PlayerInfo*)(peer->data))->rawName == ((PlayerInfo*)(peer->data))->guildLeader) {
											Player::OnDialogRequest(peer, "set_default_color|`o\n\nadd_label_with_icon|big|`w" + ((PlayerInfo*)(peer->data))->lastgmname + "``|left|1366|\n\nadd_spacer|small|\nadd_textbox|`o" + ((PlayerInfo*)(peer->data))->lastgmname + " is `2online `onow in the world `5" + ((PlayerInfo*)(peer->data))->lastgmworld + "`o.|\n\nadd_spacer|small|\nadd_button|gmwarpbutton|`oWarp to `5" + ((PlayerInfo*)(peer->data))->lastgmworld + "``|0|0|\nadd_button|gmmsgbutton|`5Send message``|0|0|\nadd_spacer|small|" + PromoteRankDialog + "\nadd_spacer|small|" + DemoteRankDialog + "\nadd_spacer|small|\nadd_button|removegmonline|Kick from guild|0|0|\nadd_button|showguild|`oBack``|0|0|\nadd_quick_exit|");
										}
										else if (find(GC.begin(), GC.end(), static_cast<PlayerInfo*>(peer->data)->rawName) != GC.end()) {
											for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
												if (((PlayerInfo*)(currentPeer->data))->rawName == ((PlayerInfo*)(peer->data))->lastgm) {
													std::ifstream ifff("save/guilds/_" + PlayerDB::getProperName(static_cast<PlayerInfo*>(currentPeer->data)->guild) + ".json");
													if (ifff.fail()) {
														ifff.close();
														continue;
													}
													if (ifff.is_open()) {
													}
													json j;
													ifff >> j; //load
													for (int i = 0; i < j["Elder-Leader"].size(); i++) {
														GE.push_back(j["Elder-Leader"][i]);
													}
													for (int i = 0; i < j["Co-Leader"].size(); i++) {
														GC.push_back(j["Co-Leader"][i]);
													}
													if (find(GE.begin(), GE.end(), static_cast<PlayerInfo*>(currentPeer->data)->rawName) != GE.end()) {
														PromoteRankDialog = "";
														DemoteRankDialog = "\nadd_button|demoteguildrank|`wDemote to Member|";
													}
													else if (find(GC.begin(), GC.end(), static_cast<PlayerInfo*>(currentPeer->data)->rawName) != GC.end()) {
														PromoteRankDialog = "";
														DemoteRankDialog = "";
													}
													else if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == static_cast<PlayerInfo*>(peer->data)->guildLeader) {
														PromoteRankDialog = "";
														DemoteRankDialog = "";
													}
													else
													{
														PromoteRankDialog = "\nadd_button|promotetoge|Promote to GE(Guild Elder)|0|0|";
														DemoteRankDialog = "";
													}
												}
											}
											if (((PlayerInfo*)(peer->data))->lastgm == ((PlayerInfo*)(peer->data))->guildLeader) {
												Player::OnDialogRequest(peer, "set_default_color|`o\n\nadd_label_with_icon|big|`w" + ((PlayerInfo*)(peer->data))->lastgmname + "``|left|1366|\n\nadd_spacer|small|\nadd_textbox|`o" + ((PlayerInfo*)(peer->data))->lastgmname + " is `2online `onow in the world `5" + ((PlayerInfo*)(peer->data))->lastgmworld + "`o.|\n\nadd_spacer|small|\nadd_button|gmwarpbutton|`oWarp to `5" + ((PlayerInfo*)(peer->data))->lastgmworld + "``|0|0|\nadd_button|gmmsgbutton|`5Send message``|0|0|\nadd_spacer|small|" + PromoteRankDialog + "\nadd_spacer|small|\nadd_button|showguild|`oBack``|0|0|\nadd_quick_exit|");
											}
											else
											{
												Player::OnDialogRequest(peer, "set_default_color|`o\n\nadd_label_with_icon|big|`w" + ((PlayerInfo*)(peer->data))->lastgmname + "``|left|1366|\n\nadd_spacer|small|\nadd_textbox|`o" + ((PlayerInfo*)(peer->data))->lastgmname + " is `2online `onow in the world `5" + ((PlayerInfo*)(peer->data))->lastgmworld + "`o.|\n\nadd_spacer|small|\nadd_button|gmwarpbutton|`oWarp to `5" + ((PlayerInfo*)(peer->data))->lastgmworld + "``|0|0|\nadd_button|gmmsgbutton|`5Send message``|0|0|\nadd_spacer|small|" + PromoteRankDialog + "\nadd_spacer|small|" + DemoteRankDialog + "\nadd_spacer|small|\nadd_button|removegmonline|Kick from guild|0|0|\nadd_button|showguild|`oBack``|0|0|\nadd_quick_exit|");
											}
										}
										else {
											Player::OnDialogRequest(peer, "set_default_color|`o\n\nadd_label_with_icon|big|`w" + ((PlayerInfo*)(peer->data))->lastgmname + "``|left|1366|\n\nadd_spacer|small|\nadd_textbox|`o" + ((PlayerInfo*)(peer->data))->lastgmname + " is `2online `onow in the world `5" + ((PlayerInfo*)(peer->data))->lastgmworld + "`o.|\n\nadd_spacer|small|\nadd_button|gmwarpbutton|`oWarp to `5" + ((PlayerInfo*)(peer->data))->lastgmworld + "``|0|0|\nadd_button|gmmsgbutton|`5Send message``|0|0|\n\nadd_spacer|small|\nadd_button|showguild|`oBack``|0|0|\nadd_quick_exit|");
										}
									}
								}
								if (btn == "leavefromguild") {
									if (((PlayerInfo*)(peer->data))->currentWorld == "EXIT") {
										continue;
									}
									if (((PlayerInfo*)(peer->data))->rawName == ((PlayerInfo*)(peer->data))->guildLeader) {
										Player::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`8Are you sure?``|left|6204|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`oAfter `4Abandon `ofrom the guild, all guild's members will be `4kicked out `oand the guild will be `4destroyed`o!|left|8|\nadd_spacer|small|\nadd_button|confirmguildleaderleave|`4Yes, Abandon!|0|0|\nadd_spacer|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|");
									}
									else {
										try {
											std::ifstream ifff("save/guilds/_" + PlayerDB::getProperName(((PlayerInfo*)(peer->data))->guild) + ".json");
											if (ifff.fail()) {
												ifff.close();
												Player::OnConsoleMessage(peer, "`4Error: `oGuild does not exist! If you are seeing this message, please take a screenshot and send it to a developer!");
												continue;
											}
											if (ifff.is_open()) {
											}
											remove(("save/guilds/_" + PlayerDB::getProperName(((PlayerInfo*)(peer->data))->guild) + ".json").c_str());
											json j;
											ifff >> j; //load
											vector<string> gmlist;
											vector<string> GE;
											vector<string> GC;
											for (int i = 0; i < j["Member"].size(); i++) {
												gmlist.push_back(j["Member"][i]);
											}
											for (int i = 0; i < j["Co-Leader"].size(); i++) {
												GC.push_back(j["Co-Leader"][i]);
											}
											for (int i = 0; i < j["Elder-Leader"].size(); i++) {
												GE.push_back(j["Elder-Leader"][i]);
											}
											if (find(GE.begin(), GE.end(), static_cast<PlayerInfo*>(peer->data)->rawName) != GE.end()) {
												GE.erase(std::remove(GE.begin(), GE.end(), static_cast<PlayerInfo*>(peer->data)->rawName), GE.end());
											}
											if (find(GC.begin(), GC.end(), static_cast<PlayerInfo*>(peer->data)->rawName) != GC.end()) {
												GC.erase(std::remove(GC.begin(), GC.end(), static_cast<PlayerInfo*>(peer->data)->rawName), GC.end());
											}
											gmlist.erase(std::remove(gmlist.begin(), gmlist.end(), ((PlayerInfo*)(peer->data))->rawName), gmlist.end());
											j["Member"] = gmlist;
											j["Co-Leader"] = GC; //edit
											j["Elder-Leader"] = GE; //edit
											std::ofstream o("save/guilds/_" + PlayerDB::getProperName(((PlayerInfo*)(peer->data))->guild) + ".json"); //save
											if (!o.is_open()) continue;
											o << j << std::endl;
											for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
												if (((PlayerInfo*)(currentPeer->data))->guild == ((PlayerInfo*)(peer->data))->guild) {
													Player::OnConsoleMessage(currentPeer, "`9[GUILD ALERT] `o" + ((PlayerInfo*)(peer->data))->rawName + " has left the guild!");
													updateInvis(currentPeer);
												}
											}
											((PlayerInfo*)(peer->data))->guildBg = 0;
											((PlayerInfo*)(peer->data))->guildFg = 0;
											((PlayerInfo*)(peer->data))->guildLeader = "";
											((PlayerInfo*)(peer->data))->guild = "";
											((PlayerInfo*)(peer->data))->guildStatement = "";
											((PlayerInfo*)(peer->data))->guildlast = "";
											((PlayerInfo*)(peer->data))->lastgm = "";
											((PlayerInfo*)(peer->data))->lastgmname = "";
											((PlayerInfo*)(peer->data))->joinguild = false;
											((PlayerInfo*)(peer->data))->lastgmworld = "";
											((PlayerInfo*)(peer->data))->guildMembers.clear();
											outFromGuild(peer);
											updateInvis(peer);
											ifstream fg("save/players/_" + ((PlayerInfo*)(peer->data))->rawName + ".json");
											json j2;
											fg >> j2;
											fg.close();
											j2["guild"] = "";
											j2["joinguild"] = false;
											ofstream fs("save/players/_" + ((PlayerInfo*)(peer->data))->rawName + ".json");
											fs << j2;
											fs.close();
										}
										catch (std::exception&) {
											SendConsole("leavefromguild Critical error details: rawName(" + ((PlayerInfo*)(peer->data))->rawName + ")", "ERROR");
											enet_peer_disconnect_now(peer, 0);
										}
										catch (std::runtime_error&) {
											SendConsole("leavefromguild Critical error details: name(" + ((PlayerInfo*)(peer->data))->rawName + ")", "ERROR");
											enet_peer_disconnect_now(peer, 0);
										}
										catch (...) {
											SendConsole("leavefromguild Critical error details: name(" + ((PlayerInfo*)(peer->data))->rawName + ")", "ERROR");
											enet_peer_disconnect_now(peer, 0);
										}
									}
								}
								if (btn == "confirmguildleaderleave") {
									if (((PlayerInfo*)(peer->data))->currentWorld == "EXIT") {
										continue;
									}
									try {
										std::ifstream ifff("save/guilds/_" + PlayerDB::getProperName(((PlayerInfo*)(peer->data))->guild) + ".json");
										if (ifff.fail()) {
											ifff.close();
											Player::OnDialogRequest(peer, "`4Error: `oGuild does not exist! If you are seeing this message, please take a screenshot and send it to a developer!");
											continue;
										}
										json j;
										ifff >> j; //load
										ifff.close();
										vector<string> gmlist;
										for (int i = 0; i < j["Member"].size(); i++) {
											gmlist.push_back(j["Member"][i]);
										}
										const int result = remove(("save/guilds/_" + PlayerDB::getProperName(((PlayerInfo*)(peer->data))->guild) + ".json").c_str());
										if (result == 0) {
										}
										else {
											SendConsole("Button (confirmguildleaderleave) Failed to execute!", "ERROR");
										}
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
											if (find(gmlist.begin(), gmlist.end(), ((PlayerInfo*)(currentPeer->data))->rawName) != gmlist.end()) {
												((PlayerInfo*)(currentPeer->data))->guildBg = 0;
												((PlayerInfo*)(currentPeer->data))->guildFg = 0;
												((PlayerInfo*)(currentPeer->data))->guildLeader = "";
												((PlayerInfo*)(currentPeer->data))->guild = "";
												((PlayerInfo*)(currentPeer->data))->guildStatement = "";
												((PlayerInfo*)(currentPeer->data))->guildlast = "";
												((PlayerInfo*)(currentPeer->data))->lastgm = "";
												((PlayerInfo*)(currentPeer->data))->lastgmname = "";
												((PlayerInfo*)(currentPeer->data))->joinguild = false;
												((PlayerInfo*)(currentPeer->data))->lastgmworld = "";
												((PlayerInfo*)(currentPeer->data))->guildMembers.clear();
												world->category = "None";
												updateInvis(currentPeer);
												Player::OnConsoleMessage(currentPeer, "`5[GUILD ALERT] `4Unfortunately, `obut guild's leader `4abandoned `ofrom the guild and you were `4kicked out`o.");
											}
										}
										for (int i = 0; i < gmlist.size(); i++) {
											ifstream fg("save/players/_" + gmlist[i] + ".json");
											json j;
											fg >> j;
											fg.close();
											j["guild"] = "";
											j["joinguild"] = false;
											ofstream fs("save/players/_" + gmlist[i] + ".json");
											fs << j;
											fs.close();
										}
									}
									catch (std::exception&) {
										SendConsole("confirmguildleaderleave Critical error details: rawName(" + ((PlayerInfo*)(peer->data))->rawName + ")", "ERROR");
										enet_peer_disconnect_now(peer, 0);
									}
									catch (std::runtime_error&) {
										SendConsole("confirmguildleaderleave Critical error details: name(" + ((PlayerInfo*)(peer->data))->rawName + ")", "ERROR");
										enet_peer_disconnect_now(peer, 0);
									}
									catch (...) {
										SendConsole("confirmguildleaderleave Critical error details: name(" + ((PlayerInfo*)(peer->data))->rawName + ")", "ERROR");
										enet_peer_disconnect_now(peer, 0);
									}
								}
								if (btn == "gmwarpbutton") {
									if (((PlayerInfo*)(peer->data))->currentWorld == "EXIT") continue;
									if (((PlayerInfo*)(peer->data))->lastgmworld == "EXIT") {
										Player::OnConsoleMessage(peer, "`oYou can't warp to your guild member's world because he/she is in EXIT!");
										continue;
									}
									sendPlayerLeave(peer);
									handle_world(peer, ((PlayerInfo*)(peer->data))->lastgmworld);
								}
								if (btn == "guildoffline") {
									if (((PlayerInfo*)(peer->data))->currentWorld == "EXIT") {
										continue;
									}
									string onlinegmlist = "";
									string offname, offlinegm;
									string grole = "";
									int onlinecount = 0;
									int totalcount = ((PlayerInfo*)(peer->data))->guildMembers.size();
									string gstatement = ((PlayerInfo*)(peer->data))->guildLeader;
									string bg = std::to_string(((PlayerInfo*)(peer->data))->guildBg);
									string fg = std::to_string(((PlayerInfo*)(peer->data))->guildFg);
									string guildname = ((PlayerInfo*)(peer->data))->guild;
									string guildleader = ((PlayerInfo*)(peer->data))->guildLeader;
									string guildlvl = "0";
									string guildexp = "0";
									vector<string> offlineguild = ((PlayerInfo*)(peer->data))->guildMembers;
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
										string name = ((PlayerInfo*)(currentPeer->data))->rawName;
										if (find(((PlayerInfo*)(peer->data))->guildMembers.begin(), ((PlayerInfo*)(peer->data))->guildMembers.end(), name) != ((PlayerInfo*)(peer->data))->guildMembers.end()) {
											if (((PlayerInfo*)(currentPeer->data))->rawName == ((PlayerInfo*)(peer->data))->guildLeader) {
												onlinegmlist += "\nadd_button|onlinegm_" + ((PlayerInfo*)(currentPeer->data))->rawName + "|`2ONLINE: `o" + ((PlayerInfo*)(currentPeer->data))->displayName + " `e(GL)``|0|0|";
												onlinecount++;
											}
											else {
												onlinegmlist += "\nadd_button|onlinegm_" + ((PlayerInfo*)(currentPeer->data))->rawName + "|`2ONLINE: `o" + ((PlayerInfo*)(currentPeer->data))->displayName + " " + grole + "``|0|0|";
												onlinecount++;
												offlineguild.erase(std::remove(offlineguild.begin(), offlineguild.end(), name), offlineguild.end());
											}
										}
									}
									for (std::vector<string>::const_iterator i = offlineguild.begin(); i != offlineguild.end(); ++i) {
										offname = *i;
										offlinegm += "\nadd_button|offlinegm_" + offname + "|`4OFFLINE: `o" + offname + "``|0|0|";
									}
									int guildsize = 15;
									if (((PlayerInfo*)(peer->data))->guildlevel == 2) guildsize = 20;
									else if (((PlayerInfo*)(peer->data))->guildlevel == 3) guildsize = 25;
									else if (((PlayerInfo*)(peer->data))->guildlevel == 4) guildsize = 30;
									else if (((PlayerInfo*)(peer->data))->guildlevel == 5) guildsize = 35;
									else if (((PlayerInfo*)(peer->data))->guildlevel == 6) guildsize = 40;
									else if (((PlayerInfo*)(peer->data))->guildlevel == 7) guildsize = 45;
									else if (((PlayerInfo*)(peer->data))->guildlevel == 8) guildsize = 50;
									Player::OnDialogRequest(peer, "set_default_color|`o\nadd_dual_layer_icon_label|big|`wGuild Home|left|" + std::to_string(((PlayerInfo*)(peer->data))->guildBg) + "|" + std::to_string(((PlayerInfo*)(peer->data))->guildFg) + "|1.0|0|\n\nadd_spacer|small|\nadd_textbox|" + ((PlayerInfo*)(peer->data))->guildStatement + "``|\nadd_textbox|`oGuild size: " + std::to_string(guildsize) + " members|\nadd_textbox|`oGuild Level: " + std::to_string(((PlayerInfo*)(peer->data))->guildlevel) + "|\n\nadd_spacer|small|\nadd_button|goguildhome|`wGo to Guild Home``|0|0|\nadd_button|leavefromguild|`4Leave from guild``|0|0|\n\nadd_spacer|small|\nadd_textbox|`5" + std::to_string(onlinecount) + " of " + std::to_string(((PlayerInfo*)(peer->data))->guildMembers.size()) + " `wGuild Members Online|" + offlinegm + "\n\nadd_spacer|small|\nadd_button||`wClose``|0|0|\nadd_quick_exit|");
								}
								if (btn == "showoffline")
								{
									if (pData->currentWorld == "EXIT")
									{
										continue;
									}
									string onlinelist = "";
									string offlinelist = "";
									string offname = "";
									int onlinecount = 0;
									int totalcount = pData->friendinfo.size();
									vector<string> offliness = pData->friendinfo;
									ENetPeer* currentPeer;
									for (currentPeer = server->peers;
										currentPeer < &server->peers[server->peerCount];
										++currentPeer)
									{
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
											continue;
										string name = static_cast<PlayerInfo*>(currentPeer->data)->rawName;
										if (find(pData->friendinfo.begin(), pData->friendinfo.end(), name) != pData->friendinfo.end())
										{
											onlinelist += "\nadd_button|onlinefrns_" + static_cast<PlayerInfo*>(currentPeer->data)->rawName + "|`2ONLINE: `o" + static_cast<PlayerInfo*>(currentPeer->data)->displayName + "``|0|0|";
											onlinecount++;
											offliness.erase(std::remove(offliness.begin(), offliness.end(), name), offliness.end());
										}
									}
									for (std::vector<string>::const_iterator i = offliness.begin(); i != offliness.end(); ++i)
									{
										offname = *i;
										offlinelist += "\nadd_button|offlinefrns_" + offname + "|`4OFFLINE: `o" + offname + "``|0|0|";
									}
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`o" + std::to_string(onlinecount) + " of " + std::to_string(totalcount) + " `wFriends Online|left|1366|\n\nadd_spacer|small|\nadd_button|chc0|`wClose``|0|0|\nadd_spacer|small|" + offlinelist + "\nadd_spacer|small|\n\nadd_button|frnoption|`oFriend Options``|0|0|\nadd_button|showfriend|Back``|0|0|\nadd_button||`oClose``|0|0|\nadd_quick_exit|"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
								}
								if (btn == "demoteguildrank") {
									if (((PlayerInfo*)(peer->data))->currentWorld == "EXIT") continue;
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
										if (((PlayerInfo*)(currentPeer->data))->rawName == ((PlayerInfo*)(peer->data))->lastgm) {
											if (static_cast<PlayerInfo*>(currentPeer->data)->guild == "" || static_cast<PlayerInfo*>(currentPeer->data)->guild != static_cast<PlayerInfo*>(peer->data)->guild) continue;
											std::ifstream ifff("save/guilds/_" + PlayerDB::getProperName(((PlayerInfo*)(peer->data))->guild) + ".json");
											if (ifff.fail()) {
												ifff.close();
												Player::OnConsoleMessage(peer, "`4Error: `oGuild does not exist! If you are seeing this message, please take a screenshot and send it to a developer!");
												continue;
											}
											if (ifff.is_open()) {
											}
											json j;
											ifff >> j; //load
											vector<string> GC;
											vector<string> GE;
											for (int i = 0; i < j["Co-Leader"].size(); i++) {
												GC.push_back(j["Co-Leader"][i]);
											}
											for (int i = 0; i < j["Elder-Leader"].size(); i++) {
												GE.push_back(j["Elder-Leader"][i]);
											}
											if (find(GE.begin(), GE.end(), static_cast<PlayerInfo*>(currentPeer->data)->rawName) != GE.end()) {
												GE.erase(std::remove(GE.begin(), GE.end(), static_cast<PlayerInfo*>(currentPeer->data)->rawName), GE.end());
											}
											if (find(GC.begin(), GC.end(), static_cast<PlayerInfo*>(currentPeer->data)->rawName) != GC.end()) {
												GC.erase(std::remove(GC.begin(), GC.end(), static_cast<PlayerInfo*>(currentPeer->data)->rawName), GC.end());
											}
											j["Co-Leader"] = GC; //edit
											j["Elder-Leader"] = GE; //edit
											std::ofstream o("save/guilds/_" + PlayerDB::getProperName(((PlayerInfo*)(peer->data))->guild) + ".json"); //save
											if (!o.is_open()) continue;
											o << j << std::endl;
											Player::OnConsoleMessage(peer, "`wYou successfully demoted " + static_cast<PlayerInfo*>(currentPeer->data)->rawName + " to Member!");
											Player::OnAddNotification(currentPeer, "`wYou have been demoted to Member!", "audio/gong.wav", "interface/large/gd_prom.rttex");
											enet_peer_disconnect_later(currentPeer, 0);
										}
									}
								}
								if (btn == "promotetogc") {
									if (((PlayerInfo*)(peer->data))->currentWorld == "EXIT") continue;
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
										if (((PlayerInfo*)(currentPeer->data))->rawName == ((PlayerInfo*)(peer->data))->lastgm) {
											if (static_cast<PlayerInfo*>(currentPeer->data)->guild == "" || static_cast<PlayerInfo*>(currentPeer->data)->guild != static_cast<PlayerInfo*>(peer->data)->guild) continue;
											std::ifstream ifff("save/guilds/_" + PlayerDB::getProperName(((PlayerInfo*)(peer->data))->guild) + ".json");
											if (ifff.fail()) {
												ifff.close();
												Player::OnConsoleMessage(peer, "`4Error: `oGuild does not exist! If you are seeing this message, please take a screenshot and send it to a developer!");
												continue;
											}
											if (ifff.is_open()) {
											}
											json j;
											ifff >> j; //load
											vector<string> GC;
											vector<string> GE;
											for (int i = 0; i < j["Co-Leader"].size(); i++) {
												GC.push_back(j["Co-Leader"][i]);
											}
											for (int i = 0; i < j["Elder-Leader"].size(); i++) {
												GE.push_back(j["Elder-Leader"][i]);
											}
											if (find(GE.begin(), GE.end(), static_cast<PlayerInfo*>(currentPeer->data)->rawName) != GE.end()) {
												GE.erase(std::remove(GE.begin(), GE.end(), static_cast<PlayerInfo*>(currentPeer->data)->rawName), GE.end());
											}
											GC.push_back(static_cast<PlayerInfo*>(currentPeer->data)->rawName);
											j["Co-Leader"] = GC; //edit
											j["Elder-Leader"] = GE; // edit
											std::ofstream o("save/guilds/_" + PlayerDB::getProperName(((PlayerInfo*)(peer->data))->guild) + ".json"); //save
											if (!o.is_open()) continue;
											o << j << std::endl;
											string name2;
											string namemsg = ((PlayerInfo*)(currentPeer->data))->rawName;
											if (static_cast<PlayerInfo*>(currentPeer->data)->adminLevel != 0) {
												name2 = role_prefix.at(static_cast<PlayerInfo*>(currentPeer->data)->adminLevel) + static_cast<PlayerInfo*>(currentPeer->data)->tankIDName + " `6(GC)``";
											}
											else
											{
												name2 = "`w" + ((PlayerInfo*)(currentPeer->data))->displayName + " `6(GC)";
											}
											((PlayerInfo*)(currentPeer->data))->displayName = name2;
											((PlayerInfo*)(currentPeer->data))->msgName = namemsg;
											Player::OnConsoleMessage(peer, "`wYou successfully promoted " + static_cast<PlayerInfo*>(currentPeer->data)->rawName + " to Co-Leader!");
											Player::OnAddNotification(currentPeer, "`wYou have been promoted to Guild Co-Leader!", "audio/gong.wav", "interface/large/gd_prom.rttex");
											send_state(peer);
										}
									}
								}
								if (btn == "promotetoge") {
									if (((PlayerInfo*)(peer->data))->currentWorld == "EXIT") continue;
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
										if (((PlayerInfo*)(currentPeer->data))->rawName == ((PlayerInfo*)(peer->data))->lastgm) {
											if (static_cast<PlayerInfo*>(currentPeer->data)->guild == "" || static_cast<PlayerInfo*>(currentPeer->data)->guild != static_cast<PlayerInfo*>(peer->data)->guild) continue;
											std::ifstream ifff("save/guilds/_" + PlayerDB::getProperName(((PlayerInfo*)(peer->data))->guild) + ".json");
											if (ifff.fail()) {
												ifff.close();
												Player::OnConsoleMessage(peer, "`4Error: `oGuild does not exist! If you are seeing this message, please take a screenshot and send it to a developer!");
												continue;
											}
											if (ifff.is_open()) {
											}
											json j;
											ifff >> j; //load
											vector<string> GE;
											for (int i = 0; i < j["Elder-Leader"].size(); i++) {
												GE.push_back(j["Elder-Leader"][i]);
											}
											GE.push_back(static_cast<PlayerInfo*>(currentPeer->data)->rawName);
											j["Elder-Leader"] = GE; //edit
											std::ofstream o("save/guilds/_" + PlayerDB::getProperName(((PlayerInfo*)(peer->data))->guild) + ".json"); //save
											if (!o.is_open()) continue;
											o << j << std::endl;
											string name2;
											string namemsg = ((PlayerInfo*)(currentPeer->data))->rawName;
											if (static_cast<PlayerInfo*>(currentPeer->data)->adminLevel != 0) {
												name2 = role_prefix.at(static_cast<PlayerInfo*>(currentPeer->data)->adminLevel) + static_cast<PlayerInfo*>(currentPeer->data)->tankIDName + " `9(GE)``";
											}
											else
											{
												name2 = "`w" + ((PlayerInfo*)(currentPeer->data))->tankIDName + " `9(GE)";
											}
											((PlayerInfo*)(currentPeer->data))->displayName = name2;
											((PlayerInfo*)(currentPeer->data))->msgName = namemsg;
											Player::OnConsoleMessage(peer, "`wYou successfully promoted " + static_cast<PlayerInfo*>(currentPeer->data)->rawName + " to Guild-Elder!");
											Player::OnAddNotification(currentPeer, "`wYou have been promoted to Guild Elder!", "audio/gong.wav", "interface/large/gd_prom.rttex");
											send_state(peer);
										}
									}
								}
								if (btn == "removecon")
								{
									if (pData->currentWorld == "EXIT" || pData->haveGrowId == false)
									{
										continue;
									}
									try {
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
											if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == pData->lastFrn) {
												pData->friendinfo.erase(std::remove(pData->friendinfo.begin(), pData->friendinfo.end(), pData->lastFrn), pData->friendinfo.end());
												static_cast<PlayerInfo*>(currentPeer->data)->friendinfo.erase(std::remove(static_cast<PlayerInfo*>(currentPeer->data)->friendinfo.begin(), static_cast<PlayerInfo*>(currentPeer->data)->friendinfo.end(), pData->rawName), static_cast<PlayerInfo*>(currentPeer->data)->friendinfo.end());
												string friends_string = "";
												for (int i = 0; i < pData->friendinfo.size(); i++) {
													friends_string += pData->friendinfo.at(i) + ",";
												}
												ifstream read_player("save/players/_" + pData->rawName + ".json");
												if (!read_player.is_open()) {
													continue;
												}
												json j;
												read_player >> j;
												read_player.close();
												j["friends"] = friends_string;
												ofstream write_player("save/players/_" + pData->rawName + ".json");
												write_player << j << std::endl;
												write_player.close();
												string friends_string2 = "";
												for (int i = 0; i < static_cast<PlayerInfo*>(currentPeer->data)->friendinfo.size(); i++) {
													friends_string2 += static_cast<PlayerInfo*>(currentPeer->data)->friendinfo.at(i) + ",";
												}
												ifstream read_player3("save/players/_" + static_cast<PlayerInfo*>(currentPeer->data)->rawName + ".json");
												if (!read_player3.is_open()) {
													continue;
												}
												json j3;
												read_player3 >> j3;
												read_player3.close();
												j3["friends"] = friends_string2;
												ofstream write_player3("save/players/_" + static_cast<PlayerInfo*>(currentPeer->data)->rawName + ".json");
												write_player3 << j3 << std::endl;
												write_player3.close();
												Player::OnConsoleMessage(currentPeer, "`3FRIEND ALERT: `2" + pData->displayName + " `ohas removed you as a friend.");
												Player::OnDialogRequest(peer, "set_default_color|`o\n\nadd_label_with_icon|big|`4Friend removed``|left|1366|\n\nadd_spacer|small|\nadd_textbox|`oOk, you are no longer friends with `o" + pData->lastFrnName + ".``|\n\nadd_spacer|small|\nadd_button||`oOK``|0|0|\nadd_quick_exit|");
												break;
											}
										}
									}
									catch (const std::out_of_range& e) {
										std::cout << e.what() << std::endl;
									}
									catch (std::exception& e) {
										std::cout << e.what() << std::endl;
									}
								}
								if (btn == "removeconoff") {
									if (pData->currentWorld == "EXIT") {
										continue;
									}
									if (pData->haveGrowId == false) {
										continue;
									}
									try {
										pData->friendinfo.erase(std::remove(pData->friendinfo.begin(), pData->friendinfo.end(), pData->lastFrn), pData->friendinfo.end());
										ifstream read_player("save/players/_" + pData->lastFrn + ".json");
										if (!read_player.is_open()) {
											continue;
										}
										json j;
										read_player >> j;
										read_player.close();
										string Friends = j["friends"];
										stringstream ss(Friends);
										vector<string> result;
										while (ss.good()) {
											string substr;
											getline(ss, substr, ',');
											if (substr.size() == 0) continue;
											result.push_back(substr);
										}
										result.erase(std::remove(result.begin(), result.end(), pData->rawName), result.end());
										string friends_string = "";
										for (int i = 0; i < result.size(); i++) {
											friends_string += result.at(i) + ",";
										}
										j["friends"] = friends_string;
										ofstream write_player("save/players/_" + pData->lastFrn + ".json");
										write_player << j << std::endl;
										write_player.close();
										ifstream read_player3("save/players/_" + pData->rawName + ".json");
										if (!read_player3.is_open()) {
											continue;
										}
										json j3;
										read_player3 >> j3;
										read_player3.close();
										string friends_string3 = "";
										for (int i = 0; i < pData->friendinfo.size(); i++) {
											friends_string3 += pData->friendinfo.at(i) + ",";
										}
										j3["friends"] = friends_string3;
										ofstream write_player3("save/players/_" + pData->rawName + ".json");
										write_player3 << j3 << std::endl;
										write_player3.close();
										Player::OnDialogRequest(peer, "set_default_color|`o\n\nadd_label_with_icon|big|`4Friend removed``|left|1366|\n\nadd_spacer|small|\nadd_textbox|`oOk, you are no longer friends with `o" + pData->lastFrn + ".``|\n\nadd_spacer|small|\nadd_button||`oOK``|0|0|\nadd_quick_exit|");
									}
									catch (const std::out_of_range& e) {
										std::cout << e.what() << std::endl;
									}
									catch (std::exception& e) {
										std::cout << e.what() << std::endl;
									}
								}
								if (btn.substr(0, 11) == "onlinefrns_")
								{
									if (pData->currentWorld == "EXIT")
									{
										continue;
									}
									ENetPeer* currentPeer;
									for (currentPeer = server->peers;
										currentPeer < &server->peers[server->peerCount];
										++currentPeer)
									{
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL)
											continue;
										if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == btn.substr(11, cch.length() - 11 - 1))
										{
											pData->lastFrnWorld = static_cast<PlayerInfo*>(currentPeer->data)->currentWorld;
											pData->lastFrnName = static_cast<PlayerInfo*>(currentPeer->data)->tankIDName;
											pData->lastFrn = static_cast<PlayerInfo*>(currentPeer->data)->rawName;
										}
									}
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`w" + pData->lastFrnName + "``|left|1366|\n\nadd_spacer|small|\nadd_textbox|`o" + pData->lastFrnName + " is `2online `onow in the world `5" + pData->lastFrnWorld + "`o.|\n\nadd_spacer|small|\nadd_button|frnwarpbutton|`oWarp to `5" + pData->lastFrnWorld + "``|0|0|\nadd_button|msgbutton|`5Send message``|0|0|\n\nadd_spacer|small|\nadd_button|removecon|`oRemove as friend``|0|0|\nadd_button|showfriend|`oBack``|0|0|\nadd_quick_exit|"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
								}
								if (btn == "msgbutton")
								{
									if (pData->currentWorld == "EXIT")
									{
										continue;
									}
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "add_label_with_icon|big|`5Message to `o" + pData->lastFrnName + "|left|660|\nadd_spacer|small|\nadd_text_input|msgtext|||50|\nend_dialog|msgdia|Cancel|`5Send``| \nadd_spacer|big|\nadd_button|showfriend|`oBack``|0|0|\nadd_quick_exit|\n"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
								}
								if (btn.substr(0, 12) == "offlinefrns_")
								{
									if (pData->currentWorld == "EXIT")
									{
										continue;
									}
									pData->lastFrn = btn.substr(12, cch.length() - 12 - 1);
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`w" + pData->lastFrn + "``|left|1366|\n\nadd_spacer|small|\nadd_textbox|`o" + pData->lastFrn + " is `4offline`o.``|\nadd_spacer|small|\nadd_button|removeconoff|`oRemove as friend``|0|0|\nadd_button|showoffline|`oBack``|0|0|\nadd_quick_exit|"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
								}
								if (btn == "addfriendrnbutton") {
									if (pData->haveGrowId == true) {
										try {
											for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
												if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == pData->lastInfo) {
													if (pData->lastfriend == static_cast<PlayerInfo*>(currentPeer->data)->rawName) {
														pData->friendinfo.push_back(static_cast<PlayerInfo*>(currentPeer->data)->rawName); //add
														static_cast<PlayerInfo*>(currentPeer->data)->friendinfo.push_back(pData->rawName);
														string friends_string = "";
														for (int i = 0; i < pData->friendinfo.size(); i++) {
															friends_string += pData->friendinfo.at(i) + ",";
														}
														ifstream read_player("save/players/_" + pData->rawName + ".json");
														if (!read_player.is_open()) {
															continue;
														}
														json j;
														read_player >> j;
														read_player.close();
														j["friends"] = friends_string;
														ofstream write_player("save/players/_" + pData->rawName + ".json");
														write_player << j << std::endl;
														write_player.close();
														string friends_string2 = "";
														for (int i = 0; i < static_cast<PlayerInfo*>(currentPeer->data)->friendinfo.size(); i++) {
															friends_string2 += static_cast<PlayerInfo*>(currentPeer->data)->friendinfo.at(i) + ",";
														}
														ifstream read_player3("save/players/_" + static_cast<PlayerInfo*>(currentPeer->data)->rawName + ".json");
														if (!read_player3.is_open()) {
															continue;
														}
														json j3;
														read_player3 >> j3;
														read_player3.close();
														j3["friends"] = friends_string2;
														ofstream write_player3("save/players/_" + static_cast<PlayerInfo*>(currentPeer->data)->rawName + ".json");
														write_player3 << j3 << std::endl;
														write_player3.close();
														string text = "action|play_sfx\nfile|audio/love_in.wav\ndelayMS|0\n";
														BYTE* data = new BYTE[5 + text.length()];
														BYTE zero = 0;
														int type = 3;
														memcpy(data, &type, 4);
														memcpy(data + 4, text.c_str(), text.length());
														memcpy(data + 4 + text.length(), &zero, 1);
														ENetPacket* packet2 = enet_packet_create(data,
															5 + text.length(),
															ENET_PACKET_FLAG_RELIABLE);
														enet_peer_send(currentPeer, 0, packet2);
														enet_peer_send(peer, 0, packet2);
														delete[] data;
														GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`3FRIEND ADDED: `oYou're now friends with `w" + pData->displayName + "`o!"));
														ENetPacket* packet = enet_packet_create(p.data,
															p.len,
															ENET_PACKET_FLAG_RELIABLE);
														enet_peer_send(currentPeer, 0, packet);
														delete p.data;
														GamePacket p3 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`3FRIEND ADDED: `oYou're now friends with `w" + static_cast<PlayerInfo*>(currentPeer->data)->displayName + "`o!"));
														ENetPacket* packet3 = enet_packet_create(p3.data,
															p3.len,
															ENET_PACKET_FLAG_RELIABLE);
														enet_peer_send(peer, 0, packet3);
														delete p3.data;
													}
													else
													{
														GamePacket p4 = packetEnd(appendString(appendIntx(appendString(createPacket(), "OnTalkBubble"), pData->netID), "`5[`wFriend request sent to " + static_cast<PlayerInfo*>(currentPeer->data)->displayName + "`5]"));
														ENetPacket* packet4 = enet_packet_create(p4.data,
															p4.len,
															ENET_PACKET_FLAG_RELIABLE);
														enet_peer_send(peer, 0, packet4);
														delete p4.data;
														string text = "action|play_sfx\nfile|audio/tip_start.wav\ndelayMS|0\n";
														BYTE* data = new BYTE[5 + text.length()];
														BYTE zero = 0;
														int type = 3;
														memcpy(data, &type, 4);
														memcpy(data + 4, text.c_str(), text.length());
														memcpy(data + 4 + text.length(), &zero, 1);
														ENetPacket* packet2 = enet_packet_create(data,
															5 + text.length(),
															ENET_PACKET_FLAG_RELIABLE);
														enet_peer_send(currentPeer, 0, packet2);
														delete[] data;
														static_cast<PlayerInfo*>(currentPeer->data)->lastfriend = pData->rawName;
														GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`3FRIEND REQUEST: `oYou've received a `wfriend request `ofrom `w" + pData->displayName + "`o! To accept, click the `wwrench by his/her name `oand then choose `wAdd as friend`o."));
														ENetPacket* packet = enet_packet_create(p.data,
															p.len,
															ENET_PACKET_FLAG_RELIABLE);
														enet_peer_send(currentPeer, 0, packet);
														delete p.data;
													}
												}
											}
										}
										catch (const std::out_of_range& e) {
											std::cout << e.what() << std::endl;
										}
										catch (std::exception& e) {
											std::cout << e.what() << std::endl;
										}
									}
									else
									{
										SendRegisterDialog(peer);
									}
								}
								break;
							}
							else if (cch.find("action|drop\n|itemID|") == 0)
							{
								if (pData->haveGrowId == true)
								{
									if (pData->isCursed == true)
									{
										Player::OnConsoleMessage(peer, "`4You are cursed now!");
										continue;
									}
									try {
										if (pData->trade == true) end_trade(peer);
										std::stringstream ss(cch);
										std::string to;
										int idx = -1;
										int count = -1;
										while (std::getline(ss, to, '\n'))
										{
											vector<string> infoDat = explode("|", to);
											if (infoDat.size() == 3)
											{
												if (infoDat.at(1) == "itemID") idx = atoi(infoDat.at(2).c_str());
												if (infoDat.at(1) == "count") count = atoi(infoDat.at(2).c_str());
											}
										}
										pData->lastdropitem = idx;
										pData->lastdropitemcount = count;
										if (idx == -1) continue;
										if (itemDefs.size() < idx || idx < 0) continue;
										if (pData->lastdropitem == 6260 || getItemDef(pData->lastdropitem).properties || pData->lastdropitem == 18 || pData->lastdropitem == 32 || pData->lastdropitem == 6336 || pData->lastdropitem == 1794 || pData->lastdropitem == 5640 || pData->lastdropitem == 1424 || pData->lastdropitem == 6260) {
											if (!isDev(peer) && !isPlayer(peer) && !pData->Subscriber || pData->lastdropitem == 18 || pData->lastdropitem == 5640 || pData->lastdropitem == 32 || pData->lastdropitem == 6336 || pData->lastdropitem == 1486 || pData->lastdropitem == 1794 || pData->lastdropitem == 1424 || pData->lastdropitem == 6260) {
												Player::OnTextOverlay(peer, "You can't drop that.");
												continue;
											}
										}
										if (pData->trade == true)
										{
											Player::OnTextOverlay(peer, "You can't drop while trading");
											end_trade(peer);
											continue;
										}
										if (jammers) {
											bool minimod = false;
											for (auto i = 0; i < world->width * world->height; i++) {
												if (world->items.at(i).foreground == 4758 && world->items.at(i).activated) {
													minimod = true;
													continue;
												}
											}
											if (minimod) {
												Player::OnTextOverlay(peer, "The Mini-Mod says no dropping items in this world!");
												continue;
											}
										}
										/*if (getItemDef(world->items.at(x + (y * world->width)).foreground).blockType == BlockTypes::FOREGROUND && world->items.at(x + (y * world->width)).foreground != 0)
										{
											Player::OnTextOverlay(peer, "You can't drop that here, face somewhere with open space.");
											continue;
										}*/
										auto KiekTuri = 0;
										for (auto i = 0; i < pData->inventory.items.size(); i++)
										{
											if (pData->inventory.items.at(i).itemID == pData->lastdropitem && pData->inventory.items.at(i).itemCount >= 1)
											{
												KiekTuri = pData->inventory.items.at(i).itemCount;
												break;
											}
										}
										Player::OnDialogRequest(peer, "add_label_with_icon|big|`wDrop " + itemDefs.at(idx).name + "``|left|" + std::to_string(idx) + "|\nadd_textbox|`oHow many to drop?|\nadd_text_input|dropitemcount||" + to_string(KiekTuri) + "|3|||\nadd_textbox|`4Warning:`` Any player who asks you to drop items is scamming you. We cannot restore scammed items.|left|\nend_dialog|dropdialog|Cancel|OK|\n"); // \nadd_button|drop_inv|Drop Inventory|
									}
									catch (const std::out_of_range& e) {
										std::cout << e.what() << std::endl;
									}
								}
								break;
							}
							else if (cch.find("action|trash\n|itemID|") == 0) {
								try {
									if (pData->trade) end_trade(peer);
									std::stringstream ss(cch);
									std::string to;
									int idx = -1;
									int count = -1;
									while (std::getline(ss, to, '\n')) {
										vector<string> infoDat = explode("|", to);
										if (infoDat.size() == 3) {
											if (infoDat.at(1) == "itemID") idx = atoi(infoDat.at(2).c_str());
											if (infoDat.at(1) == "count") count = atoi(infoDat.at(2).c_str());
										}
									}
									pData->lasttrashitem = idx;
									if (idx == -1) continue;
									if (itemDefs.size() < idx || idx < 0) continue;
									if (pData->lasttrashitem == 18 || pData->lasttrashitem == 32 || pData->lasttrashitem == 6336) {
										if (getItemDef(pData->lasttrashitem).properties & Property_Untradable) {
										}
										else {
											Player::OnTextOverlay(peer, "You can't trash that.");
											continue;
										}
									}
									else {
										auto KiekTuri = 0;
										for (auto i = 0; i < pData->inventory.items.size(); i++) {
											if (pData->inventory.items.at(i).itemID == pData->lasttrashitem && pData->inventory.items.at(i).itemCount >= 1) {
												KiekTuri = pData->inventory.items.at(i).itemCount;
												break;
											}
										}
										if (getItemDef(idx).blockType == BlockTypes::FISH) {
											Player::OnDialogRequest(peer, "add_label_with_icon|big|`4Recycle `w" + itemDefs.at(idx).name + "``|left|" + std::to_string(idx) + "|\nadd_label|small|You will get up to 5 gems per item.|left|\nadd_textbox|`oHow many to `4destroy`o? (you have " + to_string(KiekTuri) + ")|\nadd_text_input|trashitemcount||0|3|\nend_dialog|trashdialog|Cancel|OK|\n");
										}
										else {
											Player::OnDialogRequest(peer, "add_label_with_icon|big|`4Trash `w" + itemDefs.at(idx).name + "``|left|" + std::to_string(idx) + "|\nadd_textbox|`oHow many to `4destroy`o? (you have " + to_string(KiekTuri) + ")|\nadd_text_input|trashitemcount||0|3|\nend_dialog|trashdialog|Cancel|OK|\n");
										}
									}
								}
								catch (const std::out_of_range& e) {
									std::cout << e.what() << std::endl;
								}
								break;
							}
							else if (cch.find("text|") != std::string::npos) {
								bool canchat = true;
								string str = cch.substr(cch.find("text|") + 5, cch.length() - cch.find("text|") - 1);
								if (str.length() > 120) continue;
								if (pData->currentWorld == "EXIT" || world == nullptr) continue;
								if (str.length() && str.at(0) == '/') {
									sendAction(peer, pData->netID, str);
									if (str.find("/msg ") != string::npos) {
										Player::OnConsoleMessage(peer, "CP:_PL:0_OID:_CT:[MSG]_ `6" + str);
									} else if (str.find("/r ") != string::npos) {
										Player::OnConsoleMessage(peer, "CP:_PL:0_OID:_CT:[MSG]_ `6" + str);
									} else if (str.find("/sb ") != string::npos) {
										Player::OnConsoleMessage(peer, "CP:_PL:0_OID:_CT:[SB]_ `6" + str);
									} else if (str.find("/ssb ") != string::npos) {
										Player::OnConsoleMessage(peer, "CP:_PL:0_OID:_CT:[CB]_ `6" + str);
									} else {
										Player::OnConsoleMessage(peer, "`6" + str);
									}
								}
								if (pData->taped == false) {
									if (world->silence == true && !isWorldOwner(peer, world)) {
										Player::OnTalkBubble(peer, pData->netID, "`1(Peasants must not to talk)", 0, true);
										continue;
									}
									SendChat(peer, pData->netID, str, world, cch);
								} 
								else {
									for (char c : str) {
										if (str.find(" ")) canchat = false;
									}
									if (canchat) {
										if (pData->cantsay) {
											const string mf[4] = { "mf ff mf fm", "f fmf fmfmf fmm", "mfm ff mf mf", "mff ffmf mf " };
											string word = mf[rand() % 4];
											if (world->silence == true && !isWorldOwner(peer, world)) {
												Player::OnTalkBubble(peer, pData->netID, "`1(Peasants must not to talk)", 0, true);
												continue;
											}
											SendChat(peer, pData->netID, word, world, cch);
											continue;
										} else {
											pData->taped = false;
											pData->isDuctaped = false;
											pData->cantsay = false;
											send_state(peer);
											sendClothes(peer);
										}
									}
								}
								break;
							} else if (cch.find("tankIDName") || cch.find("tankIDPass")) {
								cch.clear();
								cch.erase(std::remove(cch.begin(), cch.end(), '\n'), cch.end());

								if (find(unknown_packets.begin(), unknown_packets.end(), cch) == unknown_packets.end()) {
									SendConsole("Unknown array of data " + cch, "WARN");
									unknown_packets.push_back(cch);
								}
								break;
							} else {
								cch.erase(std::remove(cch.begin(), cch.end(), '\n'), cch.end());
								if (find(unknown_packets.begin(), unknown_packets.end(), cch) == unknown_packets.end()) {
									SendConsole("Unknown array of data " + cch, "WARN");
									unknown_packets.push_back(cch); 
								}
								break;
							}
							break;
						}
						case 3:
						{
							stringstream ss(GetTextPointerFromPacket(event.packet));
							string cch = GetTextPointerFromPacket(event.packet);
							if (cch.find("action|world_button") == 0) {
								if (cch.find("action|world_button\nname|_catselect_") == 0) {
									string worldOffers = "";
									worldOffers = "\nadd_button|Random|_0|0.8|3529161471|\nadd_button|Your Worlds|_16|0.8|3529161471|\nadd_button|Mining|_17|0.8|3529161471|\nadd_button|Adventure|_1|0.8|3529161471|\nadd_button|Art|_2|0.8|3529161471|\nadd_button|Farm|_3|0.8|3529161471|\nadd_button|Game|_4|0.8|3529161471|\nadd_button|Guild|_13|0.8|3529161471|\nadd_button|Information|_5|0.8|3529161471|\nadd_button|Music|_15|0.8|3529161471|\nadd_button|Parkour|_6|0.8|3529161471|\nadd_button|Puzzle|_14|0.8|3529161471|\nadd_button|Roleplay|_7|0.8|3529161471|\nadd_button|Shop|_8|0.8|3529161471|\nadd_button|Social|_9|0.8|3529161471|\nadd_button|Storage|_10|0.8|3529161471|\nadd_button|Story|_11|0.8|3529161471|\nadd_button|Trade|_12|0.8|3529161471|";
									auto p3 = packetEnd(appendString(appendString(createPacket(), "OnRequestWorldSelectMenu"), worldOffers));
									const auto packet3 = enet_packet_create(p3.data, p3.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet3);
									delete p3.data;
								} 
								else if (cch.find("action|world_button\nname|_0") == 0) {
									sendWorldOffers(peer);
								} 
								else if (cch.find("action|world_button\nname|_16") == 0) {
									try {
										string worldOffers = "\nadd_button|Showing: `wYour Worlds``|_catselect_|0.6|3529161471|\n";
										std::sort(pData->worldsowned.begin(), pData->worldsowned.end());
										auto it = std::unique(pData->worldsowned.begin(), pData->worldsowned.end());
										pData->worldsowned.erase(it, pData->worldsowned.end());
										for (int i = 0; i < pData->worldsowned.size(); i++) {
											worldOffers += "add_floater|" + pData->worldsowned.at(i) + "|0|0.5|3417414143|\n";
										}
										auto p3 = packetEnd(appendString(appendString(createPacket(), "OnRequestWorldSelectMenu"), worldOffers));
										const auto packet3 = enet_packet_create(p3.data, p3.len, ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet3);
										delete p3.data;
									}
									catch (const std::out_of_range& e) {
										std::cout << e.what() << std::endl;
									}
								}
								break;
							}
							string to = "", name = "";
							bool isJoinReq = false;
							while (std::getline(ss, to, '\n')) {
								if (to.find('|') == -1) continue;
								string id = "";
								id = to.substr(0, to.find("|"));
								string act = "";
								act = to.substr(to.find("|") + 1, to.length() - to.find("|") - 1);
								if (id == "invitedWorld") {
									handle_world(peer, name);
								}
								if (id == "name" && isJoinReq) {
									name = act;
								}
								if (id == "action") {
									if (act == "join_request") {
										isJoinReq = true;
									}
									if (act == "quit_to_exit") {
										if (pData->HasLogged || !pData->haveGrowId) {
											if (pData->currentWorld == "EXIT") {
												enet_peer_disconnect_later(peer, 0);
												break;
											}
											Player::OnConsoleMessage(peer, "Where would you like to go? (`w" + GetPlayerCountServer() + " `oonline)");
											sendPlayerLeave(peer);
											sendWorldOffers(peer);
										}
									}
									if (act == "quit") {
										enet_peer_disconnect_later(peer, 0);
									}
								}
							}
							break;
						}
						case 4:
						{
							if (pData->currentWorld == "EXIT" || world == NULL) continue;  
							BYTE* tankUpdatePacket = GetStructPointerFromTankPacket(event.packet);
							if (tankUpdatePacket) {
								PlayerMoving* pMov = unpackPlayerMoving(tankUpdatePacket);
								if (!pData->canWalkInBlocks) {
									if ((pMov->characterState >= 80 || pMov->characterState == 64) && pMov->characterState != 160 && pMov->characterState != 144 && pMov->characterState != 128 && pMov->characterState < 250) {
										pData->lavaLevel = pData->lavaLevel + 1;
										if (pData->lavaLevel >= 5) {
											pData->lavaLevel = 0;
											playerRespawn(world, peer, false);
										}
									}
								}

								if (world->name == "LEGENDARYMOUNTAIN") {
									try {
										for (auto i = 0; i < world->width * world->height; i++) {
											if (world->items.at(i).foreground == 1792) {
												int x = i % world->width, y = i / world->width;
												if (pData->x / 32 == x && pData->y / 32 == y) {
													bool iscontains = false;
													SearchInventoryItem(peer, 1794, 1, iscontains);
													if (!iscontains) {
														bool success = false;
														SaveItemMoreTimes(1794, 1, peer, success);
														for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
															if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
															if (isHere(peer, currentPeer)) {
																Player::OnParticleEffect(currentPeer, 46, pData->x, pData->y, 0);
															}
														}
														Player::OnTalkBubble(peer, pData->netID, "`9You have claimed a Legendary Orb!", 0, true);
													}
												}
												break;
											}
										}
									}
									catch (const std::out_of_range& e) {
										std::cout << e.what() << std::endl;
									}
								}
								for (auto i = 0; i < world->width * world->height; i++) {
									if (world->items.at(i).foreground == 4722) {
										int x = i % world->width, y = i / world->width;
										if (pData->x / 32 == x && pData->y / 32 == y) {
											bool iscontains = false;
											if (!iscontains) {
												bool success = false;
												if (static_cast<PlayerInfo*>(peer->data)->AdventureStarted) { //blocks if you have saw it already
													continue;
													break;
												}
												for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
													if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
													if (isHere(peer, currentPeer)) {
													}
												}
												Player::OnAddNotification(peer, world->items.at(i).sign, "audio/hub_open.wav", "interface/large/adventure.rttex");
												static_cast<PlayerInfo*>(peer->data)->AdventureStarted = true; //fix spam
											}
										}
										break;
									}
								}
								switch (pMov->packetType) {
								case 0:
									{
										pData->x = pMov->x;
										pData->y = pMov->y;
										pData->isRotatedLeft = pMov->characterState & 0x10;
										sendPData(peer, pMov);
										if (pData->isinv == false) {
											if (pData->cloth_necklace == 9168) {
												if (!visibleparticles) {
													Player::OnParticleEffect(peer, 125, pData->x, pData->y, 0);
												}
												else {
													for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
														if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
														if (isHere(peer, currentPeer)) {
															Player::OnParticleEffect(currentPeer, 125, pData->x, pData->y, 0);
														}
													}
												}
											}
											if (pData->cloth_back == 9152) {
												if (!visibleparticles) {
													Player::OnParticleEffect(peer, 125, pData->x, pData->y, 0);
												}
												else {
													for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
														if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
														if (isHere(peer, currentPeer)) {
															Player::OnParticleEffect(currentPeer, 359, pData->x, pData->y, 0);
														}
													}
												}
											} 
											else if (pData->cloth_back == 9222) {
												if (!visibleparticles) {
													Player::OnParticleEffect(peer, 125, pData->x, pData->y, 0);
												}
												else {
													for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
														if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
														if (isHere(peer, currentPeer)) {
															Player::OnParticleEffect(currentPeer, 321, pData->x + rand() % 35 - 20, pData->y + rand() % 35 - 20, 0);
															Player::OnParticleEffect(currentPeer, 322, pData->x + rand() % 35 - 20, pData->y + rand() % 35 - 20, 0);
															Player::OnParticleEffect(currentPeer, 321, pData->x + rand() % 35 - 20, pData->y + rand() % 35 - 20, 0);
															Player::OnParticleEffect(currentPeer, 322, pData->x + rand() % 35 - 20, pData->y + rand() % 35 - 20, 0);
															Player::OnParticleEffect(currentPeer, 321, pData->x + rand() % 35 - 20, pData->y + rand() % 35 - 20, 0);
															Player::OnParticleEffect(currentPeer, 322, pData->x + rand() % 35 - 20, pData->y + rand() % 35 - 20, 0);
														}
													}
												}
											} 
											else if (pData->cloth_back == 9154) {
												if (!visibleparticles) {
													Player::OnParticleEffect(peer, 125, pData->x, pData->y, 0);
												}
												else {
													for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
														if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
														if (isHere(peer, currentPeer)) {
															Player::OnParticleEffect(currentPeer, 150, pData->x, pData->y, 0);
														}
													}
												}
											}
											else if (pData->cloth_face == 3774) {
												pData->noEyes = true;
												send_state(peer);
												if (pData->cloth_back == 10426 || pData->cloth_back == 156 || pData->cloth_back == 9006 || pData->cloth_back == 1958 || getItemDef(pData->cloth_back).name.find("Aura") != string::npos || pData->cloth_back == 9476 || pData->cloth_back == 9434 || getItemDef(pData->cloth_back).name.find("Wings") != string::npos || getItemDef(pData->cloth_back).name.find("Cape") != string::npos || pData->cloth_back == 8580 || pData->cloth_back == 5158 || pData->cloth_back == 9410 || pData->cloth_back == 9306 || pData->cloth_back == 10022 || pData->cloth_back == 8308 || pData->cloth_back == 7834 || pData->cloth_back == 10020 || pData->cloth_back == 9760 || pData->cloth_back == 10016 || pData->cloth_back == 10012 || pData->cloth_back == 1674 || pData->cloth_back == 9478 || pData->cloth_back == 9506 || pData->cloth_back == 9476 || pData->cloth_back == 1970 || pData->cloth_back == 8286 || pData->cloth_back == 9506 || pData->cloth_back == 9478 || pData->cloth_back == 8552 || pData->cloth_back == 362 || pData->cloth_back == 678 || pData->cloth_back == 736 || pData->cloth_back == 7734 || pData->cloth_back == 7762 || pData->cloth_back == 818 || pData->cloth_back == 1206 || pData->cloth_back == 1460 || pData->cloth_back == 1550 || pData->cloth_back == 1574 || pData->cloth_back == 1668 || pData->cloth_back == 1672 || pData->cloth_back == 1674 || pData->cloth_back == 1784 || pData->cloth_back == 1824 || pData->cloth_back == 1936 || pData->cloth_back == 1938 || pData->cloth_back == 1970 || pData->cloth_back == 2254 || pData->cloth_back == 2256 || pData->cloth_back == 2258 || pData->cloth_back == 2260 || pData->cloth_back == 2262 || pData->cloth_back == 2264 || pData->cloth_back == 2390 || pData->cloth_back == 2392 || pData->cloth_back == 3120 || pData->cloth_back == 3308 || pData->cloth_back == 3512 || pData->cloth_back == 4534 || pData->cloth_back == 4986 || pData->cloth_back == 5754 || pData->cloth_back == 6144 || pData->cloth_back == 6334 || pData->cloth_back == 6694 || pData->cloth_back == 6818 || pData->cloth_back == 6842 || pData->cloth_back == 1934 || pData->cloth_back == 3134 || pData->cloth_back == 6004 || pData->cloth_back == 1780 || pData->cloth_back == 2158 || pData->cloth_back == 2160 || pData->cloth_back == 2162 || pData->cloth_back == 2164 || pData->cloth_back == 2166 || pData->cloth_back == 2168 || pData->cloth_back == 2438 || pData->cloth_back == 2538 || pData->cloth_back == 2778 || pData->cloth_back == 3858 || pData->cloth_back == 350 || pData->cloth_back == 998 || pData->cloth_back == 1738 || pData->cloth_back == 2642 || pData->cloth_back == 2982 || pData->cloth_back == 3104 || pData->cloth_back == 3144 || pData->cloth_back == 5738 || pData->cloth_back == 3112 || pData->cloth_back == 2722 || pData->cloth_back == 3114 || pData->cloth_back == 4970 || pData->cloth_back == 4972 || pData->cloth_back == 5020 || pData->cloth_back == 6284 || pData->cloth_back == 4184 || pData->cloth_back == 4628 || pData->cloth_back == 5322 || pData->cloth_back == 4112 || pData->cloth_back == 4114 || pData->cloth_back == 3442 || pData->cloth_back == 9466 || pData->cloth_back == 8286 || pData->cloth_back == 5136 || pData->cloth_back == 9416 || pData->cloth_back == 9356) {
													pData->canDoubleJump = true;
												}
												else {
													pData->canDoubleJump = false;
												}
											}
											else if (pData->cloth_face != 3774 && pData->noEyes == true) {
												pData->noEyes = false;
												send_state(peer);
												if (pData->cloth_back == 10426 || pData->cloth_back == 156 || pData->cloth_back == 9006 || pData->cloth_back == 1958 || getItemDef(pData->cloth_back).name.find("Aura") != string::npos || pData->cloth_back == 9476 || pData->cloth_back == 9434 || getItemDef(pData->cloth_back).name.find("Wings") != string::npos || getItemDef(pData->cloth_back).name.find("Cape") != string::npos || pData->cloth_back == 8580 || pData->cloth_back == 5158 || pData->cloth_back == 9410 || pData->cloth_back == 9306 || pData->cloth_back == 10022 || pData->cloth_back == 8308 || pData->cloth_back == 7834 || pData->cloth_back == 10020 || pData->cloth_back == 9760 || pData->cloth_back == 10016 || pData->cloth_back == 10012 || pData->cloth_back == 1674 || pData->cloth_back == 9478 || pData->cloth_back == 9506 || pData->cloth_back == 9476 || pData->cloth_back == 1970 || pData->cloth_back == 8286 || pData->cloth_back == 9506 || pData->cloth_back == 9478 || pData->cloth_back == 8552 || pData->cloth_back == 362 || pData->cloth_back == 678 || pData->cloth_back == 736 || pData->cloth_back == 7734 || pData->cloth_back == 7762 || pData->cloth_back == 818 || pData->cloth_back == 1206 || pData->cloth_back == 1460 || pData->cloth_back == 1550 || pData->cloth_back == 1574 || pData->cloth_back == 1668 || pData->cloth_back == 1672 || pData->cloth_back == 1674 || pData->cloth_back == 1784 || pData->cloth_back == 1824 || pData->cloth_back == 1936 || pData->cloth_back == 1938 || pData->cloth_back == 1970 || pData->cloth_back == 2254 || pData->cloth_back == 2256 || pData->cloth_back == 2258 || pData->cloth_back == 2260 || pData->cloth_back == 2262 || pData->cloth_back == 2264 || pData->cloth_back == 2390 || pData->cloth_back == 2392 || pData->cloth_back == 3120 || pData->cloth_back == 3308 || pData->cloth_back == 3512 || pData->cloth_back == 4534 || pData->cloth_back == 4986 || pData->cloth_back == 5754 || pData->cloth_back == 6144 || pData->cloth_back == 6334 || pData->cloth_back == 6694 || pData->cloth_back == 6818 || pData->cloth_back == 6842 || pData->cloth_back == 1934 || pData->cloth_back == 3134 || pData->cloth_back == 6004 || pData->cloth_back == 1780 || pData->cloth_back == 2158 || pData->cloth_back == 2160 || pData->cloth_back == 2162 || pData->cloth_back == 2164 || pData->cloth_back == 2166 || pData->cloth_back == 2168 || pData->cloth_back == 2438 || pData->cloth_back == 2538 || pData->cloth_back == 2778 || pData->cloth_back == 3858 || pData->cloth_back == 350 || pData->cloth_back == 998 || pData->cloth_back == 1738 || pData->cloth_back == 2642 || pData->cloth_back == 2982 || pData->cloth_back == 3104 || pData->cloth_back == 3144 || pData->cloth_back == 5738 || pData->cloth_back == 3112 || pData->cloth_back == 2722 || pData->cloth_back == 3114 || pData->cloth_back == 4970 || pData->cloth_back == 4972 || pData->cloth_back == 5020 || pData->cloth_back == 6284 || pData->cloth_back == 4184 || pData->cloth_back == 4628 || pData->cloth_back == 5322 || pData->cloth_back == 4112 || pData->cloth_back == 4114 || pData->cloth_back == 3442 || pData->cloth_back == 9466 || pData->cloth_back == 8286 || pData->cloth_back == 5136 || pData->cloth_back == 9416 || pData->cloth_back == 9356) {
													pData->canDoubleJump = true;
												}
												else {
													pData->canDoubleJump = false;
												}
											}
											else if (pData->cloth_back == 9162) {
												if (!visibleparticles) {
													Player::OnParticleEffect(peer, 125, pData->x, pData->y, 0);
												}
												else {
													for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
														if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
														if (isHere(peer, currentPeer)) {
															Player::OnParticleEffect(currentPeer, 215, pData->x, pData->y, 0);
														}
													}
												}
											}
											if (pData->cloth_hand == 2204) {
												if (pData->lastSYNC + 600 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) {
													pData->lastSYNC = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
													find_geiger(peer);
												}
											}
										}
										if (pData->billboardid == 0) {

										}
										else {
											BillBoard(peer, ((PlayerInfo*)(peer->data))->billboardid, ((PlayerInfo*)(peer->data))->billboardprice, ((PlayerInfo*)(peer->data))->billboardtab, ((PlayerInfo*)(peer->data))->billboardperwhat);
										}
										if (!pData->joinClothesUpdated) {
											pData->joinClothesUpdated = true;
											updateAllClothes(peer);
											updateInvis(peer);
											send_state(peer);
										}
										break;
									}
								case 11:
									{
										if (world == nullptr || pData->currentWorld == "EXIT" || serverIsFrozen) break;
										if (!world) break;
										if (world->DisableDrop && pData->rawName != world->owner && !isDev(peer)) {
											Player::OnTextOverlay(peer, "Collecting is disabled here!");
											break;
										}
										try {
											int blockX = static_cast<int>(pMov->x) / 32;
											int blockY = static_cast<int>(pMov->y) / 32;
											if (blockX < 0 || blockY < 0 || blockX > world->width || blockY > world->height) break;
											if (world->items.at(blockX + (blockY * world->width)).foreground != 0 && getItemDef(world->items.at(blockX + (blockY * world->width)).foreground).blockType == BlockTypes::FOREGROUND || world->items.at(blockX + (blockY * world->width)).foreground != 0 && getItemDef(world->items.at(blockX + (blockY * world->width)).foreground).blockType == BlockTypes::DISPLAY) {
												break;
											}
											bool legit = true;
											int itemIdx = pMov->plantingTree - 1;
											int atik = -1;
											try
											{
												for (int i = 0; i < world->droppedItems.size(); i++)
												{
													if (world->droppedItems.at(i).uid == itemIdx)
													{
														atik = i;
														break;
													}
												}
											}
											catch (...)
											{
												break;
											}
											legit = atik != -1;
											if (legit)
											{
												DroppedItem droppedItem = world->droppedItems.at(atik);
												legit = true;
											}
											if (legit) {
												if (pData->x / 32 == blockX || pData->x / 32 + 1 == blockX || pData->x / 32 - 1 == blockX || pData->x / 32 + 2 == blockX || pData->x / 32 - 2 == blockX) {
													DroppedItem droppedItem = world->droppedItems.at(atik);
													if (getItemDef(droppedItem.id).blockType == BlockTypes::FISH) {
														auto iscontains = false;
														SearchInventoryItem(peer, droppedItem.id, 1, iscontains);
														if (iscontains) {
															Player::OnTalkBubble(peer, pData->netID, "`1(Item maxed)", 0, true);
															break;
														}
													} if (droppedItem.id != 112) {
														if (CheckItemMaxed(peer, droppedItem.id, droppedItem.count)) {
															if (atoi(GetItemCount(peer, droppedItem.id).c_str()) < 250 && droppedItem.count > (250 - atoi(GetItemCount(peer, droppedItem.id).c_str()))) {
																int xdrop = droppedItem.x;
																int ydrop = droppedItem.y;
																int iddrop = droppedItem.id;
																int give_count = (250 - atoi(GetItemCount(peer, droppedItem.id).c_str()));
																int idcount = droppedItem.count - (250 - atoi(GetItemCount(peer, droppedItem.id).c_str()));
																world->droppedItems.erase(world->droppedItems.begin() + atik);
																SendTake(peer, pData->netID, pMov->x, pMov->y, itemIdx + 1);
																DropItem(world, peer, -1, xdrop, ydrop, iddrop, idcount, 0);
																if (getItemDef(droppedItem.id).rarity == 999) {
																	Player::OnConsoleMessage(peer, "`oCollected `w" + to_string(give_count) + " " + getItemDef(iddrop).name + "`o.");
																} else {
																	Player::OnConsoleMessage(peer, "`oCollected `w" + to_string(give_count) + " " + getItemDef(iddrop).name + "`o. Rarity: `w" + to_string(getItemDef(droppedItem.id).rarity) + "`o.");
																}
																auto success = true;
																SaveDroppedItem(iddrop, give_count, peer, success);
															} else {
																Player::OnTalkBubble(peer, pData->netID, "`1(Item maxed)", 0, true);
															}
															break;
														} if (CheckItemExists(peer, droppedItem.id) == false) {
															if (pData->inventory.items.size() == pData->currentInventorySize) {
																Player::OnTalkBubble(peer, pData->netID, "`1(Inventory is full)", 0, true);
																break;
															}
														}
													} if (droppedItem.id == 112) {
														if (droppedItem.count == 1) world->items.at(blockX + (blockY * world->width)).yellowGems--;
														if (droppedItem.count == 5) world->items.at(blockX + (blockY * world->width)).blueGems--;
														if (droppedItem.count == 10) world->items.at(blockX + (blockY * world->width)).redGems--;
														if (droppedItem.count == 50) world->items.at(blockX + (blockY * world->width)).greenGems--;
														if (droppedItem.count == 100) world->items.at(blockX + (blockY * world->width)).purpleGems--;
														try {
															std::ifstream ifsz("save/gemdb/_" + pData->rawName + ".txt");
															if (!ifsz.is_open()) {
																SendConsole("TXT Exception #2 Failed to open TXT for reading " + pData->rawName, "ERROR");
																break;
															}
															std::string content((std::istreambuf_iterator<char>(ifsz)), (std::istreambuf_iterator<char>()));
															int gembux = atoi(content.c_str());
															int fingembux = gembux + droppedItem.count;
															ofstream myfile;
															myfile.open("save/gemdb/_" + pData->rawName + ".txt");
															myfile << fingembux;
															myfile.close();
															int gemcalc = gembux + droppedItem.count;
															Player::OnSetBux(peer, gemcalc, 0);
															const auto p3 = packetEnd(appendFloat(appendIntx(appendFloat(appendFloat(appendFloat(appendString(createPacket(), "OnSetClothing"), (static_cast<PlayerInfo*>(peer->data))->cloth_hair, (static_cast<PlayerInfo*>(peer->data))->cloth_shirt, (static_cast<PlayerInfo*>(peer->data))->cloth_pants), (static_cast<PlayerInfo*>(peer->data))->cloth_feet, (static_cast<PlayerInfo*>(peer->data))->cloth_face, (static_cast<PlayerInfo*>(peer->data))->cloth_hand), (static_cast<PlayerInfo*>(peer->data))->cloth_back, (static_cast<PlayerInfo*>(peer->data))->cloth_mask, (static_cast<PlayerInfo*>(peer->data))->cloth_necklace), (static_cast<PlayerInfo*>(peer->data))->skinColor), (static_cast<PlayerInfo*>(peer->data))->cloth_ances, 0.0f, 0.0f));
															memcpy(p3.data + 8, &((static_cast<PlayerInfo*>(peer->data))->netID), 4);
															const auto packet = enet_packet_create(p3.data, p3.len, ENET_PACKET_FLAG_RELIABLE);
															enet_peer_send(peer, 0, packet);
															delete p3.data;
														} catch (std::exception& e) {
															std::cout << e.what() << std::endl;
															break; 
														}
													} else {
														auto success = true;
														SaveDroppedItem(droppedItem.id, droppedItem.count, peer, success);
													}
													if (getItemDef(droppedItem.id).rarity == 999) {
														if (droppedItem.id != 112) {
															bool found_one = false;
															auto cctv = std::experimental::filesystem::exists("save/cctv/_" + ((PlayerInfo*)(peer->data))->currentWorld + ".json");
															for (int i = 0; i < world->width * world->height; i++) {
																if (world->items.at(i).foreground == 1436 && cctv) {
																	found_one = true;
																}
															}
															if (found_one) {
																ifstream ifff("save/cctv/_" + ((PlayerInfo*)(peer->data))->currentWorld + ".json");
																json j;
																ifff >> j;
																ifff.close();
																if (j["ShowItemTake"] == true && j["DontShowOwner"] == true && j["DontShowAdmin"] == true) {
																	if (!isWorldOwner(peer, world) || !isWorldAdmin(peer, world)) {
																		vector<string> currentLogs;
																		for (int i = 0; i < j["logs"].size(); i++) {
																			currentLogs.push_back(j["logs"][i]);
																		}
																		time_t currentTime; struct tm* localTime; char buffer[80]; time(&currentTime); localTime = localtime(&currentTime);
																		int Mon = localTime->tm_mon + 1; int Day = localTime->tm_mday; int Hour = localTime->tm_hour; int Min = localTime->tm_min; int Sec = localTime->tm_sec;
																		string tolog = "`w" + ((PlayerInfo*)(peer->data))->displayName + "`w took " + to_string(droppedItem.count) + " " + getItemDef(droppedItem.id).name + " at " + to_string(Hour) + ":" + to_string(Min) + " on " + to_string(Mon) + "/" + to_string(Day) + "";
																		currentLogs.push_back(tolog);
																		j["logs"] = currentLogs;
																		ofstream fs("save/cctv/_" + ((PlayerInfo*)(peer->data))->currentWorld + ".json");
																		fs << j;
																		fs.close();
																	}
																}
																else if (j["ShowItemTake"] == true && j["DontShowOwner"] == true) {
																	if (!isWorldOwner(peer, world)) {
																		vector<string> currentLogs;
																		for (int i = 0; i < j["logs"].size(); i++) {
																			currentLogs.push_back(j["logs"][i]);
																		}
																		time_t currentTime; struct tm* localTime; char buffer[80]; time(&currentTime); localTime = localtime(&currentTime);
																		int Mon = localTime->tm_mon + 1; int Day = localTime->tm_mday; int Hour = localTime->tm_hour; int Min = localTime->tm_min; int Sec = localTime->tm_sec;
																		string tolog = "`w" + ((PlayerInfo*)(peer->data))->displayName + "`w took " + to_string(droppedItem.count) + " " + getItemDef(droppedItem.id).name + " at " + to_string(Hour) + ":" + to_string(Min) + " on " + to_string(Mon) + "/" + to_string(Day) + "";
																		currentLogs.push_back(tolog);
																		j["logs"] = currentLogs;
																		ofstream fs("save/cctv/_" + ((PlayerInfo*)(peer->data))->currentWorld + ".json");
																		fs << j;
																		fs.close();
																	}
																}
																else if (j["ShowItemTake"] == true && j["DontShowAdmin"] == true) {
																	if (!isWorldAdmin(peer, world)) {
																		vector<string> currentLogs;
																		for (int i = 0; i < j["logs"].size(); i++) {
																			currentLogs.push_back(j["logs"][i]);
																		}
																		time_t currentTime; struct tm* localTime; char buffer[80]; time(&currentTime); localTime = localtime(&currentTime);
																		int Mon = localTime->tm_mon + 1; int Day = localTime->tm_mday; int Hour = localTime->tm_hour; int Min = localTime->tm_min; int Sec = localTime->tm_sec;
																		string tolog = "`w" + ((PlayerInfo*)(peer->data))->displayName + "`w took " + to_string(droppedItem.count) + " " + getItemDef(droppedItem.id).name + " at " + to_string(Hour) + ":" + to_string(Min) + " on " + to_string(Mon) + "/" + to_string(Day) + "";
																		currentLogs.push_back(tolog);
																		j["logs"] = currentLogs;
																		ofstream fs("save/cctv/_" + ((PlayerInfo*)(peer->data))->currentWorld + ".json");
																		fs << j;
																		fs.close();
																	}
																}
																else if (j["ShowItemTake"] == false && j["DontShowOwner"] == false && j["DontShowAdmin"] == false || j["ShowItemTake"] == false && j["DontShowOwner"] == false || j["ShowItemTake"] == false && j["DontShowAdmin"] == false || j["ShowItemTake"] == false && j["DontShowAdmin"] == true || j["ShowItemTake"] == false && j["DontShowOwner"] == true || j["ShowItemTake"] == false && j["DontShowOwner"] == true && j["DontShowAdmin"] == true) {
																}
																else {
																	vector<string> currentLogs;
																	for (int i = 0; i < j["logs"].size(); i++) {
																		currentLogs.push_back(j["logs"][i]);
																	}
																	time_t currentTime; struct tm* localTime; char buffer[80]; time(&currentTime); localTime = localtime(&currentTime);
																	int Mon = localTime->tm_mon + 1; int Day = localTime->tm_mday; int Hour = localTime->tm_hour; int Min = localTime->tm_min; int Sec = localTime->tm_sec;
																	string tolog = "`w" + ((PlayerInfo*)(peer->data))->displayName + "`w took " + to_string(droppedItem.count) + " " + getItemDef(droppedItem.id).name + " at " + to_string(Hour) + ":" + to_string(Min) + " on " + to_string(Mon) + "/" + to_string(Day) + "";
																	currentLogs.push_back(tolog);
																	j["logs"] = currentLogs;
																	ofstream fs("save/cctv/_" + ((PlayerInfo*)(peer->data))->currentWorld + ".json");
																	fs << j;
																	fs.close();
																}
															}
															Player::OnConsoleMessage(peer, "`oCollected `w" + to_string(droppedItem.count) + " " + getItemDef(droppedItem.id).name + "`o.");
														}
													} else {
														bool found_one = false;
														auto cctv = std::experimental::filesystem::exists("save/cctv/_" + ((PlayerInfo*)(peer->data))->currentWorld + ".json");
														for (int i = 0; i < world->width * world->height; i++) {
															if (world->items.at(i).foreground == 1436 && cctv) {
																found_one = true;
															}
														}
														if (found_one) {
															ifstream ifff("save/cctv/_" + ((PlayerInfo*)(peer->data))->currentWorld + ".json");
															json j;
															ifff >> j;
															ifff.close();
															if (j["ShowItemTake"] == true && j["DontShowOwner"] == true && j["DontShowAdmin"] == true) {
																if (!isWorldOwner(peer, world) || !isWorldAdmin(peer, world)) {
																	vector<string> currentLogs;
																	for (int i = 0; i < j["logs"].size(); i++) {
																		currentLogs.push_back(j["logs"][i]);
																	}
																	time_t currentTime; struct tm* localTime; char buffer[80]; time(&currentTime); localTime = localtime(&currentTime);
																	int Mon = localTime->tm_mon + 1; int Day = localTime->tm_mday; int Hour = localTime->tm_hour; int Min = localTime->tm_min; int Sec = localTime->tm_sec;
																	string tolog = "`w" + ((PlayerInfo*)(peer->data))->displayName + "`w took " + to_string(droppedItem.count) + " " + getItemDef(droppedItem.id).name + " at " + to_string(Hour) + ":" + to_string(Min) + " on " + to_string(Mon) + "/" + to_string(Day) + "";
																	currentLogs.push_back(tolog);
																	j["logs"] = currentLogs;
																	ofstream fs("save/cctv/_" + ((PlayerInfo*)(peer->data))->currentWorld + ".json");
																	fs << j;
																	fs.close();
																}
															}
															else if (j["ShowItemTake"] == true && j["DontShowOwner"] == true) {
																if (!isWorldOwner(peer, world)) {
																	vector<string> currentLogs;
																	for (int i = 0; i < j["logs"].size(); i++) {
																		currentLogs.push_back(j["logs"][i]);
																	}
																	time_t currentTime; struct tm* localTime; char buffer[80]; time(&currentTime); localTime = localtime(&currentTime);
																	int Mon = localTime->tm_mon + 1; int Day = localTime->tm_mday; int Hour = localTime->tm_hour; int Min = localTime->tm_min; int Sec = localTime->tm_sec;
																	string tolog = "`w" + ((PlayerInfo*)(peer->data))->displayName + "`w took " + to_string(droppedItem.count) + " " + getItemDef(droppedItem.id).name + " at " + to_string(Hour) + ":" + to_string(Min) + " on " + to_string(Mon) + "/" + to_string(Day) + "";
																	currentLogs.push_back(tolog);
																	j["logs"] = currentLogs;
																	ofstream fs("save/cctv/_" + ((PlayerInfo*)(peer->data))->currentWorld + ".json");
																	fs << j;
																	fs.close();
																}
															}
															else if (j["ShowItemTake"] == true && j["DontShowAdmin"] == true) {
																if (!isWorldAdmin(peer, world)) {
																	vector<string> currentLogs;
																	for (int i = 0; i < j["logs"].size(); i++) {
																		currentLogs.push_back(j["logs"][i]);
																	}
																	time_t currentTime; struct tm* localTime; char buffer[80]; time(&currentTime); localTime = localtime(&currentTime);
																	int Mon = localTime->tm_mon + 1; int Day = localTime->tm_mday; int Hour = localTime->tm_hour; int Min = localTime->tm_min; int Sec = localTime->tm_sec;
																	string tolog = "`w" + ((PlayerInfo*)(peer->data))->displayName + "`w took " + to_string(droppedItem.count) + " " + getItemDef(droppedItem.id).name + " at " + to_string(Hour) + ":" + to_string(Min) + " on " + to_string(Mon) + "/" + to_string(Day) + "";
																	currentLogs.push_back(tolog);
																	j["logs"] = currentLogs;
																	ofstream fs("save/cctv/_" + ((PlayerInfo*)(peer->data))->currentWorld + ".json");
																	fs << j;
																	fs.close();
																}
															}
															else if (j["ShowItemTake"] == false && j["DontShowOwner"] == false && j["DontShowAdmin"] == false || j["ShowItemTake"] == false && j["DontShowOwner"] == false || j["ShowItemTake"] == false && j["DontShowAdmin"] == false || j["ShowItemTake"] == false && j["DontShowAdmin"] == true || j["ShowItemTake"] == false && j["DontShowOwner"] == true || j["ShowItemTake"] == false && j["DontShowOwner"] == true && j["DontShowAdmin"] == true) {
															}
															else {
																vector<string> currentLogs;
																for (int i = 0; i < j["logs"].size(); i++) {
																	currentLogs.push_back(j["logs"][i]);
																}
																time_t currentTime; struct tm* localTime; char buffer[80]; time(&currentTime); localTime = localtime(&currentTime);
																int Mon = localTime->tm_mon + 1; int Day = localTime->tm_mday; int Hour = localTime->tm_hour; int Min = localTime->tm_min; int Sec = localTime->tm_sec;
																string tolog = "`w" + ((PlayerInfo*)(peer->data))->displayName + "`w took " + to_string(droppedItem.count) + " " + getItemDef(droppedItem.id).name + " at " + to_string(Hour) + ":" + to_string(Min) + " on " + to_string(Mon) + "/" + to_string(Day) + "";
																currentLogs.push_back(tolog);
																j["logs"] = currentLogs;
																ofstream fs("save/cctv/_" + ((PlayerInfo*)(peer->data))->currentWorld + ".json");
																fs << j;
																fs.close();
															}
														}
														Player::OnConsoleMessage(peer, "`oCollected `w" + to_string(droppedItem.count) + " " + getItemDef(droppedItem.id).name + "`o. Rarity: `w" + to_string(getItemDef(droppedItem.id).rarity) + "`o.");
													}
													world->droppedItems.erase(world->droppedItems.begin() + atik);
													SendTake(peer, pData->netID, pMov->x, pMov->y, itemIdx + 1);
												} else {
													Player::OnTalkBubble(peer, pData->netID, "Error collecting dropped item, please try again", 0, true);
												}
											}
										} catch(const std::out_of_range& e) {
											std::cout << e.what() << std::endl;
										} 
										break;
									}
								case 23:
									{
										try {
											int hit_x = (pMov->plantingTree % world->width);
											int hit_y = (pMov->plantingTree / world->width);
											for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
												if (isHere(peer, currentPeer)) {
													if (pData->x / 32 == hit_x && pData->y / 32 == hit_y || pData->x / 32 + 1 == hit_x && pData->y / 32 == hit_y || pData->x / 32 + 2 == hit_x && pData->y / 32 == hit_y || pData->x / 32 - 1 == hit_x && pData->y / 32 == hit_y || pData->x / 32 - 2 == hit_x && pData->y / 32 == hit_y) {
														if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == pData->rawName) continue;
														if (jammers) {
															bool punchJammer = false;
															for (auto i = 0; i < world->width * world->height; i++) {
																if (world->items.at(i).foreground == 1276 && world->items.at(i).activated) {
																	punchJammer = true;
																	break;
																}
															}
															if (punchJammer) break;
														}
														if (static_cast<PlayerInfo*>(currentPeer->data)->cloth_hand == 3466) {
															static_cast<PlayerInfo*>(currentPeer->data)->TotalKills++;
															if (static_cast<PlayerInfo*>(currentPeer->data)->quest_active && static_cast<PlayerInfo*>(currentPeer->data)->lastquest == "honor" && static_cast<PlayerInfo*>(currentPeer->data)->quest_step == 2 && static_cast<PlayerInfo*>(currentPeer->data)->quest_progress < 100) {
																static_cast<PlayerInfo*>(currentPeer->data)->quest_progress++;
																if (static_cast<PlayerInfo*>(currentPeer->data)->quest_progress >= 100) {
																	static_cast<PlayerInfo*>(currentPeer->data)->quest_progress = 100;
																	Player::OnTalkBubble(currentPeer, static_cast<PlayerInfo*>(currentPeer->data)->netID, "`9Legendary Quest step complete! I'm off to see a Wizard!", 0, false);
																}
															}
															playerRespawn(world, peer, false);
														}
														else if (static_cast<PlayerInfo*>(currentPeer->data)->isZombie == true && pData->isZombie == false) {
															if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == pData->rawName) continue;
															if (jammers) {
																bool zombieJammer = false;
																for (auto i = 0; i < world->width * world->height; i++) {
																	if (world->items.at(i).foreground == 1278 && world->items.at(i).activated) {
																		zombieJammer = true;
																		break;
																	}
																}
																if (zombieJammer) break;
															}
															if (pData->canWalkInBlocks == true) {
																pData->canWalkInBlocks = false;
																pData->skinColor = 0x8295C3FF;
																send_state(peer);
															}
															Player::OnAddNotification(peer, "`4You were infected by " + static_cast<PlayerInfo*>(currentPeer->data)->rawName + "`4!", "audio/skel.wav", "interface/large/infected.rttex");
															pData->isZombie = true;
															playerconfig(peer, 1150, 130, 0x14);
														}
														//break;
													}
												}
											}
										}
										catch (const std::out_of_range& e) {
											std::cout << e.what() << std::endl;
										}
										break;
									}
								case 7:
									{
										if (pData->currentWorld == "EXIT") continue;
										try {
											if (pMov->punchX < 0 || pMov->punchY < 0 || pMov->punchX > 100 || pMov->punchY > 100) continue;
											int x = pMov->punchX;
											int y = pMov->punchY;
											int idx = pMov->punchY * world->width + pMov->punchX;
											if (getItemDef(world->items.at(idx).foreground).blockType == BlockTypes::DOOR || getItemDef(world->items.at(idx).foreground).blockType == BlockTypes::PORTAL) {
												if (world->items.at(idx).DoorLocked == true && !isWorldOwner(peer, world) && !isWorldAdmin(peer, world)) {
													auto respawnTimeout = 200; auto deathFlag = 0x19;
													auto p23 = packetEnd(appendIntx(appendFloat(appendString(createPacket(), "OnZoomCamera"), 10000.000000), 1000));
													memcpy(p23.data + 24, &respawnTimeout, 4);
													memcpy(p23.data + 56, &deathFlag, 4);
													const auto packet2 = enet_packet_create(p23.data, p23.len, ENET_PACKET_FLAG_RELIABLE);
													enet_peer_send(peer, 0, packet2);
													delete p23.data;
													auto p234 = packetEnd(appendIntx(appendString(createPacket(), "OnSetFreezeState"), 0));
													memcpy(p234.data + 8, &(((PlayerInfo*)(peer->data))->netID), 4);
													memcpy(p234.data + 24, &respawnTimeout, 4);
													memcpy(p234.data + 56, &deathFlag, 4);
													const auto packet23 = enet_packet_create(p234.data, p234.len, ENET_PACKET_FLAG_RELIABLE);
													enet_peer_send(peer, 0, packet23);
													delete p234.data;
													Player::OnTalkBubble(peer, ((PlayerInfo*)(peer->data))->netID, "The door is locked.", 0, false);
													doorlocked(peer, world->items.at(idx).foreground, idx % world->width, idx / world->width, "`4<Locked>");
												}
												else {
													if (world->items.at(idx).foreground == 762) {
														auto respawnTimeout = 200;
														auto deathFlag = 0x19;
														auto p23 = packetEnd(appendIntx(appendFloat(appendString(createPacket(), "OnZoomCamera"), 10000.000000), 1000));
														memcpy(p23.data + 24, &respawnTimeout, 4);
														memcpy(p23.data + 56, &deathFlag, 4);
														const auto packet2 = enet_packet_create(p23.data, p23.len, ENET_PACKET_FLAG_RELIABLE);
														enet_peer_send(peer, 0, packet2);
														delete p23.data;
														auto p234 = packetEnd(appendIntx(appendString(createPacket(), "OnSetFreezeState"), 0));
														memcpy(p234.data + 8, &(pData->netID), 4);
														memcpy(p234.data + 24, &respawnTimeout, 4);
														memcpy(p234.data + 56, &deathFlag, 4);
														const auto packet23 = enet_packet_create(p234.data, p234.len, ENET_PACKET_FLAG_RELIABLE);
														enet_peer_send(peer, 0, packet23);
														delete p234.data;
														string DoorLabelDialog = getItemDef(world->items.at(idx).foreground).name;
														if (world->items.at(idx).label != "") DoorLabelDialog = world->items.at(idx).label;
														pData->lastPunchX = pMov->punchX;
														pData->lastPunchY = pMov->punchY;
														pData->wrenchsession = pMov->punchX + (pMov->punchY * world->width);
														auto p234s = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\nadd_label_with_icon|big|`w" + DoorLabelDialog + "``|left|762|\nadd_textbox|The door requires a password.|left|\nadd_text_input|password|Password||24|\nend_dialog|password_reply|Cancel|OK|"));
														memcpy(p234s.data + 24, &respawnTimeout, 4);
														memcpy(p234s.data + 56, &deathFlag, 4);
														const auto packet234 = enet_packet_create(p234s.data, p234s.len, ENET_PACKET_FLAG_RELIABLE);
														enet_peer_send(peer, 0, packet234);
														delete p234s.data;
													}
													else
													{
														DoEnterDoor(peer, world, pMov->punchX, pMov->punchY);
													}
												}
											}
											else if (getItemDef(world->items.at(idx).foreground).blockType == BlockTypes::MAIN_DOOR) {
												Player::OnConsoleMessage(peer, "Where would you like to go? (`w" + GetPlayerCountServer() + " `oonline)");
												sendPlayerLeave(peer);
												sendWorldOffers(peer);
											}
											else if (getItemDef(world->items.at(idx).foreground).blockType == BlockTypes::CHECKPOINT) {
												((PlayerInfo*)(peer->data))->ischeck = true;
												((PlayerInfo*)(peer->data))->checkx = x * 32;
												((PlayerInfo*)(peer->data))->checky = y * 32;
												GamePacket p2 = packetEnd(appendInt(appendString(createPacket(), "SetRespawnPos"), x + (y * world->width)));
												memcpy(p2.data + 8, &((PlayerInfo*)(event.peer->data))->netID, 4);
												ENetPacket* packet2 = enet_packet_create(p2.data,
													p2.len,
													ENET_PACKET_FLAG_RELIABLE);
												enet_peer_send(peer, 0, packet2);
												delete p2.data;
											}
										}
										catch (const std::out_of_range& e) {
											std::cout << e.what() << std::endl;
										}
										break;
									}
								case 10:
									{
										if (pData->currentWorld == "EXIT") continue;
										try {
											if (pData->trade) end_trade(peer);
											if (pMov->plantingTree == 6336) {
												SendGrowpedia(peer);
												break;
											}
											if (pMov->plantingTree == 242) {
												bool iscontainseas = false;
												SearchInventoryItem(peer, pMov->plantingTree, 1, iscontainseas);
												if (!iscontainseas) break;
												for (int i = 0; i < pData->inventory.items.size(); i++) {
													if (pData->inventory.items.at(i).itemID == 242) {
														if (pData->inventory.items.at(i).itemCount >= 100) {
															bool isValid = SaveConvertedItem(1796, 1, peer);
															if (isValid) {
																RemoveInventoryItem(pMov->plantingTree, 100, peer, true);
																Player::OnTalkBubble(peer, pData->netID, "`wYou compressed 100 `2World Lock `winto a `2Diamond Lock`w!", 0, true);
																Player::OnConsoleMessage(peer, "`oYou compressed 100 `2World Lock `ointo a `2Diamond Lock`o!");
															}
														}
													}
												}
												break;
											}
											else if (pMov->plantingTree == 1796) {
												bool iscontainseas = false;
												SearchInventoryItem(peer, pMov->plantingTree, 1, iscontainseas);
												if (!iscontainseas) break;
												for (int i = 0; i < pData->inventory.items.size(); i++) {
													if (pData->inventory.items.at(i).itemID == 1796) {
														if (pData->inventory.items.at(i).itemCount >= 1) {
															bool isValid = SaveConvertedItemDls(242, 100, peer);
															if (isValid) {
																RemoveInventoryItem(pMov->plantingTree, 1, peer, true);
																Player::OnTalkBubble(peer, pData->netID, "`wYou shattered a `2Diamond Lock `winto 100 `2World Lock`w!", 0, true);
																Player::OnConsoleMessage(peer, "`oYou shattered a `2Diamond Lock `ointo 100 `2World Lock`o!");
															}
														}
													}
												}
												break;
											}
											else if (pMov->plantingTree == 7188) {
												bool iscontainseas = false;
												SearchInventoryItem(peer, pMov->plantingTree, 1, iscontainseas);
												if (!iscontainseas) break;
												for (int i = 0; i < pData->inventory.items.size(); i++) {
													if (pData->inventory.items.at(i).itemID == 7188) {
														if (pData->inventory.items.at(i).itemCount >= 1) {
															bool isValid = SaveConvertedItemDls(1796, 100, peer);
															if (isValid) {
																RemoveInventoryItem(pMov->plantingTree, 1, peer, true);
																Player::OnTalkBubble(peer, pData->netID, "`wYou shattered a `2Blue Gem Lock `winto 100 `2Diamond Lock`w!", 0, true);
																Player::OnConsoleMessage(peer, "`oYou shattered a `2Blue Gem Lock `ointo 100 `2Diamond Lock`o!");
															}
														}
													}
												}
												break;
											}
											if (pData->Fishing) {
												Player::OnTalkBubble(peer, pData->netID, "`wYou cant do that while fishing`w!", 0, true);
												continue;
											}
											equip_item(peer, pMov->plantingTree, getItemDef(pMov->plantingTree).clothType);
										}
										catch (const std::out_of_range& e) {
											std::cout << e.what() << std::endl;
										}
										break;
									}
								case 18:
									{
										sendPData(peer, pMov);
										break;
									}
								default:
									{
										break;
									}
								}
								if (pMov->punchX != -1 && pMov->punchY != -1) {
									if (pMov->packetType == 3) {
										if (pData->currentWorld == "EXIT") continue;
										if (pData->isRotatedLeft = pMov->characterState & 0x10) {
											pData->RotatedLeft = true;
										} else {
											pData->RotatedLeft = false;
										}
										if (pData->trade) end_trade(peer);
										if (pData->lastBREAK + 150 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) {
											pData->lastBREAK = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
											if (pMov->plantingTree == 18) {
												if (triple_punch.find(pData->cloth_hand) != triple_punch.end() || triple_punch.find(pData->cloth_back) != triple_punch.end() || triple_punch.find(pData->cloth_necklace) != triple_punch.end()) {
													if (pData->cloth_face != 4288 && pData->isZombie == false) {
														if (pData->isRotatedLeft = pMov->characterState & 0x10) {
															pData->RotatedLeft = true;
														} else {
															pData->RotatedLeft = false;
														} if (pMov->punchY == pData->y / 32) {
															if (pData->RotatedLeft == true) {
																sendTileUpdate(pMov->punchX, pMov->punchY, pMov->plantingTree, pData->netID, peer, world);
																sendTileUpdate(pMov->punchX - 1, pMov->punchY, pMov->plantingTree, pData->netID, peer, world);
																sendTileUpdate(pMov->punchX - 2, pMov->punchY, pMov->plantingTree, pData->netID, peer, world);
															} else {
																sendTileUpdate(pMov->punchX, pMov->punchY, pMov->plantingTree, pData->netID, peer, world);
																sendTileUpdate(pMov->punchX + 1, pMov->punchY, pMov->plantingTree, pData->netID, peer, world);
																sendTileUpdate(pMov->punchX + 2, pMov->punchY, pMov->plantingTree, pData->netID, peer, world);
															}
														} else if (pMov->punchX == pData->x / 32) {
															if (pMov->punchY > pData->y / 32) {
																sendTileUpdate(pMov->punchX, pMov->punchY, pMov->plantingTree, pData->netID, peer, world);
																sendTileUpdate(pMov->punchX, pMov->punchY + 1, pMov->plantingTree, pData->netID, peer, world);
																sendTileUpdate(pMov->punchX, pMov->punchY + 2, pMov->plantingTree, pData->netID, peer, world);
															} else if (pMov->punchY < pData->y / 32) {
																sendTileUpdate(pMov->punchX, pMov->punchY, pMov->plantingTree, pData->netID, peer, world);
																sendTileUpdate(pMov->punchX, pMov->punchY - 1, pMov->plantingTree, pData->netID, peer, world);
																sendTileUpdate(pMov->punchX, pMov->punchY - 2, pMov->plantingTree, pData->netID, peer, world);
															} else {
																sendTileUpdate(pMov->punchX, pMov->punchY, pMov->plantingTree, pData->netID, peer, world);
															}
														} else if (pMov->punchY < pData->y / 32) {
															if (pData->RotatedLeft == true) {
																sendTileUpdate(pMov->punchX, pMov->punchY, pMov->plantingTree, pData->netID, peer, world);
																sendTileUpdate(pMov->punchX - 1, pMov->punchY - 1, pMov->plantingTree, pData->netID, peer, world);
																sendTileUpdate(pMov->punchX - 2, pMov->punchY - 2, pMov->plantingTree, pData->netID, peer, world);
															} else {
																sendTileUpdate(pMov->punchX, pMov->punchY, pMov->plantingTree, pData->netID, peer, world);
																sendTileUpdate(pMov->punchX + 1, pMov->punchY - 1, pMov->plantingTree, pData->netID, peer, world);
																sendTileUpdate(pMov->punchX + 2, pMov->punchY - 2, pMov->plantingTree, pData->netID, peer, world);
															}
														} else if (pMov->punchY < pData->y / 32) {
															if (pData->RotatedLeft == true) {
																sendTileUpdate(pMov->punchX, pMov->punchY, pMov->plantingTree, pData->netID, peer, world);
																sendTileUpdate(pMov->punchX - 1, pMov->punchY - 1, pMov->plantingTree, pData->netID, peer, world);
																sendTileUpdate(pMov->punchX - 2, pMov->punchY - 2, pMov->plantingTree, pData->netID, peer, world);
															} else {
																sendTileUpdate(pMov->punchX, pMov->punchY, pMov->plantingTree, pData->netID, peer, world);
																sendTileUpdate(pMov->punchX + 1, pMov->punchY - 1, pMov->plantingTree, pData->netID, peer, world);
																sendTileUpdate(pMov->punchX + 2, pMov->punchY - 2, pMov->plantingTree, pData->netID, peer, world);
															}
														} else if (pMov->punchY > pData->y / 32) {
															if (pData->RotatedLeft == true) {
																sendTileUpdate(pMov->punchX, pMov->punchY, pMov->plantingTree, pData->netID, peer, world);
																sendTileUpdate(pMov->punchX - 1, pMov->punchY + 1, pMov->plantingTree, pData->netID, peer, world);
																sendTileUpdate(pMov->punchX - 2, pMov->punchY + 2, pMov->plantingTree, pData->netID, peer, world);
															} else {
																sendTileUpdate(pMov->punchX, pMov->punchY, pMov->plantingTree, pData->netID, peer, world);
																sendTileUpdate(pMov->punchX + 1, pMov->punchY + 1, pMov->plantingTree, pData->netID, peer, world);
																sendTileUpdate(pMov->punchX + 2, pMov->punchY + 2, pMov->plantingTree, pData->netID, peer, world);
															}
														}
													}
													else 
													{
														sendTileUpdate(pMov->punchX, pMov->punchY, pMov->plantingTree, pData->netID, peer, world);
													}
												}
												else if (pData->cloth_hand == 5480 || four_punch.find(pData->cloth_hand) != four_punch.end() || four_punch.find(pData->cloth_back) != four_punch.end() || four_punch.find(pData->cloth_necklace) != four_punch.end()) {
													if (pData->cloth_face != 4288 && pData->isZombie == false) {
														if (pData->isRotatedLeft = pMov->characterState & 0x10) {
															pData->RotatedLeft = true;
														}
														else {
															pData->RotatedLeft = false;
														} if (pMov->punchY == pData->y / 32) {
															if (pData->RotatedLeft == true) {
																sendTileUpdate(pMov->punchX, pMov->punchY, pMov->plantingTree, pData->netID, peer, world);
																sendTileUpdate(pMov->punchX - 1, pMov->punchY, pMov->plantingTree, pData->netID, peer, world);
																sendTileUpdate(pMov->punchX - 2, pMov->punchY, pMov->plantingTree, pData->netID, peer, world);
																sendTileUpdate(pMov->punchX - 3, pMov->punchY, pMov->plantingTree, pData->netID, peer, world);
															}
															else {
																sendTileUpdate(pMov->punchX, pMov->punchY, pMov->plantingTree, pData->netID, peer, world);
																sendTileUpdate(pMov->punchX + 1, pMov->punchY, pMov->plantingTree, pData->netID, peer, world);
																sendTileUpdate(pMov->punchX + 2, pMov->punchY, pMov->plantingTree, pData->netID, peer, world);
																sendTileUpdate(pMov->punchX + 3, pMov->punchY, pMov->plantingTree, pData->netID, peer, world);
															}
														}
														else if (pMov->punchX == pData->x / 32) {
															if (pMov->punchY > pData->y / 32) {
																sendTileUpdate(pMov->punchX, pMov->punchY, pMov->plantingTree, pData->netID, peer, world);
																sendTileUpdate(pMov->punchX, pMov->punchY + 1, pMov->plantingTree, pData->netID, peer, world);
																sendTileUpdate(pMov->punchX, pMov->punchY + 2, pMov->plantingTree, pData->netID, peer, world);
																sendTileUpdate(pMov->punchX, pMov->punchY + 3, pMov->plantingTree, pData->netID, peer, world);
															}
															else if (pMov->punchY < pData->y / 32) {
																sendTileUpdate(pMov->punchX, pMov->punchY, pMov->plantingTree, pData->netID, peer, world);
																sendTileUpdate(pMov->punchX, pMov->punchY - 1, pMov->plantingTree, pData->netID, peer, world);
																sendTileUpdate(pMov->punchX, pMov->punchY - 2, pMov->plantingTree, pData->netID, peer, world);
																sendTileUpdate(pMov->punchX, pMov->punchY - 3, pMov->plantingTree, pData->netID, peer, world);
															}
															else {
																sendTileUpdate(pMov->punchX, pMov->punchY, pMov->plantingTree, pData->netID, peer, world);
															}
														}
														else if (pMov->punchY < pData->y / 32) {
															if (pData->RotatedLeft == true) {
																sendTileUpdate(pMov->punchX, pMov->punchY, pMov->plantingTree, pData->netID, peer, world);
																sendTileUpdate(pMov->punchX - 1, pMov->punchY - 1, pMov->plantingTree, pData->netID, peer, world);
																sendTileUpdate(pMov->punchX - 2, pMov->punchY - 2, pMov->plantingTree, pData->netID, peer, world);
																sendTileUpdate(pMov->punchX - 3, pMov->punchY - 3, pMov->plantingTree, pData->netID, peer, world);
															}
															else {
																sendTileUpdate(pMov->punchX, pMov->punchY, pMov->plantingTree, pData->netID, peer, world);
																sendTileUpdate(pMov->punchX + 1, pMov->punchY - 1, pMov->plantingTree, pData->netID, peer, world);
																sendTileUpdate(pMov->punchX + 2, pMov->punchY - 2, pMov->plantingTree, pData->netID, peer, world);
																sendTileUpdate(pMov->punchX + 3, pMov->punchY - 3, pMov->plantingTree, pData->netID, peer, world);
															}
														}
														else if (pMov->punchY < pData->y / 32) {
															if (pData->RotatedLeft == true) {
																sendTileUpdate(pMov->punchX, pMov->punchY, pMov->plantingTree, pData->netID, peer, world);
																sendTileUpdate(pMov->punchX - 1, pMov->punchY - 1, pMov->plantingTree, pData->netID, peer, world);
																sendTileUpdate(pMov->punchX - 2, pMov->punchY - 2, pMov->plantingTree, pData->netID, peer, world);
																sendTileUpdate(pMov->punchX - 3, pMov->punchY - 3, pMov->plantingTree, pData->netID, peer, world);
															}
															else {
																sendTileUpdate(pMov->punchX, pMov->punchY, pMov->plantingTree, pData->netID, peer, world);
																sendTileUpdate(pMov->punchX + 1, pMov->punchY - 1, pMov->plantingTree, pData->netID, peer, world);
																sendTileUpdate(pMov->punchX + 2, pMov->punchY - 2, pMov->plantingTree, pData->netID, peer, world);
																sendTileUpdate(pMov->punchX + 3, pMov->punchY - 3, pMov->plantingTree, pData->netID, peer, world);
															}
														}
														else if (pMov->punchY > pData->y / 32) {
															if (pData->RotatedLeft == true) {
																sendTileUpdate(pMov->punchX, pMov->punchY, pMov->plantingTree, pData->netID, peer, world);
																sendTileUpdate(pMov->punchX - 1, pMov->punchY + 1, pMov->plantingTree, pData->netID, peer, world);
																sendTileUpdate(pMov->punchX - 2, pMov->punchY + 2, pMov->plantingTree, pData->netID, peer, world);
																sendTileUpdate(pMov->punchX - 3, pMov->punchY + 3, pMov->plantingTree, pData->netID, peer, world);
															}
															else {
																sendTileUpdate(pMov->punchX, pMov->punchY, pMov->plantingTree, pData->netID, peer, world);
																sendTileUpdate(pMov->punchX + 1, pMov->punchY + 1, pMov->plantingTree, pData->netID, peer, world);
																sendTileUpdate(pMov->punchX + 2, pMov->punchY + 2, pMov->plantingTree, pData->netID, peer, world);
																sendTileUpdate(pMov->punchX + 3, pMov->punchY + 3, pMov->plantingTree, pData->netID, peer, world);
															}
														}
													}
												}
												else if (five_punch.find(pData->cloth_hand) != five_punch.end() || five_punch.find(pData->cloth_back) != five_punch.end() || five_punch.find(pData->cloth_necklace) != five_punch.end()) {
													if (pData->cloth_face != 4288 && pData->isZombie == false) {
														if (pData->isRotatedLeft = pMov->characterState & 0x10) {
															pData->RotatedLeft = true;
														}
														else {
															pData->RotatedLeft = false;
														} if (pMov->punchY == pData->y / 32) {
															if (pData->RotatedLeft == true) {
																sendTileUpdate(pMov->punchX, pMov->punchY, pMov->plantingTree, pData->netID, peer, world);
																sendTileUpdate(pMov->punchX - 1, pMov->punchY, pMov->plantingTree, pData->netID, peer, world);
																sendTileUpdate(pMov->punchX - 2, pMov->punchY, pMov->plantingTree, pData->netID, peer, world);
																sendTileUpdate(pMov->punchX - 3, pMov->punchY, pMov->plantingTree, pData->netID, peer, world);
																sendTileUpdate(pMov->punchX - 4, pMov->punchY, pMov->plantingTree, pData->netID, peer, world);
															}
															else {
																sendTileUpdate(pMov->punchX, pMov->punchY, pMov->plantingTree, pData->netID, peer, world);
																sendTileUpdate(pMov->punchX + 1, pMov->punchY, pMov->plantingTree, pData->netID, peer, world);
																sendTileUpdate(pMov->punchX + 2, pMov->punchY, pMov->plantingTree, pData->netID, peer, world);
																sendTileUpdate(pMov->punchX + 3, pMov->punchY, pMov->plantingTree, pData->netID, peer, world);
																sendTileUpdate(pMov->punchX + 4, pMov->punchY, pMov->plantingTree, pData->netID, peer, world);
															}
														}
														else if (pMov->punchX == pData->x / 32) {
															if (pMov->punchY > pData->y / 32) {
																sendTileUpdate(pMov->punchX, pMov->punchY, pMov->plantingTree, pData->netID, peer, world);
																sendTileUpdate(pMov->punchX, pMov->punchY + 1, pMov->plantingTree, pData->netID, peer, world);
																sendTileUpdate(pMov->punchX, pMov->punchY + 2, pMov->plantingTree, pData->netID, peer, world);
																sendTileUpdate(pMov->punchX, pMov->punchY + 3, pMov->plantingTree, pData->netID, peer, world);
																sendTileUpdate(pMov->punchX, pMov->punchY + 4, pMov->plantingTree, pData->netID, peer, world);
															}
															else if (pMov->punchY < pData->y / 32) {
																sendTileUpdate(pMov->punchX, pMov->punchY, pMov->plantingTree, pData->netID, peer, world);
																sendTileUpdate(pMov->punchX, pMov->punchY - 1, pMov->plantingTree, pData->netID, peer, world);
																sendTileUpdate(pMov->punchX, pMov->punchY - 2, pMov->plantingTree, pData->netID, peer, world);
																sendTileUpdate(pMov->punchX, pMov->punchY - 3, pMov->plantingTree, pData->netID, peer, world);
																sendTileUpdate(pMov->punchX, pMov->punchY - 4, pMov->plantingTree, pData->netID, peer, world);
															}
															else {
																sendTileUpdate(pMov->punchX, pMov->punchY, pMov->plantingTree, pData->netID, peer, world);
															}
														}
														else if (pMov->punchY < pData->y / 32) {
															if (pData->RotatedLeft == true) {
																sendTileUpdate(pMov->punchX, pMov->punchY, pMov->plantingTree, pData->netID, peer, world);
																sendTileUpdate(pMov->punchX - 1, pMov->punchY - 1, pMov->plantingTree, pData->netID, peer, world);
																sendTileUpdate(pMov->punchX - 2, pMov->punchY - 2, pMov->plantingTree, pData->netID, peer, world);
																sendTileUpdate(pMov->punchX - 3, pMov->punchY - 3, pMov->plantingTree, pData->netID, peer, world);
																sendTileUpdate(pMov->punchX - 4, pMov->punchY - 4, pMov->plantingTree, pData->netID, peer, world);
															}
															else {
																sendTileUpdate(pMov->punchX, pMov->punchY, pMov->plantingTree, pData->netID, peer, world);
																sendTileUpdate(pMov->punchX + 1, pMov->punchY - 1, pMov->plantingTree, pData->netID, peer, world);
																sendTileUpdate(pMov->punchX + 2, pMov->punchY - 2, pMov->plantingTree, pData->netID, peer, world);
																sendTileUpdate(pMov->punchX + 3, pMov->punchY - 3, pMov->plantingTree, pData->netID, peer, world);
																sendTileUpdate(pMov->punchX + 4, pMov->punchY - 4, pMov->plantingTree, pData->netID, peer, world);
															}
														}
														else if (pMov->punchY < pData->y / 32) {
															if (pData->RotatedLeft == true) {
																sendTileUpdate(pMov->punchX, pMov->punchY, pMov->plantingTree, pData->netID, peer, world);
																sendTileUpdate(pMov->punchX - 1, pMov->punchY - 1, pMov->plantingTree, pData->netID, peer, world);
																sendTileUpdate(pMov->punchX - 2, pMov->punchY - 2, pMov->plantingTree, pData->netID, peer, world);
																sendTileUpdate(pMov->punchX - 3, pMov->punchY - 3, pMov->plantingTree, pData->netID, peer, world);
																sendTileUpdate(pMov->punchX - 4, pMov->punchY - 4, pMov->plantingTree, pData->netID, peer, world);
															}
															else {
																sendTileUpdate(pMov->punchX, pMov->punchY, pMov->plantingTree, pData->netID, peer, world);
																sendTileUpdate(pMov->punchX + 1, pMov->punchY - 1, pMov->plantingTree, pData->netID, peer, world);
																sendTileUpdate(pMov->punchX + 2, pMov->punchY - 2, pMov->plantingTree, pData->netID, peer, world);
																sendTileUpdate(pMov->punchX + 3, pMov->punchY - 3, pMov->plantingTree, pData->netID, peer, world);
																sendTileUpdate(pMov->punchX + 4, pMov->punchY - 4, pMov->plantingTree, pData->netID, peer, world);
															}
														}
														else if (pMov->punchY > pData->y / 32) {
															if (pData->RotatedLeft == true) {
																sendTileUpdate(pMov->punchX, pMov->punchY, pMov->plantingTree, pData->netID, peer, world);
																sendTileUpdate(pMov->punchX - 1, pMov->punchY + 1, pMov->plantingTree, pData->netID, peer, world);
																sendTileUpdate(pMov->punchX - 2, pMov->punchY + 2, pMov->plantingTree, pData->netID, peer, world);
																sendTileUpdate(pMov->punchX - 3, pMov->punchY + 3, pMov->plantingTree, pData->netID, peer, world);
																sendTileUpdate(pMov->punchX - 4, pMov->punchY + 4, pMov->plantingTree, pData->netID, peer, world);
															}
															else {
																sendTileUpdate(pMov->punchX, pMov->punchY, pMov->plantingTree, pData->netID, peer, world);
																sendTileUpdate(pMov->punchX + 1, pMov->punchY + 1, pMov->plantingTree, pData->netID, peer, world);
																sendTileUpdate(pMov->punchX + 2, pMov->punchY + 2, pMov->plantingTree, pData->netID, peer, world);
																sendTileUpdate(pMov->punchX + 3, pMov->punchY + 3, pMov->plantingTree, pData->netID, peer, world);
																sendTileUpdate(pMov->punchX + 4, pMov->punchY + 4, pMov->plantingTree, pData->netID, peer, world);
															}
														}
													}
												}
												else
												{
													sendTileUpdate(pMov->punchX, pMov->punchY, pMov->plantingTree, pData->netID, peer, world);
												}
											} else {
												if (pData->PlacePotion || triple_place.find(pData->cloth_hand) != triple_place.end() || triple_place.find(pData->cloth_hair) != triple_place.end() || triple_place.find(pData->cloth_necklace) != triple_place.end() || triple_place.find(pData->cloth_back) != triple_place.end()) {
													if ((static_cast<PlayerInfo*>(peer->data))->isRotatedLeft = pMov->characterState & 0x10) {
														(static_cast<PlayerInfo*>(peer->data))->RotatedLeft = true;
													} else {
														(static_cast<PlayerInfo*>(peer->data))->RotatedLeft = false;
													} if ((static_cast<PlayerInfo*>(peer->data))->RotatedLeft == true) {
														sendTileUpdate(pMov->punchX, pMov->punchY, pMov->plantingTree, (static_cast<PlayerInfo*>(peer->data))->netID, peer, world);
														sendTileUpdate(pMov->punchX - 1, pMov->punchY, pMov->plantingTree, (static_cast<PlayerInfo*>(peer->data))->netID, peer, world);
														sendTileUpdate(pMov->punchX - 2, pMov->punchY, pMov->plantingTree, (static_cast<PlayerInfo*>(peer->data))->netID, peer, world);
													} else {
														sendTileUpdate(pMov->punchX, pMov->punchY, pMov->plantingTree, (static_cast<PlayerInfo*>(peer->data))->netID, peer, world);
														sendTileUpdate(pMov->punchX + 1, pMov->punchY, pMov->plantingTree, (static_cast<PlayerInfo*>(peer->data))->netID, peer, world);
														sendTileUpdate(pMov->punchX + 2, pMov->punchY, pMov->plantingTree, (static_cast<PlayerInfo*>(peer->data))->netID, peer, world);
													}
												}
												else if (four_place.find(pData->cloth_hand) != four_place.end() || four_place.find(pData->cloth_hair) != four_place.end() || four_place.find(pData->cloth_necklace) != four_place.end() || four_place.find(pData->cloth_back) != four_place.end()) {
													if ((static_cast<PlayerInfo*>(peer->data))->isRotatedLeft = pMov->characterState & 0x10) {
														(static_cast<PlayerInfo*>(peer->data))->RotatedLeft = true;
													}
													else {
														(static_cast<PlayerInfo*>(peer->data))->RotatedLeft = false;
													} if ((static_cast<PlayerInfo*>(peer->data))->RotatedLeft == true) {
														sendTileUpdate(pMov->punchX, pMov->punchY, pMov->plantingTree, (static_cast<PlayerInfo*>(peer->data))->netID, peer, world);
														sendTileUpdate(pMov->punchX - 1, pMov->punchY, pMov->plantingTree, (static_cast<PlayerInfo*>(peer->data))->netID, peer, world);
														sendTileUpdate(pMov->punchX - 2, pMov->punchY, pMov->plantingTree, (static_cast<PlayerInfo*>(peer->data))->netID, peer, world);
														sendTileUpdate(pMov->punchX - 3, pMov->punchY, pMov->plantingTree, (static_cast<PlayerInfo*>(peer->data))->netID, peer, world);
													}
													else {
														sendTileUpdate(pMov->punchX, pMov->punchY, pMov->plantingTree, (static_cast<PlayerInfo*>(peer->data))->netID, peer, world);
														sendTileUpdate(pMov->punchX + 1, pMov->punchY, pMov->plantingTree, (static_cast<PlayerInfo*>(peer->data))->netID, peer, world);
														sendTileUpdate(pMov->punchX + 2, pMov->punchY, pMov->plantingTree, (static_cast<PlayerInfo*>(peer->data))->netID, peer, world);
														sendTileUpdate(pMov->punchX + 3, pMov->punchY, pMov->plantingTree, (static_cast<PlayerInfo*>(peer->data))->netID, peer, world);
													}
												}
												else if (five_place.find(pData->cloth_hand) != five_place.end() || five_place.find(pData->cloth_hair) != five_place.end() || five_place.find(pData->cloth_necklace) != five_place.end() || five_place.find(pData->cloth_back) != five_place.end()) {
													if ((static_cast<PlayerInfo*>(peer->data))->isRotatedLeft = pMov->characterState & 0x10) {
														(static_cast<PlayerInfo*>(peer->data))->RotatedLeft = true;
													}
													else {
														(static_cast<PlayerInfo*>(peer->data))->RotatedLeft = false;
													} if ((static_cast<PlayerInfo*>(peer->data))->RotatedLeft == true) {
														sendTileUpdate(pMov->punchX, pMov->punchY, pMov->plantingTree, (static_cast<PlayerInfo*>(peer->data))->netID, peer, world);
														sendTileUpdate(pMov->punchX - 1, pMov->punchY, pMov->plantingTree, (static_cast<PlayerInfo*>(peer->data))->netID, peer, world);
														sendTileUpdate(pMov->punchX - 2, pMov->punchY, pMov->plantingTree, (static_cast<PlayerInfo*>(peer->data))->netID, peer, world);
														sendTileUpdate(pMov->punchX - 3, pMov->punchY, pMov->plantingTree, (static_cast<PlayerInfo*>(peer->data))->netID, peer, world);
														sendTileUpdate(pMov->punchX - 4, pMov->punchY, pMov->plantingTree, (static_cast<PlayerInfo*>(peer->data))->netID, peer, world);
													}
													else {
														sendTileUpdate(pMov->punchX, pMov->punchY, pMov->plantingTree, (static_cast<PlayerInfo*>(peer->data))->netID, peer, world);
														sendTileUpdate(pMov->punchX + 1, pMov->punchY, pMov->plantingTree, (static_cast<PlayerInfo*>(peer->data))->netID, peer, world);
														sendTileUpdate(pMov->punchX + 2, pMov->punchY, pMov->plantingTree, (static_cast<PlayerInfo*>(peer->data))->netID, peer, world);
														sendTileUpdate(pMov->punchX + 3, pMov->punchY, pMov->plantingTree, (static_cast<PlayerInfo*>(peer->data))->netID, peer, world);
														sendTileUpdate(pMov->punchX + 4, pMov->punchY, pMov->plantingTree, (static_cast<PlayerInfo*>(peer->data))->netID, peer, world);
													}
												}
												else
												{
													sendTileUpdate(pMov->punchX, pMov->punchY, pMov->plantingTree, (static_cast<PlayerInfo*>(peer->data))->netID, peer, world);
												}
											}
										}
									}
								}
								delete pMov;
							} 
						}
						default:
						{
							break;
						}
					}
					enet_packet_destroy(event.packet);
					break;
				}
				case ENET_EVENT_TYPE_DISCONNECT:
				{
					ENetPeer* peer = event.peer;
					if (peer->data != NULL) {
						PlayerInfo* pData = GetPeerData(peer);
						if (pData->haveGrowId && pData->isIn && pData->HasLogged && pData->rawName != "") {	
							for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED || currentPeer->data == NULL) continue;
								string name = static_cast<PlayerInfo*>(currentPeer->data)->rawName;
								if (find(pData->friendinfo.begin(), pData->friendinfo.end(), name) != pData->friendinfo.end()) {
									Player::PlayAudio(currentPeer, "audio/friend_logoff.wav", 0);
									Player::OnConsoleMessage(currentPeer, "`!FRIEND ALERT : `w" + pData->displayName + " `ohas `4logged off`o.");
								}
							}
							if (pData->PerformingSurgery) end_surgery(peer, true);
							save_playerinfo(pData);
						}
						sendPlayerLeave(peer);
						if (clearpeer) {
							pData->inventory.items.clear();
							delete peer->data;
							peer->data = NULL;
						}
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
							PlayerInfo* pinf = ((PlayerInfo*)(currentPeer->data));
							checkMonitor(currentPeer, pinf->x, pinf->y);
						}
					}
					ofstream write_new_online("online_count.txt");
					write_new_online << atoi(GetPlayerCountServer().c_str());
					write_new_online.close();
					break;
				}
				default: 
				{
					break;
				}
			}
		}
	}
	cout << "Program ended??? Huh?" << endl;
	system("PAUSE");
};
